{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo disciplina de Elementos de Sistemas! \u00b6 Curso: Engenharia Da Computa\u00e7\u00e3o - Terceiro semestre Disciplina: Elementos de Sistemas Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/Insper/Z01.1 Local: Laborat\u00f3rio de Inform\u00e1tica - 404 \u00a9 Todos os direitos reservados Objetivos de aprendizagem \u00b6 Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Motiva\u00e7\u00e3o \u00b6 Desenvolver um computador do ZERO! Avalia\u00e7\u00e3o \u00b6 A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso. Infraestrutura \u00b6 O ferramental da disciplina foi desenvolvido para o sistema operacional Linux , e necessita de uma s\u00e9rie de softwares e configura\u00e7\u00f5es para funcionar. Detalhes da instala\u00e7\u00e3o pode ser acessado aqui . Bibliografia \u00b6 B\u00e1sica \u00b6 Livros NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, \u00aa ed., MIT Press, 2005 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: Artigos KHAN, S. et. Al.. A high performance processor architecture for multimedia applications. Computer & Electrical Engineering. , v. 66 , p. 14-29 , 2018. ; Dispon\u00edvel em: https://www.sciencedirect.com/science/article/pii/S0045790616305894 . Acesso em: 04 ago 2019. Complementar \u00b6 Livros MOORE, Cristopher ; MERTENS, Stephan., The Nature of Computation, \u00aa ed., University Press, 2011 STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Bem vindo disciplina de Elementos de Sistemas!"},{"location":"#bem-vindo-disciplina-de-elementos-de-sistemas","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Terceiro semestre Disciplina: Elementos de Sistemas Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/Insper/Z01.1 Local: Laborat\u00f3rio de Inform\u00e1tica - 404 \u00a9 Todos os direitos reservados","title":"Bem vindo disciplina de Elementos de Sistemas!"},{"location":"#objetivos-de-aprendizagem","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores.","title":"Objetivos de aprendizagem"},{"location":"#motivacao","text":"Desenvolver um computador do ZERO!","title":"Motiva\u00e7\u00e3o"},{"location":"#avaliacao","text":"A disciplina \u00e9 avaliada em duas frentes: avalia\u00e7\u00e3o individual e APS: Individual: ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro avalia\u00e7\u00f5es (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre. APS: Compostas por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso.","title":"Avalia\u00e7\u00e3o"},{"location":"#infraestrutura","text":"O ferramental da disciplina foi desenvolvido para o sistema operacional Linux , e necessita de uma s\u00e9rie de softwares e configura\u00e7\u00f5es para funcionar. Detalhes da instala\u00e7\u00e3o pode ser acessado aqui .","title":"Infraestrutura"},{"location":"#bibliografia","text":"","title":"Bibliografia"},{"location":"#basica","text":"Livros NISAN, Noam; SCHOCKEN, Shimon., The Elements of Computing Systems, \u00aa ed., MIT Press, 2005 TOCCI, R. J.; WIDMER, N. S.; MOSS, G. L., Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es, 11\u00aa ed., Pearson, 2011 PATTERSON, D.; HENNESSY, J. L., Organiza\u00e7\u00e3o e Projeto de Computadores: A Interface Hardware/Software., 4\u00aa ed., Campus, Artigos: Artigos KHAN, S. et. Al.. A high performance processor architecture for multimedia applications. Computer & Electrical Engineering. , v. 66 , p. 14-29 , 2018. ; Dispon\u00edvel em: https://www.sciencedirect.com/science/article/pii/S0045790616305894 . Acesso em: 04 ago 2019.","title":"B\u00e1sica"},{"location":"#complementar","text":"Livros MOORE, Cristopher ; MERTENS, Stephan., The Nature of Computation, \u00aa ed., University Press, 2011 STALLINGS, W., Arquitetura e organiza\u00e7\u00e3o de computadores, 8\u00aa ed., Prentice Hall Brasil, 2010 LAING, Gordon., Digital Retro: The Evolution and Design of the Personal Computer, \u00aa ed., Sybex, 2004 NIELSEN, L., Computing: A Business History, \u00aa ed., New Street Communications LLC, 2012 FLOYD, T. L., Digital Fundamentals, 11\u00aa ed., Pearson, 2015","title":"Complementar"},{"location":"A-Transistores-Lab-1/","text":"L\u00f3gica Combinacional - Lab 1 \u00b6 Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT . Assim como desenvolver o trabalho em grupo via a fragmenta\u00e7\u00e3o das atividades em m\u00f3dulos. Materiais \u00b6 Cada grupo receber\u00e1: Duas protoboards Duas baterias 9V Jumpers macho-macho 12 transistores BJT-N BC337 24 resistores de 2k 6 LEDs coloridos (Vermelho, amarelo e verde) Exemplo \u00b6 Para implementarmos uma equa\u00e7\u00e3o l\u00f3gica, devemos primeiramente identificar por quais portas l\u00f3gicas b\u00e1sicas a mesma \u00e9 constitu\u00edda: NOT, AND, NAND, OR, NOR, XOR . Por exemplo : Q = (A.B)+C \u00c9 equivalente a: Q = (A AND B) OR C Que pode ser fracionada em duas etapas: I = A AND B Q = I OR C Podendo ser implementado com uma AND (.) e uma OR (+). Cada porta l\u00f3gica (AND, OR) por sua vez pode ser implementada a partir de transistores e resistores Resistor-Transistor logic gates - RTL . L\u00f3gico: Implementa\u00e7\u00e3o: Note Esse ser\u00e1 o mesmo material utilizado para o Projeto A - Transistores , guardem com voc\u00eas. Simulando \u00b6 Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o, a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideias\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( www.falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( www.circuitlab.com ). 1. N\u00edvel l\u00f3gico Abra o site: https://simulator.io/board/Hwf7pzFS1Y/1 2 N\u00edvel F\u00edsico: Transistores O simulador l\u00f3gico do exemplo est\u00e1 localizado na pasta da aula (03-Transistores) com o nome de 03-Simulador-RTL-Exe1.txt . O mesmo deve ser carregado no site Falstad . 2 N\u00edvel F\u00edsico: SPICE Abra a p\u00e1gina: CircuitLab e simule o circuito. Implementando \u00b6 O grupo deve se organizar e executar da melhor forma poss\u00edvel (com todos participando) os m\u00f3dulos a seguir, utilizando: Entradas: Utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . Sa\u00eddas: A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0. Valida\u00e7\u00e3o: Uma tabela verdade do circuito deve ser apresentada e em aula demonstrado que o circuito representa a tabela. 1a - NOT \u00b6 Cada grupo deve realizar duas implementa\u00e7\u00f5es do circuito a seguir que representa uma NOT : Para isso, deveremos utilizar a protoboard e o transistor recebido, a pinagem do transistor pode ser encontrada na p\u00e1gina do datasheet em anexo a esse Handout. Exerc\u00edcio 1a Levante a tabela verdade do circuito rec\u00e9m montado Warning Se voc\u00ea perceber que algum transistor est\u00e1 aquecendo, desconecte a bateria e verifique novamente a montagem. Isso \u00e9 um sinal que alguma coisa est\u00e1 errada. 1b - NOT NOT \u00b6 Agora que as duas NOT foram implementadas, testadas e est\u00e3o funcionado, conecte a sa\u00edda de uma na entrada da outra. Isso vai fazer com que a sa\u00edda siga o valor de refer\u00eancia da entrada. Exerc\u00edcio 1b Levante a tabela verdade do circuito rec\u00e9m montado 2 - Equa\u00e7\u00e3o \u00b6 Implemente de forma modular (cada parte do grupo faz uma parte e no final junta-se a fim de montar a equa\u00e7\u00e3o original) a equa\u00e7\u00e3o l\u00f3gica a seguir em um circuito do tipo RTL. Q = A.(A.(A+B)+A.C) Exerc\u00edcio 2 Levante a tabela verdade do circuito rec\u00e9m montado Refer\u00eancias \u00b6 A p\u00e1gina: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c4 possui exemplos de diversas portas l\u00f3gicas que podem ser implementadas via RTL. J\u00e1 o site https://www.electronics-tutorials.ws/logic/logic_1.html possui uma parte te\u00f3rica mais trabalhada.","title":"2 : A Transistores Lab 1"},{"location":"A-Transistores-Lab-1/#logica-combinacional-lab-1","text":"Esse laborat\u00f3rio tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas do tipo RTL realizadas a base de transistores discretos do tipo BJT . Assim como desenvolver o trabalho em grupo via a fragmenta\u00e7\u00e3o das atividades em m\u00f3dulos.","title":"L\u00f3gica Combinacional - Lab 1"},{"location":"A-Transistores-Lab-1/#materiais","text":"Cada grupo receber\u00e1: Duas protoboards Duas baterias 9V Jumpers macho-macho 12 transistores BJT-N BC337 24 resistores de 2k 6 LEDs coloridos (Vermelho, amarelo e verde)","title":"Materiais"},{"location":"A-Transistores-Lab-1/#exemplo","text":"Para implementarmos uma equa\u00e7\u00e3o l\u00f3gica, devemos primeiramente identificar por quais portas l\u00f3gicas b\u00e1sicas a mesma \u00e9 constitu\u00edda: NOT, AND, NAND, OR, NOR, XOR . Por exemplo : Q = (A.B)+C \u00c9 equivalente a: Q = (A AND B) OR C Que pode ser fracionada em duas etapas: I = A AND B Q = I OR C Podendo ser implementado com uma AND (.) e uma OR (+). Cada porta l\u00f3gica (AND, OR) por sua vez pode ser implementada a partir de transistores e resistores Resistor-Transistor logic gates - RTL . L\u00f3gico: Implementa\u00e7\u00e3o: Note Esse ser\u00e1 o mesmo material utilizado para o Projeto A - Transistores , guardem com voc\u00eas.","title":"Exemplo"},{"location":"A-Transistores-Lab-1/#simulando","text":"Existem basicamente tr\u00eas n\u00edveis de simula\u00e7\u00e3o, a primeira, puramente l\u00f3gica utiliza de portas l\u00f3gicas \"ideias\" ( https://simulator.io/board ). Um simulador mais preciso ir\u00e1 utilizar transistores para a implementa\u00e7\u00e3o dessas portas l\u00f3gicas por\u00e9m n\u00e3o leva em considera\u00e7\u00e3o todos os fatores f\u00edsicos-eletr\u00f4nicos dos componentes ( www.falstad.com/circuit/ ). J\u00e1 um simulador que leva em considera\u00e7\u00e3o as propriedades dos componentes \u00e9 chamado de SPICE e ir\u00e1 gerar uma simula\u00e7\u00e3o mais precisa em termos f\u00edsicos do circuito original ( www.circuitlab.com ). 1. N\u00edvel l\u00f3gico Abra o site: https://simulator.io/board/Hwf7pzFS1Y/1 2 N\u00edvel F\u00edsico: Transistores O simulador l\u00f3gico do exemplo est\u00e1 localizado na pasta da aula (03-Transistores) com o nome de 03-Simulador-RTL-Exe1.txt . O mesmo deve ser carregado no site Falstad . 2 N\u00edvel F\u00edsico: SPICE Abra a p\u00e1gina: CircuitLab e simule o circuito.","title":"Simulando"},{"location":"A-Transistores-Lab-1/#implementando","text":"O grupo deve se organizar e executar da melhor forma poss\u00edvel (com todos participando) os m\u00f3dulos a seguir, utilizando: Entradas: Utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . Sa\u00eddas: A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0. Valida\u00e7\u00e3o: Uma tabela verdade do circuito deve ser apresentada e em aula demonstrado que o circuito representa a tabela.","title":"Implementando"},{"location":"A-Transistores-Lab-1/#1a-not","text":"Cada grupo deve realizar duas implementa\u00e7\u00f5es do circuito a seguir que representa uma NOT : Para isso, deveremos utilizar a protoboard e o transistor recebido, a pinagem do transistor pode ser encontrada na p\u00e1gina do datasheet em anexo a esse Handout. Exerc\u00edcio 1a Levante a tabela verdade do circuito rec\u00e9m montado Warning Se voc\u00ea perceber que algum transistor est\u00e1 aquecendo, desconecte a bateria e verifique novamente a montagem. Isso \u00e9 um sinal que alguma coisa est\u00e1 errada.","title":"1a - NOT"},{"location":"A-Transistores-Lab-1/#1b-not-not","text":"Agora que as duas NOT foram implementadas, testadas e est\u00e3o funcionado, conecte a sa\u00edda de uma na entrada da outra. Isso vai fazer com que a sa\u00edda siga o valor de refer\u00eancia da entrada. Exerc\u00edcio 1b Levante a tabela verdade do circuito rec\u00e9m montado","title":"1b - NOT NOT"},{"location":"A-Transistores-Lab-1/#2-equacao","text":"Implemente de forma modular (cada parte do grupo faz uma parte e no final junta-se a fim de montar a equa\u00e7\u00e3o original) a equa\u00e7\u00e3o l\u00f3gica a seguir em um circuito do tipo RTL. Q = A.(A.(A+B)+A.C) Exerc\u00edcio 2 Levante a tabela verdade do circuito rec\u00e9m montado","title":"2 - Equa\u00e7\u00e3o"},{"location":"A-Transistores-Lab-1/#referencias","text":"A p\u00e1gina: http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html#c4 possui exemplos de diversas portas l\u00f3gicas que podem ser implementadas via RTL. J\u00e1 o site https://www.electronics-tutorials.ws/logic/logic_1.html possui uma parte te\u00f3rica mais trabalhada.","title":"Refer\u00eancias"},{"location":"A-Transistores-Lab-2/","text":"Devemos come\u00e7ar a preparar o terreno para os projetos em grupo que estar\u00e3o por vir, nessa etapa voc\u00ea deve montar um grupo de \u215a colegas e dar um nome a ele (os grupos s\u00e3o nomeados por letras, a primeira letra do nome do seu grupo deve ser aquela que foi fornecida em sala de aula). O grupo ir\u00e1 trabalhar de forma colaborativa via a utiliza\u00e7\u00e3o do git/ github. \u00c9 imprescind\u00edvel que todos trabalhem dessa forma, pois ser\u00e1 a maneira que iremos avaliar individualmente voc\u00eas. 1. GitHub \u00b6 O git ser\u00e1 uma das ferramentas mais importantes para o projeto, com as etapas a seguir voc\u00eas realizaram um Fork do reposit\u00f3rio do projeto e adicionaram os colaboradores. Fork \u00b6 Warning S\u00f3 uma pessoa do grupo deve fazer! O Scrum Master do grupo (ser\u00e1 sorteado em sala) dever\u00e1 realizar o fork do reposit\u00f3rio do projeto do computador Z01, para isso, basta acessar a p\u00e1gina do github do projeto: https://github.com/Insper/Z01.1 E no site clicar em fork : Note que criar um fork \u00e9 diferente de criar apenas uma c\u00f3pia. No fork o seu reposit\u00f3rio ainda possui como refer\u00eancia o original (/insper/Z01.1) o que possibilitar\u00e1 que voc\u00eas atualizem o reposit\u00f3rio com novos materiais que ser\u00e3o necess\u00e1rios ao longo do semestre sem perder o que j\u00e1 foi feito e mais importante sem muito trabalho. git Fork \u00e9 quando 'copiamos' um reposit\u00f3rio para podermos trabalhar nele sem a necessidade de mexermos no original. Alterando o nome do Fork \u00b6 Acesse a p\u00e1gina do reposit\u00f3rio de voc\u00eas no github SETTINGS Repository Name e altere o nome do reposit\u00f3rio para: nome : Z01.1-NomeDoGrupo Colaboradores \u00b6 Isso ir\u00e1 criar uma c\u00f3pia do reposit\u00f3rio na sua conta, uma vez realizado a c\u00f3pia ser\u00e1 necess\u00e1rio inserir os demais colegas como integrantes desse reposit\u00f3rio (para que eles possam propor altera\u00e7\u00f5es). Para isso v\u00e1 at\u00e9 a p\u00e1gina do reposit\u00f3rio na sua conta e clique em Settings Collaborators e adicione os usu\u00e1rios ou e-mails dos seus colegas. Note que todos devem ter uma conta no github j\u00e1 criada. Clonando \u00b6 Uma vez criado o fork* e adicionado os colegas voc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone URL_DO_FORK Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal: windows + t Ap\u00f3s clonar o reposit\u00f3rio devemos baixar e atualizar os submodules , ainda no terminal, v\u00e1 para a pasta do reposit\u00f3rio $ cd Z01.1-NomeDoGrupo/ E execute os seguintes comandos no terminal: $ git submodule update --init --recursive $ git submodule foreach 'git stash; git checkout master; git pull' git submodules s\u00e3o reposit\u00f3rios git dentro de um reposit\u00f3rio git. Editando nome do grupo \u00b6 Ap\u00f3s clonar o reposit\u00f3rio o mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma frase com a primeira palavra come\u00e7ando com a letra do Grupo). exemplo um grupo com a letra M , GRUPO.json : { \"Nome-Grupo\" : \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio.","title":"1 : A Transistores Lab 2"},{"location":"A-Transistores-Lab-2/#1-github","text":"O git ser\u00e1 uma das ferramentas mais importantes para o projeto, com as etapas a seguir voc\u00eas realizaram um Fork do reposit\u00f3rio do projeto e adicionaram os colaboradores.","title":"1. GitHub"},{"location":"A-Transistores-Lab-2/#fork","text":"Warning S\u00f3 uma pessoa do grupo deve fazer! O Scrum Master do grupo (ser\u00e1 sorteado em sala) dever\u00e1 realizar o fork do reposit\u00f3rio do projeto do computador Z01, para isso, basta acessar a p\u00e1gina do github do projeto: https://github.com/Insper/Z01.1 E no site clicar em fork : Note que criar um fork \u00e9 diferente de criar apenas uma c\u00f3pia. No fork o seu reposit\u00f3rio ainda possui como refer\u00eancia o original (/insper/Z01.1) o que possibilitar\u00e1 que voc\u00eas atualizem o reposit\u00f3rio com novos materiais que ser\u00e3o necess\u00e1rios ao longo do semestre sem perder o que j\u00e1 foi feito e mais importante sem muito trabalho. git Fork \u00e9 quando 'copiamos' um reposit\u00f3rio para podermos trabalhar nele sem a necessidade de mexermos no original.","title":"Fork"},{"location":"A-Transistores-Lab-2/#alterando-o-nome-do-fork","text":"Acesse a p\u00e1gina do reposit\u00f3rio de voc\u00eas no github SETTINGS Repository Name e altere o nome do reposit\u00f3rio para: nome : Z01.1-NomeDoGrupo","title":"Alterando o nome do Fork"},{"location":"A-Transistores-Lab-2/#colaboradores","text":"Isso ir\u00e1 criar uma c\u00f3pia do reposit\u00f3rio na sua conta, uma vez realizado a c\u00f3pia ser\u00e1 necess\u00e1rio inserir os demais colegas como integrantes desse reposit\u00f3rio (para que eles possam propor altera\u00e7\u00f5es). Para isso v\u00e1 at\u00e9 a p\u00e1gina do reposit\u00f3rio na sua conta e clique em Settings Collaborators e adicione os usu\u00e1rios ou e-mails dos seus colegas. Note que todos devem ter uma conta no github j\u00e1 criada.","title":"Colaboradores"},{"location":"A-Transistores-Lab-2/#clonando","text":"Uma vez criado o fork* e adicionado os colegas voc\u00eas dever\u00e3o clonar o reposit\u00f3rio para o computador de voc\u00eas com o comando: $ git clone URL_DO_FORK Linux O s\u00edmbolo $ indica que \u00e9 um comando para ser executado no terminal do Linux ( bash ), mas ele n\u00e3o deve fazer parte do comando. No caso anterior, o comando a ser colado deve ser: git clone URL_DO_FORK . Linux Para abrir o terminal: windows + t Ap\u00f3s clonar o reposit\u00f3rio devemos baixar e atualizar os submodules , ainda no terminal, v\u00e1 para a pasta do reposit\u00f3rio $ cd Z01.1-NomeDoGrupo/ E execute os seguintes comandos no terminal: $ git submodule update --init --recursive $ git submodule foreach 'git stash; git checkout master; git pull' git submodules s\u00e3o reposit\u00f3rios git dentro de um reposit\u00f3rio git.","title":"Clonando"},{"location":"A-Transistores-Lab-2/#editando-nome-do-grupo","text":"Ap\u00f3s clonar o reposit\u00f3rio o mediador desse projeto deve editar o arquivo json GRUPO.json que est\u00e1 localizado na raiz do projeto inserindo a letra do grupo (que foi atribu\u00edda em sala) e o nome rec\u00e9m criado do grupo (o nome do grupo deve ser uma frase com a primeira palavra come\u00e7ando com a letra do Grupo). exemplo um grupo com a letra M , GRUPO.json : { \"Nome-Grupo\" : \"Macarrao\" } Ap\u00f3s editar o arquivo deve-se: fazer um commit e um push para o reposit\u00f3rio.","title":"Editando nome do grupo"},{"location":"A-Transistores-Projeto/","text":"Esse projeto tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas feitas a base de transistores discretos do tipo BJT. Cada grupo receber\u00e1 uma equa\u00e7\u00e3o l\u00f3gica que dever\u00e1 implementar e caber\u00e1 ao grupo decidir a melhor forma de separa\u00e7\u00e3o de trabalho que privilegie a distribui\u00e7\u00e3o de tarefas. Materiais \u00b6 Cada grupo receber\u00e1: Duas protoboards Duas baterias 9V Jumpers macho-macho 12 transistores BJT-N BC337 24 resistores de 2k \\Omega \\Omega 6 LEDs coloridos (Vermelho, amarelo e verde) Poder\u00e3o utilizar a quantidade que material recebido que acharem necess\u00e1rio para realizarem a equa\u00e7\u00e3o l\u00f3gica, n\u00e3o podendo superar a quantidade aqui descrita. Entrega \u00b6 Documenta\u00e7\u00e3o \u00b6 Um documento descrevendo a solu\u00e7\u00e3o empregada deve ser apresentando. O documento deve conter : A equa\u00e7\u00e3o l\u00f3gica original, sua tabela verdade e a equa\u00e7\u00e3o l\u00f3gica implementada, diagrama de blocos l\u00f3gico (contendo as portas l\u00f3gicas) e o RTL do circuito (diagrama com os transistores e resistores), uma foto do circuito montado e um link para um v\u00eddeo do circuito funcionando. N\u00e3o esque\u00e7am da documenta\u00e7\u00e3o, ela \u00e9 t\u00e3o importante quanto a implementa\u00e7\u00e3o! Uma tabela verdade do circuito deve ser apresentada e em aula e uma demonstra\u00e7\u00e3o que o circuito representa a tabela deve ser feita. Simulador : Os grupos devem utilizar simuladores online tal como o circuitLab para validarem suas ideias antes de executarem o projeto, a simula\u00e7\u00e3o dever\u00e1 ser entregue em conjunto com a implementa\u00e7\u00e3o em hardware. Local \u00b6 A entrega da documenta\u00e7\u00e3o deve ser realizada via github no Fork realizado pelo grupo na pasta: Projetos/A-Transistores/ Para isso ser\u00e1 necess\u00e1rio realizar o B-Circuitos-Integrados-Lab- . Na entrega todos os integrantes do grupo j\u00e1 devem fazer parte do reposit\u00f3rio! Rubricas \u00b6 Nota m\u00e1xima Descritivo A+ - Entregue no prazo - Circuito funcionando - Uso m\u00ednimo de transistores - Todos os itens da documenta\u00e7\u00e3o certos B - Entregue no prazo - Circuito funcionado - Um item da documenta\u00e7\u00e3o errado/faltando C - Entregue fora do prazo ou, - N\u00e3o usado a quantidade m\u00ednima de transistores - Um item da documenta\u00e7\u00e3o errado/faltando - Circuito funcionado D - Entregue fora do prazo m\u00e1ximo - Circuito n\u00e3o funcionando - Documenta\u00e7\u00e3o com mais de dois itens errados/faltando I - N\u00e3o entregue","title":"A - Transistores"},{"location":"A-Transistores-Projeto/#materiais","text":"Cada grupo receber\u00e1: Duas protoboards Duas baterias 9V Jumpers macho-macho 12 transistores BJT-N BC337 24 resistores de 2k \\Omega \\Omega 6 LEDs coloridos (Vermelho, amarelo e verde) Poder\u00e3o utilizar a quantidade que material recebido que acharem necess\u00e1rio para realizarem a equa\u00e7\u00e3o l\u00f3gica, n\u00e3o podendo superar a quantidade aqui descrita.","title":"Materiais"},{"location":"A-Transistores-Projeto/#entrega","text":"","title":"Entrega"},{"location":"A-Transistores-Projeto/#documentacao","text":"Um documento descrevendo a solu\u00e7\u00e3o empregada deve ser apresentando. O documento deve conter : A equa\u00e7\u00e3o l\u00f3gica original, sua tabela verdade e a equa\u00e7\u00e3o l\u00f3gica implementada, diagrama de blocos l\u00f3gico (contendo as portas l\u00f3gicas) e o RTL do circuito (diagrama com os transistores e resistores), uma foto do circuito montado e um link para um v\u00eddeo do circuito funcionando. N\u00e3o esque\u00e7am da documenta\u00e7\u00e3o, ela \u00e9 t\u00e3o importante quanto a implementa\u00e7\u00e3o! Uma tabela verdade do circuito deve ser apresentada e em aula e uma demonstra\u00e7\u00e3o que o circuito representa a tabela deve ser feita. Simulador : Os grupos devem utilizar simuladores online tal como o circuitLab para validarem suas ideias antes de executarem o projeto, a simula\u00e7\u00e3o dever\u00e1 ser entregue em conjunto com a implementa\u00e7\u00e3o em hardware.","title":"Documenta\u00e7\u00e3o"},{"location":"A-Transistores-Projeto/#local","text":"A entrega da documenta\u00e7\u00e3o deve ser realizada via github no Fork realizado pelo grupo na pasta: Projetos/A-Transistores/ Para isso ser\u00e1 necess\u00e1rio realizar o B-Circuitos-Integrados-Lab- . Na entrega todos os integrantes do grupo j\u00e1 devem fazer parte do reposit\u00f3rio!","title":"Local"},{"location":"A-Transistores-Projeto/#rubricas","text":"Nota m\u00e1xima Descritivo A+ - Entregue no prazo - Circuito funcionando - Uso m\u00ednimo de transistores - Todos os itens da documenta\u00e7\u00e3o certos B - Entregue no prazo - Circuito funcionado - Um item da documenta\u00e7\u00e3o errado/faltando C - Entregue fora do prazo ou, - N\u00e3o usado a quantidade m\u00ednima de transistores - Um item da documenta\u00e7\u00e3o errado/faltando - Circuito funcionado D - Entregue fora do prazo m\u00e1ximo - Circuito n\u00e3o funcionando - Documenta\u00e7\u00e3o com mais de dois itens errados/faltando I - N\u00e3o entregue","title":"Rubricas"},{"location":"B-Circuitos-Integrados-Lab-1/","text":"Existem diversas fam\u00edlias de Circuitos Integrados (CI) que j\u00e1 possuem a implementa\u00e7\u00e3o da porta l\u00f3gica, conforme figura extra\u00edda do manual a seguir: O uso dos CIs reduz a complexidade da placa j\u00e1 que n\u00e3o \u00e9 mais necess\u00e1rio utilizar transistor de forma discreto para a implementa\u00e7\u00e3o da porta l\u00f3gica, podemos simplesmente utilizar um componente dedicado a isso. Esses componentes de maneira geral possuem n\u00e3o uma porta l\u00f3gica mas v\u00e1rias do mesmo tipo, minimizando assim a quantidade de CIs em uma placa. Note Utilize a mesma t\u00e9cnica da aula passada! As entradas ser\u00e3o \"jumpers\" e as sa\u00eddas Leds. Warning N\u00e3o esque\u00e7a de conectar sempre um resistor em s\u00e9rie com o LED. E devem implementar as seguintes equa\u00e7\u00f5es l\u00f3gicas: A) A XOR B = OUT \u00b6 Que pode ser implementando com o uso da CI 4070 que possui 4 XORs Note que os n\u00f3s A e B s\u00e3o entradas da XOR (pinos 8 e 9 respectivamente) e a sa\u00edda (pino 10) est\u00e1 conectado a um resistor no led e ent\u00e3o para o terra. Para saber contar os pinos do chip encontre o chanfro e come\u00e7o a contar no sentido anti-hor\u00e1rio. B) Equa\u00e7\u00e3o \u00b6 Temos dispon\u00edvel no laborat\u00f3rio os seguintes CIs da fam\u00edlia 40xx que podem ser utilizados para montar o circuito. CD4015, CD4016, CD4017, CD4020, CD4023, CD4024, CD4027, CD4040, CD4046, CD4050, CD4051, CD4069, CD4070, CD4071, CD4081, CD4093, CD4511, CD4538, CD4543, CD4584 CD4001, CD4011, CD4013, CD4049, CD4066 . Note Qual voc\u00ea vai precisar usar para montar essa equa\u00e7\u00e3o? C) Chip misterioso .... \u00b6 Descubra qual a l\u00f3gica por detr\u00e1s do chip misterioso. Explique em um texto o que esse chip faz De exemplos de uso Note Quando chegar aqui procure por algum t\u00e9cnico da 404 D) Trabalhando com NAND \u00b6 Utilizando o simulador logic.ly implemente as seguintes portas l\u00f3gicas utilizando somente NANDs : NOT AND OR XOR NOR XNOR D') Implementando \u00b6 Escolha uma das portas e valide o simulador montando na protoboard.","title":"3 : B CI Lab 2"},{"location":"B-Circuitos-Integrados-Lab-1/#a-a-xor-b-out","text":"Que pode ser implementando com o uso da CI 4070 que possui 4 XORs Note que os n\u00f3s A e B s\u00e3o entradas da XOR (pinos 8 e 9 respectivamente) e a sa\u00edda (pino 10) est\u00e1 conectado a um resistor no led e ent\u00e3o para o terra. Para saber contar os pinos do chip encontre o chanfro e come\u00e7o a contar no sentido anti-hor\u00e1rio.","title":"A)  A XOR B = OUT"},{"location":"B-Circuitos-Integrados-Lab-1/#b-equacao","text":"Temos dispon\u00edvel no laborat\u00f3rio os seguintes CIs da fam\u00edlia 40xx que podem ser utilizados para montar o circuito. CD4015, CD4016, CD4017, CD4020, CD4023, CD4024, CD4027, CD4040, CD4046, CD4050, CD4051, CD4069, CD4070, CD4071, CD4081, CD4093, CD4511, CD4538, CD4543, CD4584 CD4001, CD4011, CD4013, CD4049, CD4066 . Note Qual voc\u00ea vai precisar usar para montar essa equa\u00e7\u00e3o?","title":"B) Equa\u00e7\u00e3o"},{"location":"B-Circuitos-Integrados-Lab-1/#c-chip-misterioso","text":"Descubra qual a l\u00f3gica por detr\u00e1s do chip misterioso. Explique em um texto o que esse chip faz De exemplos de uso Note Quando chegar aqui procure por algum t\u00e9cnico da 404","title":"C) Chip misterioso ...."},{"location":"B-Circuitos-Integrados-Lab-1/#d-trabalhando-com-nand","text":"Utilizando o simulador logic.ly implemente as seguintes portas l\u00f3gicas utilizando somente NANDs : NOT AND OR XOR NOR XNOR","title":"D) Trabalhando com NAND"},{"location":"B-Circuitos-Integrados-Lab-1/#d-implementando","text":"Escolha uma das portas e valide o simulador montando na protoboard.","title":"D') Implementando"},{"location":"B-Circuitos-Integrados-Lab-2/","text":"B - CI - Lab 1 \u00b6 Note Deve ser realizado para a entrega do projeto B. Referenciando a raiz \u00b6 Warning Somente o mediador . Todos devem acompanhar! https://gist.github.com/CristinaSolana/1885435 https://help.github.com/articles/syncing-a-fork/ Uma vez clonado o reposit\u00f3rio, voc\u00ea deve entrar na pasta via o terminal: $ cd Z01.1-NomeDoGrupo Uma vez na pasta do reposit\u00f3rio precisamos agora indicar para o reposit\u00f3rio original na qual o reposit\u00f3rio que deu origem a esse fork, para isso devemos executar a seguinte linha de c\u00f3digo: $ git remote add upstream https://github.com/insper/Z01.1 Para verificar se deu certo, execute: $ git remote -v E deve aparecer al\u00e9m do link para o reposit\u00f3rio de voc\u00eas a refer\u00eancia ao reposit\u00f3rio original: upstream https://github.com/insper/Z01.1 ( fetch ) upstream https://github.com/insper/Z01.1 ( push ) Atualizando reposit\u00f3rio \u00b6 Para atualizar o reposit\u00f3rio do grupo de voc\u00eas com as novas atualiza\u00e7\u00f5es inseridas no reposit\u00f3rio da disciplina basta executar: Atualize o reposit\u00f3rio raiz para o branch upstream $ git fetch upstream Agora precisamos realizar um merge desse branch (que cont\u00e9m as atualiza\u00e7\u00f5es do reposit\u00f3rio da disciplin) com o master: $ git checkout master $ git merge upstream/master Agora precisamos submeter essa atualiza\u00e7\u00e3o para o reposit\u00f3rio remoto a fim de todos do grupo terem acesso a vers\u00e3o mais nova. $ git push origin master Github \u00b6 git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Para isso ser\u00e1 alteramos algumas configura\u00e7\u00f5es no reposit\u00f3rio: Execute Na p\u00e1gina do seu reposit\u00f3rio v\u00e1 em: Settings -> Features -> e ative Issues e Project . A seguir alguns termos que ser\u00e3o utilizados nesse lab e \u00e9 importante revisar/conhecer: Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Master : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um lider de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o. Adicionando nomes ao INTEGRANTES.json \u00b6 Warning Deve ser realizado individualmente! Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (insper) e usu\u00e1rio gituhb. Conforme o exemplo a seguir: { \"aluno-1\" : { \"nome\" : \"Rafae Corsi\" , \"email-insper\" : \"rafael.corsi@insper.edu.br\" , \"user-github\" : \"rafaelcorsi\" }, Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Criando um branch para fazer o commit. \u00b6 A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git commit -am \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v . Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Realizando pull-request \u00b6 Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a pag\u00edna do github do reposit\u00f3rio do seu grupo. git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Aceitando pull-request \u00b6 O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"4 : B CI Lab 1"},{"location":"B-Circuitos-Integrados-Lab-2/#b-ci-lab-1","text":"Note Deve ser realizado para a entrega do projeto B.","title":"B - CI - Lab 1"},{"location":"B-Circuitos-Integrados-Lab-2/#referenciando-a-raiz","text":"Warning Somente o mediador . Todos devem acompanhar! https://gist.github.com/CristinaSolana/1885435 https://help.github.com/articles/syncing-a-fork/ Uma vez clonado o reposit\u00f3rio, voc\u00ea deve entrar na pasta via o terminal: $ cd Z01.1-NomeDoGrupo Uma vez na pasta do reposit\u00f3rio precisamos agora indicar para o reposit\u00f3rio original na qual o reposit\u00f3rio que deu origem a esse fork, para isso devemos executar a seguinte linha de c\u00f3digo: $ git remote add upstream https://github.com/insper/Z01.1 Para verificar se deu certo, execute: $ git remote -v E deve aparecer al\u00e9m do link para o reposit\u00f3rio de voc\u00eas a refer\u00eancia ao reposit\u00f3rio original: upstream https://github.com/insper/Z01.1 ( fetch ) upstream https://github.com/insper/Z01.1 ( push )","title":"Referenciando a raiz"},{"location":"B-Circuitos-Integrados-Lab-2/#atualizando-repositorio","text":"Para atualizar o reposit\u00f3rio do grupo de voc\u00eas com as novas atualiza\u00e7\u00f5es inseridas no reposit\u00f3rio da disciplina basta executar: Atualize o reposit\u00f3rio raiz para o branch upstream $ git fetch upstream Agora precisamos realizar um merge desse branch (que cont\u00e9m as atualiza\u00e7\u00f5es do reposit\u00f3rio da disciplin) com o master: $ git checkout master $ git merge upstream/master Agora precisamos submeter essa atualiza\u00e7\u00e3o para o reposit\u00f3rio remoto a fim de todos do grupo terem acesso a vers\u00e3o mais nova. $ git push origin master","title":"Atualizando reposit\u00f3rio"},{"location":"B-Circuitos-Integrados-Lab-2/#github","text":"git GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia http://github.com Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Para isso ser\u00e1 alteramos algumas configura\u00e7\u00f5es no reposit\u00f3rio: Execute Na p\u00e1gina do seu reposit\u00f3rio v\u00e1 em: Settings -> Features -> e ative Issues e Project . A seguir alguns termos que ser\u00e3o utilizados nesse lab e \u00e9 importante revisar/conhecer: Github Project : Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. github issues : Plataforma do github para cria\u00e7\u00e3o de tarefas/ reportar erros. As tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. Branch : Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Master : Ramo principal do projeto, gerenciado pelo Scrum Master Pull-request : Maneira de um lider de projeto receber altera\u00e7\u00f5es a um projeto e ter controle do que ser\u00e1 aceito ou n\u00e3o. Na maioria dos casos o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Quem for fazer a eletiva de Desenvolvimento Aberto do Prof. Igor ver\u00e1 bem a fundo essa quest\u00e3o.","title":"Github"},{"location":"B-Circuitos-Integrados-Lab-2/#adicionando-nomes-ao-integrantesjson","text":"Warning Deve ser realizado individualmente! Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request Cada integrante do grupo deve editar o documento com na raiz do projeto com nome INTEGRANTES.json e adicionar a esse arquivo o seu nome, e-mail (insper) e usu\u00e1rio gituhb. Conforme o exemplo a seguir: { \"aluno-1\" : { \"nome\" : \"Rafae Corsi\" , \"email-insper\" : \"rafael.corsi@insper.edu.br\" , \"user-github\" : \"rafaelcorsi\" }, Warning Uma \u00fanica pessoa n\u00e3o deve editar o documento com todos os nomes. Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request","title":"Adicionando nomes ao INTEGRANTES.json"},{"location":"B-Circuitos-Integrados-Lab-2/#criando-um-branch-para-fazer-o-commit","text":"A fim de realizarmos um pull-request ao mediador do projeto \u00e9 preciso salvarmos essas modifica\u00e7\u00f5es em um novo branch. O comando a seguir faz isso: $ # criando um novo branch $ git checkout -B $NOME git Substitua nos comandos o termo $NOME pelo seu nome. Agora vamos fazer um commit com o seu nome nesse novo branch: $ git commit -am \"Adicionado meu $NOME ao arquivo\" Ser\u00e1 necess\u00e1rio enviarmos esse branch ao servidor (github) antes de realizarmos o pull-request : $ # enviando o branch para o reposit\u00f3rio remoto $ git push origin $NOME git Esse comando diz para o git que \u00e9 para enviar o branch $NOME para o reposit\u00f3rio remoto origin . Aquele que aparece no comando $ git remote -v . Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request","title":"Criando um branch para fazer o commit."},{"location":"B-Circuitos-Integrados-Lab-2/#realizando-pull-request","text":"Uma vez enviando o branch para o servidor, podemos via a interface web do github realizar o pull-request . Abra a pag\u00edna do github do reposit\u00f3rio do seu grupo. git Se tiver instalado o software hub digite na linha de comando: $ hub browser . Vamos agora gerar o pull-request na interface do github, de forma similar ao exemplo a seguir: Warning Cuidado! Escolher o seu reposit\u00f3rio no momento de realizar o pullrequest. Gerar mudan\u00e7as no reposit\u00f3rio local Enviar mudan\u00e7as para o reposit\u00f3rio remoto Gerar pull-request","title":"Realizando pull-request"},{"location":"B-Circuitos-Integrados-Lab-2/#aceitando-pull-request","text":"O mediador do projeto deve revisar os pull-requests (e corrigir eventuais erros de merge) e aceitar ou negar o pedido.","title":"Aceitando pull-request"},{"location":"B-Circuitos-Integrados-Projeto/","text":"Esse \u00e9 o \u00fanico projeto que ir\u00e1 ter sobreposi\u00e7\u00e3o de prazo de entrega, a ideia \u00e9 que o grupo fa\u00e7a a divis\u00e3o de trabalho para maximizar a produtividade. Descri\u00e7\u00e3o \u00b6 Esse projeto tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas feitas em circuitos integrados. Cada grupo receber\u00e1 uma equa\u00e7\u00e3o l\u00f3gica que dever\u00e1 implementar e caber\u00e1 ao grupo decidir a melhor forma de separa\u00e7\u00e3o de trabalho que privilegie a distribui\u00e7\u00e3o de tarefas. Instru\u00e7\u00f5es \u00b6 Deve-se implementar a mesma equa\u00e7\u00e3o l\u00f3gica recebida no projeto A (individual por grupo) via os circuitos integrados da fam\u00edlia 40xx l\u00f3gicos recebidos em sala. O circuito deve ser realizado na protoboard. Materiais extras \u00b6 Cada grupo recebeu os seguintes CIs: 2x 4001 \u2013 NOR 2x 4013 \u2013 FF D Type 2x 4070 \u2013 XOR 2x 4073 \u2013 AND 2x 4075 \u2013 OR 2x 4072 \u2013 OR 4 Poder\u00e3o utilizar a quantidade que material recebido que acharem necess\u00e1rio para realizarem a equa\u00e7\u00e3o l\u00f3gica, n\u00e3o podendo superar a quantidade aqui descrita. Voc\u00eas podem substituir poss\u00edveis CIs / transistores queimados. Entradas \u00b6 Pode-se utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . A cada entrada um LED de cor diferente pode ser utilizado para de forma f\u00e1cil saber quais s\u00e3o as entradas do sistema. Sa\u00edda \u00b6 A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0. Documenta\u00e7\u00e3o \u00b6 Um documento descrevendo a solu\u00e7\u00e3o empregada deve ser apresentando. O documento deve conter : A equa\u00e7\u00e3o l\u00f3gica original, diagrama de blocos l\u00f3gico ( contendo as portas l\u00f3gicas) e o diagrama de el\u00e9trico/montagem (quais pinos de quais componentes foram utilizados). O documento deve descrever como foi feito a divis\u00e3o do trabalho em grupo. Valida\u00e7\u00e3o \u00b6 Uma tabela verdade do circuito deve ser apresentada e em aula e uma demonstra\u00e7\u00e3o que o circuito representa a tabela deve ser feita. Entrega \u00b6 A entrega da documenta\u00e7\u00e3o deve ser realizada via github no fork realizado na disciplina (verifique o lab 2 do projeto A) . O documento deve ser colocado na pasta do reposit\u00f3rio do grupo: Z01.1/B-CircuitosIntegrados/Documentacao.pdf - Na entrega todos os integrantes do grupo j\u00e1 - devem fazer parte do reposit\u00f3rio. Rubricas \u00b6 As rubricas s\u00e3o progressivas A(B(C())). Nota m\u00e1xima Descritivo A+ - Adicionado bot\u00e3o na entrada do sistema (A,B,C) B - Documenta\u00e7\u00e3o correta C - Circuito funcionado - Um item da documenta\u00e7\u00e3o errado/faltando - Entregue fora do prazo original D - Entregue fora do prazo m\u00e1ximo - Circuito n\u00e3o funcionando - Documenta\u00e7\u00e3o com mais de dois itens errados/faltando I - N\u00e3o entregue","title":"B - Circuitos Integrados"},{"location":"B-Circuitos-Integrados-Projeto/#descricao","text":"Esse projeto tem como objetivo trabalhar com os conceitos b\u00e1sicos de portas l\u00f3gicas feitas em circuitos integrados. Cada grupo receber\u00e1 uma equa\u00e7\u00e3o l\u00f3gica que dever\u00e1 implementar e caber\u00e1 ao grupo decidir a melhor forma de separa\u00e7\u00e3o de trabalho que privilegie a distribui\u00e7\u00e3o de tarefas.","title":"Descri\u00e7\u00e3o"},{"location":"B-Circuitos-Integrados-Projeto/#instrucoes","text":"Deve-se implementar a mesma equa\u00e7\u00e3o l\u00f3gica recebida no projeto A (individual por grupo) via os circuitos integrados da fam\u00edlia 40xx l\u00f3gicos recebidos em sala. O circuito deve ser realizado na protoboard.","title":"Instru\u00e7\u00f5es"},{"location":"B-Circuitos-Integrados-Projeto/#materiais-extras","text":"Cada grupo recebeu os seguintes CIs: 2x 4001 \u2013 NOR 2x 4013 \u2013 FF D Type 2x 4070 \u2013 XOR 2x 4073 \u2013 AND 2x 4075 \u2013 OR 2x 4072 \u2013 OR 4 Poder\u00e3o utilizar a quantidade que material recebido que acharem necess\u00e1rio para realizarem a equa\u00e7\u00e3o l\u00f3gica, n\u00e3o podendo superar a quantidade aqui descrita. Voc\u00eas podem substituir poss\u00edveis CIs / transistores queimados.","title":"Materiais extras"},{"location":"B-Circuitos-Integrados-Projeto/#entradas","text":"Pode-se utilizar como entrada do sistema (A,B,C,...) jumpers que estar\u00e3o hora conectados em GND (0) ou VCC (1) . A cada entrada um LED de cor diferente pode ser utilizado para de forma f\u00e1cil saber quais s\u00e3o as entradas do sistema.","title":"Entradas"},{"location":"B-Circuitos-Integrados-Projeto/#saida","text":"A sa\u00edda final do sistema deve ser representada com um LED, sendo aceso indicando l\u00f3gica 1 e apagado l\u00f3gica 0.","title":"Sa\u00edda"},{"location":"B-Circuitos-Integrados-Projeto/#documentacao","text":"Um documento descrevendo a solu\u00e7\u00e3o empregada deve ser apresentando. O documento deve conter : A equa\u00e7\u00e3o l\u00f3gica original, diagrama de blocos l\u00f3gico ( contendo as portas l\u00f3gicas) e o diagrama de el\u00e9trico/montagem (quais pinos de quais componentes foram utilizados). O documento deve descrever como foi feito a divis\u00e3o do trabalho em grupo.","title":"Documenta\u00e7\u00e3o"},{"location":"B-Circuitos-Integrados-Projeto/#validacao","text":"Uma tabela verdade do circuito deve ser apresentada e em aula e uma demonstra\u00e7\u00e3o que o circuito representa a tabela deve ser feita.","title":"Valida\u00e7\u00e3o"},{"location":"B-Circuitos-Integrados-Projeto/#entrega","text":"A entrega da documenta\u00e7\u00e3o deve ser realizada via github no fork realizado na disciplina (verifique o lab 2 do projeto A) . O documento deve ser colocado na pasta do reposit\u00f3rio do grupo: Z01.1/B-CircuitosIntegrados/Documentacao.pdf - Na entrega todos os integrantes do grupo j\u00e1 - devem fazer parte do reposit\u00f3rio.","title":"Entrega"},{"location":"B-Circuitos-Integrados-Projeto/#rubricas","text":"As rubricas s\u00e3o progressivas A(B(C())). Nota m\u00e1xima Descritivo A+ - Adicionado bot\u00e3o na entrada do sistema (A,B,C) B - Documenta\u00e7\u00e3o correta C - Circuito funcionado - Um item da documenta\u00e7\u00e3o errado/faltando - Entregue fora do prazo original D - Entregue fora do prazo m\u00e1ximo - Circuito n\u00e3o funcionando - Documenta\u00e7\u00e3o com mais de dois itens errados/faltando I - N\u00e3o entregue","title":"Rubricas"},{"location":"C-Logica-Combinacional-Lab-1/","text":"TRIO OU DUPLA Nesse lab iremos pela primeira vez programar uma FPGA e come\u00e7ar a trabalhar com uma linguagem de descri\u00e7\u00e3o de hardware (HDL), o VHDL. Usar o Linux fornecido! - Scrum Master: - Atualize o reposit\u00f3rio com o upstream antes de come\u00e7ar! Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Quartus \u00b6 Esse handout introdut\u00f3rio para o desenvolvimento do projeto ( C L\u00f3gica Combinacional ), vamos criar o nosso primeiro c\u00f3digo em VHDL e em seguida, programar a FPGA para executar o hardware rec\u00e9m descrito. Ap\u00f3s essa etapa, iremos come\u00e7ar o desenvolvimento do projeto, programando os m\u00f3dulos que vir\u00e3o a ser utilizados no computador Z01. Entendendo a estrutura de pastas \u00b6 A pasta do projeto C ( C-LogicaCombinacional ) no reposit\u00f3rio Z01 possui a seguinte estrutura: /C-Logica-combinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl tests/config.txt : Configura\u00e7\u00e3o dos testes Abrindo o Quartus \u00b6 Se n\u00e3o encontrar o software abra o terminal e escreva quartus . Abra o software do Quartus e clique em File Open Project escolha o projeto localizado na pasta C-Logica-Combinacional/Quartus . O arquivo que o Quartus ir\u00e1 reconhecer \u00e9 o: DE0_CV_Default.qpf como no gif a seguir: Abra o arquivo TopLevel.vhd como demonstrado no gif anterior, este arquivo \u00e9 o que chamamos de top level (pode-se fazer uma analogia com o main de um c\u00f3digo), ele ser\u00e1 o primeiro a ser executado na compila\u00e7\u00e3o e utilizar\u00e1 os demais m\u00f3dulos do sistema. Um c\u00f3digo em VHDL possui basicamente tr\u00eas partes: Declara\u00e7\u00e3o de bibliotecas utilizadas library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work. all ; Declara\u00e7\u00e3o das entradas e sa\u00eddas desse bloco (entidade) entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Implementa\u00e7\u00e3o da l\u00f3gica que relaciona as entradas e sa\u00eddas do m\u00f3dulo (arquitetura) architecture rtl of TopLevel is begin end rtl ; O c\u00f3digo original dispon\u00edvel n\u00e3o realiza nenhuma l\u00f3gica. Note que sua arquitetura est\u00e1 vazia! Compilando o c\u00f3digo \u00b6 Para compilarmos esse c\u00f3digo VHDL basta irmos em: Processing Start Compilation . A ferramenta ir\u00e1 \"realizar\" o c\u00f3digo, ou seja, interpretar e torna-lo um hardware. RTL View \u00b6 Podemos gerar a vis\u00e3o rtl do c\u00f3digo em vhdl, esse diagrama \u00e9 a interpreta\u00e7\u00e3o do c\u00f3digo em VHDL pelo compilador e como ele seria supostamente implementando em hardware. Para isso: Tools Netlist Viewers RTL viewer Ele ir\u00e1 gerar o seguinte diagrama: Onde podemos analisar que n\u00e3o existe nenhuma l\u00f3gica que relaciona entrada com sa\u00edda. Modificando o projeto \u00b6 Vamos modificar o arquivo toplevel.vhd do projeto para ficar como: --------------- -- implementacao --------------- begin LEDR ( 0 ) <= SW ( 0 ); end rtl ; + 1. Compile + 2. Gere o RTL Viewer novamente O resultado deve ser o seguinte: Onde o valor do LEDR0 ser\u00e1 o pr\u00f3prio valor de entrada chave SW0 . Programando a FPGA \u00b6 Para programar na FPGA conecte-a ao seu computador via cabo USB e v\u00e1 em: Tools Programmer . Ele deve abrir uma nova interface: Brinque com as chaves e note que os LEDs ir\u00e3o acender conforme as chaves s\u00e3o colocadas na posi\u00e7\u00e3o on. Desafios \u00b6 Para cada desafio proposto a seguir, verifique se o RTL corresponde a l\u00f3gica que deseja implementar. Ap\u00f3s a verifica\u00e7\u00e3o teste na programe e teste na FPGA: Compile Verifique o RTL Programe a FPGA 1. Fa\u00e7a a sa\u00edda LEDR(0) ser o inverso da entrada SW(0) \u00b6 2. Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) \u00b6 3. Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) e o LEDR(1) ser a chave SW(1) \u00b6 4. Sete segmentos \u00b6 Note que na nossa FPGA possu\u00edmos seis displays de sete segmentos . Para termos acesso a esses displays, basta modificar a entidade do projeto para: entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); HEX0 : out std_logic_vector ( 6 downto 0 ); -- 7seg0 HEX1 : out std_logic_vector ( 6 downto 0 ); -- 7seg1 HEX2 : out std_logic_vector ( 6 downto 0 ); -- 7seg2 HEX3 : out std_logic_vector ( 6 downto 0 ); -- 7seg3 LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Agora com os 7segs mapeados como sa\u00edda ( out ) na nossa entity podemos acionar cada led do display, como descrito no manual da placa (isso s\u00f3 \u00e9 poss\u00edvel pois o projeto j\u00e1 foi configurado corretamente antes pelo seu professor): Fa\u00e7a aparecer o n\u00famero 5 no HEX0 . Adicionando um novo componente ao projeto \u00b6 O desenvolvimento de projetos de hardware assim como os de softwares devem ser feitos de forma modular, onde especifica-se e implementa-se pequenos m\u00f3dulos (entidades) que s\u00e3o combinadas em sistemas cada vez mais complexos at\u00e9 chegar ao TopLevel . Esse projeto define uma s\u00e9rie de pequenos m\u00f3dulos, cada um com sua especificidade (localizados em C-LogicaCombinacional/src/rtl/ ) : And16.vhd DMux2Way.vhd DMux4Way.vhd DMux8Way.vhd Mux16.vhd Mux2Way.vhd Mux4Way16.vhd Mux4Way.vhd Mux8Way16.vhd Mux8Way.vhd Nand.vhd Nor8Way.vhd Not16.vhd Or16.vhd Or8Way.vhd TopLevel.vhd O m\u00f3dulo Nand.vhd j\u00e1 foi dado implementando para voc\u00eas, e seu conte\u00fado \u00e9 o seguinte: Library ieee ; use ieee.std_logic_1164. all ; entity nand_z01 is port ( A : in std_logic ; B : in std_logic ; Q : out std_logic ); end nand_z01 ; architecture rtl of nand_z01 is begin q <= not ( a and b ); end rtl ; + Note que o VHDL n\u00e3o \u00e9 case sensitive Esse m\u00f3dulo \u00e9 uma entidade que possui duas entrada (a,b) e uma sa\u00edda (q) e implementa um nand entre as entradas. Inserindo no toplevel \u00b6 Podemos inserir essa nand no toplevel da seguinte maneira: begin u1 : work . nand_z01 port map ( A => SW ( 0 ), B => SW ( 1 ), Q => LEDR ( 0 ) ); end rtl ; Essa linha de c\u00f3digo pode ser lida como: Cria um componente chamada de u1 , mapeando (roteando) a entrada SW(0) na porta A da NAND e a entrada SW(1) na entrada B da NAND e a sa\u00edda Q mapeada para o LEDR(0) Compilando o projeto podemos analisar o RTL gerado: Desafios extras \u00b6 Realize os seguintes desafios junto com o seu grupo, siga os passos anteriores para conseguir rodar na FPGA. 1. Fa\u00e7a TODOs os LEDs acenderem quando a seguinte combina\u00e7\u00e3o de entrada for: \u00b6 SW9 SW0 1 0 0 1 1 0 1 0 1 0 2. Fa\u00e7a um c\u00f3digo VHDL para implementar o circuito a seguir: \u00b6 Sendo: X: chave 0 (SW(0)) y: chave 1 (SW(1)) z: chave 2 (SW(2))","title":"5 : C Logica Comb. Lab 1"},{"location":"C-Logica-Combinacional-Lab-1/#quartus","text":"Esse handout introdut\u00f3rio para o desenvolvimento do projeto ( C L\u00f3gica Combinacional ), vamos criar o nosso primeiro c\u00f3digo em VHDL e em seguida, programar a FPGA para executar o hardware rec\u00e9m descrito. Ap\u00f3s essa etapa, iremos come\u00e7ar o desenvolvimento do projeto, programando os m\u00f3dulos que vir\u00e3o a ser utilizados no computador Z01.","title":"Quartus"},{"location":"C-Logica-Combinacional-Lab-1/#entendendo-a-estrutura-de-pastas","text":"A pasta do projeto C ( C-LogicaCombinacional ) no reposit\u00f3rio Z01 possui a seguinte estrutura: /C-Logica-combinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd Serve para programar a FPGA *.py : Scripts em python automatiza a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl tests/config.txt : Configura\u00e7\u00e3o dos testes","title":"Entendendo a estrutura de pastas"},{"location":"C-Logica-Combinacional-Lab-1/#abrindo-o-quartus","text":"Se n\u00e3o encontrar o software abra o terminal e escreva quartus . Abra o software do Quartus e clique em File Open Project escolha o projeto localizado na pasta C-Logica-Combinacional/Quartus . O arquivo que o Quartus ir\u00e1 reconhecer \u00e9 o: DE0_CV_Default.qpf como no gif a seguir: Abra o arquivo TopLevel.vhd como demonstrado no gif anterior, este arquivo \u00e9 o que chamamos de top level (pode-se fazer uma analogia com o main de um c\u00f3digo), ele ser\u00e1 o primeiro a ser executado na compila\u00e7\u00e3o e utilizar\u00e1 os demais m\u00f3dulos do sistema. Um c\u00f3digo em VHDL possui basicamente tr\u00eas partes: Declara\u00e7\u00e3o de bibliotecas utilizadas library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work. all ; Declara\u00e7\u00e3o das entradas e sa\u00eddas desse bloco (entidade) entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Implementa\u00e7\u00e3o da l\u00f3gica que relaciona as entradas e sa\u00eddas do m\u00f3dulo (arquitetura) architecture rtl of TopLevel is begin end rtl ; O c\u00f3digo original dispon\u00edvel n\u00e3o realiza nenhuma l\u00f3gica. Note que sua arquitetura est\u00e1 vazia!","title":"Abrindo o Quartus"},{"location":"C-Logica-Combinacional-Lab-1/#compilando-o-codigo","text":"Para compilarmos esse c\u00f3digo VHDL basta irmos em: Processing Start Compilation . A ferramenta ir\u00e1 \"realizar\" o c\u00f3digo, ou seja, interpretar e torna-lo um hardware.","title":"Compilando o c\u00f3digo"},{"location":"C-Logica-Combinacional-Lab-1/#rtl-view","text":"Podemos gerar a vis\u00e3o rtl do c\u00f3digo em vhdl, esse diagrama \u00e9 a interpreta\u00e7\u00e3o do c\u00f3digo em VHDL pelo compilador e como ele seria supostamente implementando em hardware. Para isso: Tools Netlist Viewers RTL viewer Ele ir\u00e1 gerar o seguinte diagrama: Onde podemos analisar que n\u00e3o existe nenhuma l\u00f3gica que relaciona entrada com sa\u00edda.","title":"RTL View"},{"location":"C-Logica-Combinacional-Lab-1/#modificando-o-projeto","text":"Vamos modificar o arquivo toplevel.vhd do projeto para ficar como: --------------- -- implementacao --------------- begin LEDR ( 0 ) <= SW ( 0 ); end rtl ; + 1. Compile + 2. Gere o RTL Viewer novamente O resultado deve ser o seguinte: Onde o valor do LEDR0 ser\u00e1 o pr\u00f3prio valor de entrada chave SW0 .","title":"Modificando o projeto"},{"location":"C-Logica-Combinacional-Lab-1/#programando-a-fpga","text":"Para programar na FPGA conecte-a ao seu computador via cabo USB e v\u00e1 em: Tools Programmer . Ele deve abrir uma nova interface: Brinque com as chaves e note que os LEDs ir\u00e3o acender conforme as chaves s\u00e3o colocadas na posi\u00e7\u00e3o on.","title":"Programando a FPGA"},{"location":"C-Logica-Combinacional-Lab-1/#desafios","text":"Para cada desafio proposto a seguir, verifique se o RTL corresponde a l\u00f3gica que deseja implementar. Ap\u00f3s a verifica\u00e7\u00e3o teste na programe e teste na FPGA: Compile Verifique o RTL Programe a FPGA","title":"Desafios"},{"location":"C-Logica-Combinacional-Lab-1/#1-faca-a-saida-ledr0-ser-o-inverso-da-entrada-sw0","text":"","title":"1. Fa\u00e7a a sa\u00edda LEDR(0) ser o inverso da entrada SW(0)"},{"location":"C-Logica-Combinacional-Lab-1/#2-faca-a-saida-ledr0-ser-a-entrada-sw0-ou-sw1","text":"","title":"2. Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1)"},{"location":"C-Logica-Combinacional-Lab-1/#3-faca-a-saida-ledr0-ser-a-entrada-sw0-ou-sw1-e-o-ledr1-ser-a-chave-sw1","text":"","title":"3. Fa\u00e7a a sa\u00edda LEDR(0) ser a entrada SW(0) ou SW(1) e o LEDR(1) ser a chave SW(1)"},{"location":"C-Logica-Combinacional-Lab-1/#4-sete-segmentos","text":"Note que na nossa FPGA possu\u00edmos seis displays de sete segmentos . Para termos acesso a esses displays, basta modificar a entidade do projeto para: entity TopLevel is port ( SW : in std_logic_vector ( 9 downto 0 ); HEX0 : out std_logic_vector ( 6 downto 0 ); -- 7seg0 HEX1 : out std_logic_vector ( 6 downto 0 ); -- 7seg1 HEX2 : out std_logic_vector ( 6 downto 0 ); -- 7seg2 HEX3 : out std_logic_vector ( 6 downto 0 ); -- 7seg3 LEDR : out std_logic_vector ( 9 downto 0 ) ); end entity ; Agora com os 7segs mapeados como sa\u00edda ( out ) na nossa entity podemos acionar cada led do display, como descrito no manual da placa (isso s\u00f3 \u00e9 poss\u00edvel pois o projeto j\u00e1 foi configurado corretamente antes pelo seu professor): Fa\u00e7a aparecer o n\u00famero 5 no HEX0 .","title":"4. Sete segmentos"},{"location":"C-Logica-Combinacional-Lab-1/#adicionando-um-novo-componente-ao-projeto","text":"O desenvolvimento de projetos de hardware assim como os de softwares devem ser feitos de forma modular, onde especifica-se e implementa-se pequenos m\u00f3dulos (entidades) que s\u00e3o combinadas em sistemas cada vez mais complexos at\u00e9 chegar ao TopLevel . Esse projeto define uma s\u00e9rie de pequenos m\u00f3dulos, cada um com sua especificidade (localizados em C-LogicaCombinacional/src/rtl/ ) : And16.vhd DMux2Way.vhd DMux4Way.vhd DMux8Way.vhd Mux16.vhd Mux2Way.vhd Mux4Way16.vhd Mux4Way.vhd Mux8Way16.vhd Mux8Way.vhd Nand.vhd Nor8Way.vhd Not16.vhd Or16.vhd Or8Way.vhd TopLevel.vhd O m\u00f3dulo Nand.vhd j\u00e1 foi dado implementando para voc\u00eas, e seu conte\u00fado \u00e9 o seguinte: Library ieee ; use ieee.std_logic_1164. all ; entity nand_z01 is port ( A : in std_logic ; B : in std_logic ; Q : out std_logic ); end nand_z01 ; architecture rtl of nand_z01 is begin q <= not ( a and b ); end rtl ; + Note que o VHDL n\u00e3o \u00e9 case sensitive Esse m\u00f3dulo \u00e9 uma entidade que possui duas entrada (a,b) e uma sa\u00edda (q) e implementa um nand entre as entradas.","title":"Adicionando um novo componente ao projeto"},{"location":"C-Logica-Combinacional-Lab-1/#inserindo-no-toplevel","text":"Podemos inserir essa nand no toplevel da seguinte maneira: begin u1 : work . nand_z01 port map ( A => SW ( 0 ), B => SW ( 1 ), Q => LEDR ( 0 ) ); end rtl ; Essa linha de c\u00f3digo pode ser lida como: Cria um componente chamada de u1 , mapeando (roteando) a entrada SW(0) na porta A da NAND e a entrada SW(1) na entrada B da NAND e a sa\u00edda Q mapeada para o LEDR(0) Compilando o projeto podemos analisar o RTL gerado:","title":"Inserindo no toplevel"},{"location":"C-Logica-Combinacional-Lab-1/#desafios-extras","text":"Realize os seguintes desafios junto com o seu grupo, siga os passos anteriores para conseguir rodar na FPGA.","title":"Desafios extras"},{"location":"C-Logica-Combinacional-Lab-1/#1-faca-todos-os-leds-acenderem-quando-a-seguinte-combinacao-de-entrada-for","text":"SW9 SW0 1 0 0 1 1 0 1 0 1 0","title":"1. Fa\u00e7a TODOs os LEDs acenderem quando a seguinte combina\u00e7\u00e3o de entrada for:"},{"location":"C-Logica-Combinacional-Lab-1/#2-faca-um-codigo-vhdl-para-implementar-o-circuito-a-seguir","text":"Sendo: X: chave 0 (SW(0)) y: chave 1 (SW(1)) z: chave 2 (SW(2))","title":"2. Fa\u00e7a um c\u00f3digo VHDL para implementar o circuito a seguir:"},{"location":"C-Logica-Combinacional-Lab-2/","text":"SCRUM MASTER (todos devem acompanhar) Travis \u00e9 um sistema de integra\u00e7\u00e3o cont\u00ednua que vai executar de forma autom\u00e1tica alguns testes (criado por n\u00f3s) no projeto e em caso de alguma falha ir\u00e1 notificar no github e por e-mail todos os integrantes. Como ele funciona ? Ele fica verificando o reposit\u00f3rio por altera\u00e7\u00f5es (voc\u00ea deve al\u00e9m de dar commit, dar push) e para cada novo commit ele faz o seguinte Inicializa uma nova m\u00e1quina virtual na nuvem (ubuntu, windows, mac) Instala todo a infra necess\u00e1ria do projeto (no caso do Z01.1 : python, java, Quartus, ...) Executa os scripts de teste localizados em cada parte do projeto No caso desse projeto : Projetos/C-Logica-Combinacional/testeLogicaCombinacional.py Desliga e \"deleta\" a m\u00e1quina virtual rec\u00e9m criada. O arquivo de configura\u00e7\u00e3o do travis est\u00e1 localizado na raiz do reposit\u00f3rio : Z01.1/.travis.yml . Nele que est\u00e3o feitas todas as defini\u00e7\u00f5es de execu\u00e7\u00e3o. Na pagina do seu reposit\u00f3rio em commits deve aparecer uma pequena bolinha em cada um dos commits novos que ser\u00e3o feitos no projeto, esse indicador ser\u00e1 atualizado pelo travis sendo : Amarelo: O teste est\u00e1 em execu\u00e7\u00e3o Verde: O teste passou Vermelho: O teste falhou Cada teste leva em torno de alguns minutos j\u00e1 que toda a infraestrutura \u00e9 instalada sempre do zero, n\u00e3o utilize o sistema de Integra\u00e7\u00e3o Cont\u00ednua para validar as suas novas implementa\u00e7\u00f5es, esse sistema deve ser utilizado para encontrar problemas mais amplos ou para o scrum master aceitar ou n\u00e3o um pull-request, j\u00e1 que o resultado do sucesso ou n\u00e3o dessa requisi\u00e7\u00e3o \u00e9 vis\u00edvel facilmente. Ativando no Travis \u00b6 Ser\u00e1 necess\u00e1rio acessar o site do travis : https://travis-ci.org/ e adicione o projeto forkado ao travis : + Somente o usu\u00e1rio que realizou o fork do projeto + deve realizar essa etapa. Github \u00b6 GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Github Project: Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. GitHub issues: Plataforma do github para cria\u00e7\u00e3o de tarefas, as tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. + Voc\u00ea dever\u00e1 ativar o issues no github. + V\u00e1 em Settings -> e clique em issues Pull-request: Maneira de um lider de projeto aceitar ou n\u00e3o atualiza\u00e7\u00f5es em um c\u00f3digo, o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Branch: Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Master: Ramo principal do projeto, gerenciado pelo Scrum Master Tutorial \u00b6 O Scrum Master deve realizar as tarefas a seguir com todos acompanhando no monitor! Criando um project no github Adicionando issues Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto.","title":"7 : C Logica Comb. Lab 2"},{"location":"C-Logica-Combinacional-Lab-2/#ativando-no-travis","text":"Ser\u00e1 necess\u00e1rio acessar o site do travis : https://travis-ci.org/ e adicione o projeto forkado ao travis : + Somente o usu\u00e1rio que realizou o fork do projeto + deve realizar essa etapa.","title":"Ativando no Travis"},{"location":"C-Logica-Combinacional-Lab-2/#github","text":"GitHub Inc. is a web-based hosting service for version control using Git. It is mostly used for computer code. It offers all of the distributed version control and source code management functionality of Git as well as adding its own features. Wikipedia Nessa disciplina iremos utilizar n\u00e3o s\u00f3 a ferramenta principal do github, que \u00e9 o servidor de reposit\u00f3rios git mas todas as outras ferramentas j\u00e1 integradas na plataforma para gest\u00e3o e acompanhamento de projeto. Github Project: Ferramenta do github para gerenciamento de projetos (estilo Kambam), cada reposit\u00f3rio pode ter N projetos, e o github automatiza o processo de todo/doing/done deixando de maneira visual as tarefas. GitHub issues: Plataforma do github para cria\u00e7\u00e3o de tarefas, as tarefas aqui criadas ser\u00e3o associadas a um projeto espec\u00edfico e a um grupo de pessoas espec\u00edficas. + Voc\u00ea dever\u00e1 ativar o issues no github. + V\u00e1 em Settings -> e clique em issues Pull-request: Maneira de um lider de projeto aceitar ou n\u00e3o atualiza\u00e7\u00f5es em um c\u00f3digo, o pull-request \u00e9 criado por um usu\u00e1rio e revisado por outro. Branch: Ramo criado para implementar um feature/ corre\u00e7\u00e3o de bug que ser\u00e1 futuramente incorporado no master (merge) Master: Ramo principal do projeto, gerenciado pelo Scrum Master","title":"Github"},{"location":"C-Logica-Combinacional-Lab-2/#tutorial","text":"O Scrum Master deve realizar as tarefas a seguir com todos acompanhando no monitor! Criando um project no github Adicionando issues Os issues devem ser todos os m\u00f3dulos a serem implementados do projeto.","title":"Tutorial"},{"location":"C-Logica-Combinacional-Lab-3/","text":"INDIVIDUAL Executar antes! $ git submodule update --init --recursive $ git submodule foreach 'git stash; git checkout master; git pull' Vamos iremos trabalharmos em implementarmos a porta or16 (que \u00e9 uma parte do projeto C), para isso iremos editar o arquivo de configura\u00e7\u00e3o /Z01.1/Projetos/C-LogicaCombinacional/tests/config.txt comentando os demais m\u00f3dulos menos o Or16 : ###################################### # Rafael.Corsi @ Insper.edu.br # # Elementos de Sistemas # # # # Arquivos de teste do projeto C # # - Para incluir o teste basta # # descomentar a linha # # # ###################################### #nand.vhd #Nor8Way.vhd #And16.vhd #Not16.vhd #Or8Way.vhd +Or16.vhd #DMux2Way.vhd #DMux4Way.vhd #DMux8Way.vhd #Mux2Way.vhd #Mux4Way.vhd #Mux16.vhd #Mux4Way16.vhd #Mux8Way.vhd #Mux8Way16.vhd Abra o terminal na pasta C-Logica-Combinacional/ e execute o script python: $ ./testeLogicaCombinacional.py O mesmo ir\u00e1 executar a compila\u00e7\u00e3o dos arquivos src/rtl/*.vhd e realizar testes unit\u00e1rios em cada um desses m\u00f3dulos, como os m\u00f3dulos n\u00e3o est\u00e3o implementados e como estamos for\u00e7ando o teste do or16 devemos ter um erro nesse m\u00f3dulo. Esse erro acontece pois o mesmo ainda n\u00e3o foi implementado: library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Or16 is port ( a: in STD_LOGIC_VECTOR(15 downto 0); b: in STD_LOGIC_VECTOR(15 downto 0); q: out STD_LOGIC_VECTOR(15 downto 0)); end entity; architecture arch of Or16 is begin end architecture; Vamos agora editar esse arquivo para realizar sua implementa\u00e7\u00e3o. Essa modifica\u00e7\u00e3o deve ser salva em novo branch or16 . Dentro do terminal (na pasta do projeto C): $ git checkout -B or16 Modifique o arquivo or16 para implementar uma OR /Z01.1/C-LogicaCombinacional/src/rtl/or16.vhd Execute o comando no terminal para testarmos a implementa\u00e7\u00e3o. $ ./testeLogicaCombinacional.py Realizando o commit: $ git commit -am \"funcionando e testado\" Agora vamos enviar para o servidor (reposit\u00f3rio git remoto) o novo branch or16 : $ git push origin or16 Pr\u00f3ximos passos \u00b6 \u00c1gora \u00e9 necess\u00e1rio que o desenvolvedor gerar o pullrequest para que o mediador tenha conhecimento da sua implementa\u00e7\u00e3o. Se no grupo mais de uma pessoa fez a implementa\u00e7\u00e3o, gere somente um PULL REQUEST Desenvolvedor gera pullrequest Mediador analisa/ aprova o pullrequest.","title":"6 : C Logica Comb. Lab 3"},{"location":"C-Logica-Combinacional-Lab-3/#proximos-passos","text":"\u00c1gora \u00e9 necess\u00e1rio que o desenvolvedor gerar o pullrequest para que o mediador tenha conhecimento da sua implementa\u00e7\u00e3o. Se no grupo mais de uma pessoa fez a implementa\u00e7\u00e3o, gere somente um PULL REQUEST Desenvolvedor gera pullrequest Mediador analisa/ aprova o pullrequest.","title":"Pr\u00f3ximos passos"},{"location":"C-Logica-Combinacional-Projeto/","text":"C - L\u00f3gica Combinacional \u00b6 Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e VHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador. Instru\u00e7\u00f5es \u00b6 O desenvolvimento ser\u00e1 na linguagem VHDL. Os alunos dever\u00e3o se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo. Al\u00e9m dos m\u00f3dulos principais, dever\u00e1 ser entregue um m\u00f3dulo que faz o acionamento de um display de sete segmentos. Integrantes \u00b6 Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo. Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente, utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, esse \u00e9 sua tarefa/ responsabilidade! Controle de Tarefas e Reposit\u00f3rio \u00b6 Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que voc\u00ea ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado. Facilitador (Scrum Master) \u00b6 Organizar o github + issues + project Fazer a atualiza\u00e7\u00e3o do fork com o upstream Gerenciar o grupo (atribuir tarefas) Aceitar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final Desenvolvedores \u00b6 Realizar as tarefas atribuidas pelo scrum-master Realizar os pull-requests Testar os c\u00f3digos Instru\u00e7\u00f5es \u00b6 A pasta cont\u00e9m dois diret\u00f3rios distintos : src/ e Quartus/ . O diret\u00f3rio src cont\u00e9m os arquivos fontes que dever\u00e3o ser editados para implementar o projeto. O diret\u00f3rio quartus/ cont\u00e9m o projeto que possibilitar\u00e1 compilar os m\u00f3dulos e testar em hardware. Entendendo o projeto \u00b6 A pasta do projeto C no reposit\u00f3rio Z01.1 possui a seguinte estrutura : /C-Logica-combinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd testeLogicaCombinacional.py : Script em python que possibilita a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl Executando o script de teste \u00b6 Abra o terminal na pasta C-Logica-Combinacional e execute o script python localizado nessa pasta: $ ./testeLogicaCombinacional.py M\u00f3dulos : \u00b6 Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Travis deve estar configurado e funcionando Implementar acionamento do diplay de 7 segmentos e demonstrar na FPGA Esses arquivos est\u00e3o localizados em C-Logica-Combinacional/src/rtl/ Utilize um editor de texto/c\u00f3digo de sua prefer\u00eancia para a implementa\u00e7\u00e3o, valide rodando o script de testes. Deve-se implementar os seguintes circuitos combinacionais: AND 16 bits Arquivo : And16.vhd Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits Arquivo : Or16.vhd Descri\u00e7\u00e3o : OR bit a bit entre duas palavras de 16 bits. NOT de 16 bits Arquivo : Not16.vhd Descri\u00e7\u00e3o : NOT bit a bit entre duas palavras de 16 bits. NOR 8 Way Arquivo : Nor8Way.vhd Descri\u00e7\u00e3o : NOR entre 8 bits, resulta em uma \u00fanica sa\u00edda OR 8 Way Arquivo : Or8Way.vhd Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Demultiplexiador de 2 sa\u00eddas Arquivo : DMux2Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexiador de 4 sa\u00eddas Arquivo : DMux4Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexiador de 8 sa\u00eddas Arquivo : DMux8Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits Arquivo : Mux16.vhd Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada Arquivo : Mux2Way.vhd Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada Arquivo : Mux4Way.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada Arquivo : Mux8Way.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada Arquivo : Mux4Way16.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada Arquivo : Mux8Way16.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Controle do display de 7 segmentos Arquivo : `/src/toplevel.vhd' Descri\u00e7\u00e3o : Deve ler as chaves SW e exibir seu valor no display de 7s. DICAS \u00b6 Existem diversos locais onde podem tirar d\u00favida de VHDL , por exemplo : http://esd.cs.ucr.edu/labs/tutorial/ https://courseware.ee.calpoly.edu/cpe-169/Misc_stuff/cheat_sheet.pdf https://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl_golden_reference_guide.pdf Rubricas para avalia\u00e7\u00e3o do projeto \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Grupo \u00b6 Conceito Descritivo I - Mais de tr\u00eas m\u00f3dulos com falha D - At\u00e9 tr\u00eas M\u00f3dulos com falha C - Ter criado o project no github - O travis configurado e funcionando - Todos os m\u00f3dulos implementados e funcionado (teste ok) - Implementando um \u00fanico display de 7s (conta at\u00e9 16 em hexadecimal) B - Exibe tr\u00eas d\u00edgitos em Hexadecimal (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) A - Exibe tr\u00eas d\u00edgitos em Decimal Individual \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link : Rubricas Scrum e Desenvolvedor","title":"Projeto"},{"location":"C-Logica-Combinacional-Projeto/#c-logica-combinacional","text":"Scrum Master Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Esse projeto tem como objetivo trabalhar com portas l\u00f3gicas e sistemas digitais combinacionais (sem um clock) em FPGA e VHDL. Os elementos l\u00f3gicos desenvolvidos nessa etapa ser\u00e3o utilizados como elementos b\u00e1sicos para a constru\u00e7\u00e3o do computador.","title":"C - L\u00f3gica Combinacional"},{"location":"C-Logica-Combinacional-Projeto/#instrucoes","text":"O desenvolvimento ser\u00e1 na linguagem VHDL. Os alunos dever\u00e3o se organizar para implementar todos os elementos propostos. O facilitador escolhido ser\u00e1 respons\u00e1vel pela completude e consist\u00eancia do branch master do grupo. Al\u00e9m dos m\u00f3dulos principais, dever\u00e1 ser entregue um m\u00f3dulo que faz o acionamento de um display de sete segmentos.","title":"Instru\u00e7\u00f5es"},{"location":"C-Logica-Combinacional-Projeto/#integrantes","text":"Warning Este projeto \u00e9 para ser realizado por todos os integrantes do grupo. Tarefas devem ser criadas no Issues e atribu\u00eddas aos demais colegas. As tarefas devem ser resolvidas individualmente, utilize a ajuda de seus colegas, mas resolva o que foi atribu\u00eddo a voc\u00eas, esse \u00e9 sua tarefa/ responsabilidade!","title":"Integrantes"},{"location":"C-Logica-Combinacional-Projeto/#controle-de-tarefas-e-repositorio","text":"Nas discuss\u00f5es com os outros colegas o scrum master deve definir os m\u00f3dulos que voc\u00ea ir\u00e1 desenvolver. Crie uma rotina para commits e pull-request. Sempre teste os m\u00f3dulos e verifique se est\u00e1 fazendo o esperado.","title":"Controle de Tarefas e Reposit\u00f3rio"},{"location":"C-Logica-Combinacional-Projeto/#facilitador-scrum-master","text":"Organizar o github + issues + project Fazer a atualiza\u00e7\u00e3o do fork com o upstream Gerenciar o grupo (atribuir tarefas) Aceitar os pull-requests Criar relat\u00f3rio da performance de cada um do grupo Entregar/Apresentar o projeto no final","title":"Facilitador (Scrum Master)"},{"location":"C-Logica-Combinacional-Projeto/#desenvolvedores","text":"Realizar as tarefas atribuidas pelo scrum-master Realizar os pull-requests Testar os c\u00f3digos","title":"Desenvolvedores"},{"location":"C-Logica-Combinacional-Projeto/#instrucoes_1","text":"A pasta cont\u00e9m dois diret\u00f3rios distintos : src/ e Quartus/ . O diret\u00f3rio src cont\u00e9m os arquivos fontes que dever\u00e3o ser editados para implementar o projeto. O diret\u00f3rio quartus/ cont\u00e9m o projeto que possibilitar\u00e1 compilar os m\u00f3dulos e testar em hardware.","title":"Instru\u00e7\u00f5es"},{"location":"C-Logica-Combinacional-Projeto/#entendendo-o-projeto","text":"A pasta do projeto C no reposit\u00f3rio Z01.1 possui a seguinte estrutura : /C-Logica-combinacional testeLogicaCombinacional.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus : Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd testeLogicaCombinacional.py : Script em python que possibilita a execu\u00e7\u00e3o dos testes src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementado pelo grupo tests/tst/*.vhd : Arquivos VHDL que realizam teste l\u00f3gico nos arquivos do rtl","title":"Entendendo o projeto"},{"location":"C-Logica-Combinacional-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta C-Logica-Combinacional e execute o script python localizado nessa pasta: $ ./testeLogicaCombinacional.py","title":"Executando o script de teste"},{"location":"C-Logica-Combinacional-Projeto/#modulos","text":"Implementar todos os m\u00f3dulos listados Todos os m\u00f3dulos devem passar nos testes Travis deve estar configurado e funcionando Implementar acionamento do diplay de 7 segmentos e demonstrar na FPGA Esses arquivos est\u00e3o localizados em C-Logica-Combinacional/src/rtl/ Utilize um editor de texto/c\u00f3digo de sua prefer\u00eancia para a implementa\u00e7\u00e3o, valide rodando o script de testes. Deve-se implementar os seguintes circuitos combinacionais: AND 16 bits Arquivo : And16.vhd Descri\u00e7\u00e3o : And bit a bit entre duas palavras de 16 bits. OR de 16 bits Arquivo : Or16.vhd Descri\u00e7\u00e3o : OR bit a bit entre duas palavras de 16 bits. NOT de 16 bits Arquivo : Not16.vhd Descri\u00e7\u00e3o : NOT bit a bit entre duas palavras de 16 bits. NOR 8 Way Arquivo : Nor8Way.vhd Descri\u00e7\u00e3o : NOR entre 8 bits, resulta em uma \u00fanica sa\u00edda OR 8 Way Arquivo : Or8Way.vhd Descri\u00e7\u00e3o : OR entre 8 bits, resulta em uma \u00fanica sa\u00edda Demultiplexiador de 2 sa\u00eddas Arquivo : DMux2Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em duas sa\u00eddas. Demultiplexiador de 4 sa\u00eddas Arquivo : DMux4Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em quatro sa\u00eddas. Demultiplexiador de 8 sa\u00eddas Arquivo : DMux8Way.vhd Descri\u00e7\u00e3o : Demultiplexa uma entrada bin\u00e1ria em oito sa\u00eddas. Multiplexador de duas entradas de 16 bits Arquivo : Mux16.vhd Descri\u00e7\u00e3o : Multiplexa duas entradas de 16 bits para uma de 16 bits. Multiplexador 2 entradas de um bit cada Arquivo : Mux2Way.vhd Descri\u00e7\u00e3o : Multiplexa 2 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de um bit cada Arquivo : Mux4Way.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 8 entradas de um bit cada Arquivo : Mux8Way.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas bin\u00e1rias em uma sa\u00edda bin\u00e1ria Multiplexador 4 entradas de 16 bits cada Arquivo : Mux4Way16.vhd Descri\u00e7\u00e3o : Multiplexa 4 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Multiplexador 8 entradas de 16 bits cada Arquivo : Mux8Way16.vhd Descri\u00e7\u00e3o : Multiplexa 8 entradas de 16 bits cada em uma sa\u00edda de 16 bits. Controle do display de 7 segmentos Arquivo : `/src/toplevel.vhd' Descri\u00e7\u00e3o : Deve ler as chaves SW e exibir seu valor no display de 7s.","title":"M\u00f3dulos :"},{"location":"C-Logica-Combinacional-Projeto/#dicas","text":"Existem diversos locais onde podem tirar d\u00favida de VHDL , por exemplo : http://esd.cs.ucr.edu/labs/tutorial/ https://courseware.ee.calpoly.edu/cpe-169/Misc_stuff/cheat_sheet.pdf https://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl_golden_reference_guide.pdf","title":"DICAS"},{"location":"C-Logica-Combinacional-Projeto/#rubricas-para-avaliacao-do-projeto","text":"Cada integrante do grupo ir\u00e1 receber duas notas: Uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o do projeto"},{"location":"C-Logica-Combinacional-Projeto/#grupo","text":"Conceito Descritivo I - Mais de tr\u00eas m\u00f3dulos com falha D - At\u00e9 tr\u00eas M\u00f3dulos com falha C - Ter criado o project no github - O travis configurado e funcionando - Todos os m\u00f3dulos implementados e funcionado (teste ok) - Implementando um \u00fanico display de 7s (conta at\u00e9 16 em hexadecimal) B - Exibe tr\u00eas d\u00edgitos em Hexadecimal (exibir at\u00e9 o valor 0x3FF = 2^10 - 1) A - Exibe tr\u00eas d\u00edgitos em Decimal","title":"Grupo"},{"location":"C-Logica-Combinacional-Projeto/#individual","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link : Rubricas Scrum e Desenvolvedor","title":"Individual"},{"location":"D-ULA-Lab-1/","text":"+ Realizar em grupo (projetar) Iremos nesse laborat\u00f3rio editar a configura\u00e7\u00e3o do Travis para tevstar um novo projeto em seguida iremos explorar como os testes dos m\u00f3dulos em VHDL s\u00e3o realizados (testbench). Configurando Travis Implementando halfAdder Visualizando teste Aprimorando teste halfAdder 1. Configurando Travis \u00b6 Facilitador (chap\u00e9u) deve realizar por\u00e9m todos devem acompanhar . Usar o monitor! At\u00e9 agora voc\u00eas utilizaram o Travis de maneira transparente, sem entender muito como ele foi configurado. Nessa nova etapa do desenvolvimento do computador Z01 iremos modificar o arquivo de configura\u00e7\u00e3o do Travis para que ele posso executar os novos scripts de teste (testar o desenvolvimento da ULA). Note que no diret\u00f3rio raiz do reposit\u00f3rio Z01.1 temos um arquivo oculto chamado .travis.yml (usu\u00e1rios LINUX esse arquivo estar\u00e1 oculto. Para exibir no gerenciador de arquivos ctrl + h , ou ls -a no terminal), esse arquivo faz toda a configura\u00e7\u00e3o do teste de integra\u00e7\u00e3o cont\u00ednua e \u00e9 dividido em algumas partes: Configura\u00e7\u00e3o da m\u00e1quina virtual ubuntu 16.04 Instala\u00e7\u00e3o das depend\u00eancias: python quartus (no Travis instalamos somente o modelsim) java Execu\u00e7\u00e3o dos scripts de teste Nessa etapa estamos interessados em adicionar mais um script de teste ao Travis (o script que testa a ULA, testeULA.py ). Para isso abra o arquivo .travis.yml e na sec\u00e7\u00e3o referente aos scripts, adicione a linha como demonstrado a seguir: script: - python Projetos/C-LogicaCombinacional/testeLogicaCombinacional.py +- python Projetos/D-UnidadeLogicaAritmetica/testeULA.py Agora, toda vez que o reposit\u00f3rio remoto ( origin ) sofrer alguma varia\u00e7\u00e3o, o Travis ir\u00e1 executar os dois scripts de teste (projeto C e projeto D). - Salve e submeta as altera\u00e7\u00f5es no master ('git checkout master') fa\u00e7a um commit com essa altera\u00e7\u00e3o ('git add .travis.yml' + 'git commit -m \"adicionado teste D\"') fa\u00e7a o push ('git push origin master') 2. Implementando o half-adder \u00b6 O half-adder \u00e9 um dispositivo somador bin\u00e1rio que possui duas entradas bin\u00e1rias (a,b) e duas sa\u00eddas bin\u00e1ria (soma dos bits (Soma) e o carry (vaium)). A tabela verdade desse componente \u00e9 detalhada a seguir: a b Soma Vaium 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Com a tabela verdade podemos extrair as duas equa\u00e7\u00f5es que descreve esse componente: Soma e Vaium. soma = a xor b vaium = a and b Lembre que: not(a) b + a not(b) = a xor b Agora com a equa\u00e7\u00e3o definida \u00e9 poss\u00edvel realizarmos uma descri\u00e7\u00e3o em VHDL do componente halfadder . Abra o arquivo D-UnidadeLogicaAritmetica/src/rtl/HalfAdder.vhd e modifique sua arquitetura para implementar a equa\u00e7\u00e3o do halfadder. Edite o arquivo de configura\u00e7\u00e3o do teste tests/config.txt e descomente a linha referente ao halfadder . Valide a implementa\u00e7\u00e3o executando o script de testes: testeULA.py 3. Visualizando a simula\u00e7\u00e3o \u00b6 \u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Para isso ser\u00e1 necess\u00e1rio invocarmos a parte gr\u00e1fica do modelsim. Na hora de invocarmos o script de teste ( D-UnidadeLogicaAritmetica/testeULA.py ) passe o par\u00e2metro --gui (ou -g ), como a seguir: $ python testeULA.py --gui Esse comando ir\u00e1 executar a simula\u00e7\u00e3o e abrir no software modelsim (toda a simula\u00e7\u00e3o \u00e9 realizada por esse software, mas estava sendo 'mascarada' pelos scripts de teste em py). Antes de continuar, o m\u00f3dulo do HalfAdder.vhd j\u00e1 deve est\u00e1 implementando e testado (na forma tradicional). modelsim \u00b6 O modelsim n\u00e3o possui uma interface moderna, por\u00e9m \u00e9 o software de simula\u00e7\u00e3o de hardware mais completo e mais utilizado pela industria. Siga os passos a seguir para conseguirmos visualizarmos a forma de onda: Primeiramente devemos adicionar os sinais que desejamos visualizar, no caso do HalfAdder queremos ver suas entradas (a,b) e suas sa\u00eddas (soma, vaium). Para isso clique em wave : E depois selecione no menu das inst\u00e2ncias o m\u00f3dulo u1HalfAdder, com isso poderemos selecionar quais pinos/ sinais gostar\u00edamos de visualizar desse bloco. Arraste todos os sinais para o wave form : Resultando em: Agora podemos executar a simula\u00e7\u00e3o, na regi\u00e3o do script TCL execute o seguinte comando: vunit_run VSIM 7 > vunit_run Podemos agora visualizar a forma de onda: 4. Aprimorando teste \u00b6 Testbench (bancada de teste) \u00e9 a forma utilizada para verificarmos se um projeto de HDL (VHDL, Verilog, ...) est\u00e1 certo, o testbench pode ser escrito em v\u00e1rias linguagens inclusive em VHDL. Os TestBenchs est\u00e3o localizados nas pastas dos projetos em: /tests/tst/ . No projeto D temos os seguintes testbenchs definidos (um para cada m\u00f3dulo a ser implementando): /tests/tst/ tb_Add16.vhd tb_ALU.vhd tb_comparador16.vhd tb_FullAdder.vhd tb_HalfAdder.vhd tb_Inc16.vhd tb_inversor16.vhd tb_zerador16.vhd Nesse projeto os testes n\u00e3o est\u00e3o completos, ser\u00e1 necess\u00e1rio implementar o resto dos testes. tb_HalfAdder.vhd \u00b6 Note que na simula\u00e7\u00e3o do HalfAdder n\u00e3o testamos um dos casos de entrada: 1 + 1 , esse teste est\u00e1 incompleto. Vamos corrigir isso! O arquivo tb_HalfAdder faz a inclus\u00e3o do m\u00f3dulo HalfAdder (component e port map) instanciando esse m\u00f3dulo para uso. No arquivo \u00e9 criado est\u00edmulos na entrada do componente e verifica-se se a sa\u00edda est\u00e1 de acordo com o que deveria ser feito. modificando o arquivo \u00b6 Agora vamos modificar o arquivo para inserir o teste que est\u00e1 faltando: 1+1 , para isso inclua as linhas a seguir logo ap\u00f3s o teste 3: -- Teste: 4 -- 1 + 1 +inA <= '1'; inB<= '1'; +wait for 200 ps; +assert(soma = '0' and vaium = '1') report \"Falha em teste: 4\" severity error; Como isso funciona? Primeiro colocamos os valores desejados na entrada do componente: inA <= '1'; inB <= '1'; \u00e9 necess\u00e1rio aguardar um instante de tempo para que as portas l\u00f3gicas fiquem com a sa\u00edda est\u00e1vel (e para possibilitar a visualiza\u00e7\u00e3o na simula\u00e7\u00e3o): wait for 200 ps; Testando novamente \u00b6 Execute novamente a simula\u00e7\u00e3o com o modo --gui e verifique se o m\u00f3dulo est\u00e1 se comportando corretamente: soma = 0 e vaium = 1 . - Salve e submeta as altera\u00e7\u00f5es","title":"9 : D ULA Lab 1"},{"location":"D-ULA-Lab-1/#1-configurando-travis","text":"Facilitador (chap\u00e9u) deve realizar por\u00e9m todos devem acompanhar . Usar o monitor! At\u00e9 agora voc\u00eas utilizaram o Travis de maneira transparente, sem entender muito como ele foi configurado. Nessa nova etapa do desenvolvimento do computador Z01 iremos modificar o arquivo de configura\u00e7\u00e3o do Travis para que ele posso executar os novos scripts de teste (testar o desenvolvimento da ULA). Note que no diret\u00f3rio raiz do reposit\u00f3rio Z01.1 temos um arquivo oculto chamado .travis.yml (usu\u00e1rios LINUX esse arquivo estar\u00e1 oculto. Para exibir no gerenciador de arquivos ctrl + h , ou ls -a no terminal), esse arquivo faz toda a configura\u00e7\u00e3o do teste de integra\u00e7\u00e3o cont\u00ednua e \u00e9 dividido em algumas partes: Configura\u00e7\u00e3o da m\u00e1quina virtual ubuntu 16.04 Instala\u00e7\u00e3o das depend\u00eancias: python quartus (no Travis instalamos somente o modelsim) java Execu\u00e7\u00e3o dos scripts de teste Nessa etapa estamos interessados em adicionar mais um script de teste ao Travis (o script que testa a ULA, testeULA.py ). Para isso abra o arquivo .travis.yml e na sec\u00e7\u00e3o referente aos scripts, adicione a linha como demonstrado a seguir: script: - python Projetos/C-LogicaCombinacional/testeLogicaCombinacional.py +- python Projetos/D-UnidadeLogicaAritmetica/testeULA.py Agora, toda vez que o reposit\u00f3rio remoto ( origin ) sofrer alguma varia\u00e7\u00e3o, o Travis ir\u00e1 executar os dois scripts de teste (projeto C e projeto D). - Salve e submeta as altera\u00e7\u00f5es no master ('git checkout master') fa\u00e7a um commit com essa altera\u00e7\u00e3o ('git add .travis.yml' + 'git commit -m \"adicionado teste D\"') fa\u00e7a o push ('git push origin master')","title":"1. Configurando Travis"},{"location":"D-ULA-Lab-1/#2-implementando-o-half-adder","text":"O half-adder \u00e9 um dispositivo somador bin\u00e1rio que possui duas entradas bin\u00e1rias (a,b) e duas sa\u00eddas bin\u00e1ria (soma dos bits (Soma) e o carry (vaium)). A tabela verdade desse componente \u00e9 detalhada a seguir: a b Soma Vaium 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Com a tabela verdade podemos extrair as duas equa\u00e7\u00f5es que descreve esse componente: Soma e Vaium. soma = a xor b vaium = a and b Lembre que: not(a) b + a not(b) = a xor b Agora com a equa\u00e7\u00e3o definida \u00e9 poss\u00edvel realizarmos uma descri\u00e7\u00e3o em VHDL do componente halfadder . Abra o arquivo D-UnidadeLogicaAritmetica/src/rtl/HalfAdder.vhd e modifique sua arquitetura para implementar a equa\u00e7\u00e3o do halfadder. Edite o arquivo de configura\u00e7\u00e3o do teste tests/config.txt e descomente a linha referente ao halfadder . Valide a implementa\u00e7\u00e3o executando o script de testes: testeULA.py","title":"2. Implementando o half-adder"},{"location":"D-ULA-Lab-1/#3-visualizando-a-simulacao","text":"\u00c9 muito dif\u00edcil sabermos porque uma implementa\u00e7\u00e3o em VHDL n\u00e3o funciona, atualmente o fluxo \u00e9: transcreve para VHDL o componente; testa; n\u00e3o funcionou volta para o VHDL; testa.... Ser\u00e1 que n\u00e3o existe uma forma de conseguirmos visualizar o resultado do teste e com isso mudarmos a implementa\u00e7\u00e3o em VDHL? Sim existe! Para isso ser\u00e1 necess\u00e1rio invocarmos a parte gr\u00e1fica do modelsim. Na hora de invocarmos o script de teste ( D-UnidadeLogicaAritmetica/testeULA.py ) passe o par\u00e2metro --gui (ou -g ), como a seguir: $ python testeULA.py --gui Esse comando ir\u00e1 executar a simula\u00e7\u00e3o e abrir no software modelsim (toda a simula\u00e7\u00e3o \u00e9 realizada por esse software, mas estava sendo 'mascarada' pelos scripts de teste em py). Antes de continuar, o m\u00f3dulo do HalfAdder.vhd j\u00e1 deve est\u00e1 implementando e testado (na forma tradicional).","title":"3. Visualizando a simula\u00e7\u00e3o"},{"location":"D-ULA-Lab-1/#modelsim","text":"O modelsim n\u00e3o possui uma interface moderna, por\u00e9m \u00e9 o software de simula\u00e7\u00e3o de hardware mais completo e mais utilizado pela industria. Siga os passos a seguir para conseguirmos visualizarmos a forma de onda: Primeiramente devemos adicionar os sinais que desejamos visualizar, no caso do HalfAdder queremos ver suas entradas (a,b) e suas sa\u00eddas (soma, vaium). Para isso clique em wave : E depois selecione no menu das inst\u00e2ncias o m\u00f3dulo u1HalfAdder, com isso poderemos selecionar quais pinos/ sinais gostar\u00edamos de visualizar desse bloco. Arraste todos os sinais para o wave form : Resultando em: Agora podemos executar a simula\u00e7\u00e3o, na regi\u00e3o do script TCL execute o seguinte comando: vunit_run VSIM 7 > vunit_run Podemos agora visualizar a forma de onda:","title":"modelsim"},{"location":"D-ULA-Lab-1/#4-aprimorando-teste","text":"Testbench (bancada de teste) \u00e9 a forma utilizada para verificarmos se um projeto de HDL (VHDL, Verilog, ...) est\u00e1 certo, o testbench pode ser escrito em v\u00e1rias linguagens inclusive em VHDL. Os TestBenchs est\u00e3o localizados nas pastas dos projetos em: /tests/tst/ . No projeto D temos os seguintes testbenchs definidos (um para cada m\u00f3dulo a ser implementando): /tests/tst/ tb_Add16.vhd tb_ALU.vhd tb_comparador16.vhd tb_FullAdder.vhd tb_HalfAdder.vhd tb_Inc16.vhd tb_inversor16.vhd tb_zerador16.vhd Nesse projeto os testes n\u00e3o est\u00e3o completos, ser\u00e1 necess\u00e1rio implementar o resto dos testes.","title":"4. Aprimorando teste"},{"location":"D-ULA-Lab-1/#tb_halfaddervhd","text":"Note que na simula\u00e7\u00e3o do HalfAdder n\u00e3o testamos um dos casos de entrada: 1 + 1 , esse teste est\u00e1 incompleto. Vamos corrigir isso! O arquivo tb_HalfAdder faz a inclus\u00e3o do m\u00f3dulo HalfAdder (component e port map) instanciando esse m\u00f3dulo para uso. No arquivo \u00e9 criado est\u00edmulos na entrada do componente e verifica-se se a sa\u00edda est\u00e1 de acordo com o que deveria ser feito.","title":"tb_HalfAdder.vhd"},{"location":"D-ULA-Lab-1/#modificando-o-arquivo","text":"Agora vamos modificar o arquivo para inserir o teste que est\u00e1 faltando: 1+1 , para isso inclua as linhas a seguir logo ap\u00f3s o teste 3: -- Teste: 4 -- 1 + 1 +inA <= '1'; inB<= '1'; +wait for 200 ps; +assert(soma = '0' and vaium = '1') report \"Falha em teste: 4\" severity error; Como isso funciona? Primeiro colocamos os valores desejados na entrada do componente: inA <= '1'; inB <= '1'; \u00e9 necess\u00e1rio aguardar um instante de tempo para que as portas l\u00f3gicas fiquem com a sa\u00edda est\u00e1vel (e para possibilitar a visualiza\u00e7\u00e3o na simula\u00e7\u00e3o): wait for 200 ps;","title":"modificando o arquivo"},{"location":"D-ULA-Lab-1/#testando-novamente","text":"Execute novamente a simula\u00e7\u00e3o com o modo --gui e verifique se o m\u00f3dulo est\u00e1 se comportando corretamente: soma = 0 e vaium = 1 . - Salve e submeta as altera\u00e7\u00f5es","title":"Testando novamente"},{"location":"D-ULA-Lab-2/","text":"+ Realizar em dupla/trio (dois por grupo) Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Atualize o Z01-Tools! submodule antes de come\u00e7ar. Nesse projeto tivemos umas melhorias na infra do curso. O objetivo desse laborat\u00f3rio \u00e9 o de trabalharmos com o controle dos sinais da ULA para validarmos e entendermos as opera\u00e7\u00f5es da unidade de processamento do nosso computador. Programando FPGA com ULA Entendendo fun\u00e7\u00f5es das chaves e LEDs Controlando ULA para realizar opera\u00e7\u00f5es espec\u00edficas (exerc\u00edcios) Programando FPGA \u00b6 Com a FPGA plugada no PC e ligada, execute o script programFPGA.py da pasta do projeto D. Esse script ir\u00e1 realizar a programa\u00e7\u00e3o da FPGA com o hardware da Unidade L\u00f3gica Aritm\u00e9tica - ULA que voc\u00eas ter\u00e3o que implementar. Nesse os controles da ULA est\u00e3o mapeados para as chaves da FPGA, a sa\u00edda da ULA foi mapeada para LEDs: como ilustrado as figuras a seguir: Como isso \u00e9 feito em VHDL? De uma olhada no top level do projeto ( D-UnidadeLogicaAritmetica/src/TopLevel.vhd ) ula0: ALU port map ( x => x, Y => y, Zx => SW(0), Nx => SW(1), Zy => SW(2), Ny => SW(3), F => SW(4), No => SW(5), Zr => LEDR(8), Ng => LEDR(9), Saida(7 downto 0) => LEDR(7 downto 0), Saida(15 downto 8) => Open ); Note que ULA que iremos desenvolver no projeto D ter\u00e1 16 bits de largura, por\u00e9m como temos um limite de LEDs e bot\u00f5es na FPGA, estamos ignorando os valores mais significativos, sem afetar o projeto. Controlando ULA \u00b6 Com a FPGA programada podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas devem ser realizadas na FPGA, seus sinais de controle e resultado devem ser anotados nas tabelas. O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F Out = X \u00b6 Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X Out = Y \u00b6 Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y Out = !Y \u00b6 Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada Out = 0 \u00b6 Fa\u00e7a com que a sa\u00edda da ULA seja 0 Out = 1 \u00b6 Fa\u00e7a com que a sa\u00edda da ULA seja 1 Out = X + Y \u00b6 Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y (dif\u00edcil) Out = X ou Y \u00b6 Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y (dif\u00edcil) Out = X - Y \u00b6 Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"8 : D ULA Lab 2"},{"location":"D-ULA-Lab-2/#programando-fpga","text":"Com a FPGA plugada no PC e ligada, execute o script programFPGA.py da pasta do projeto D. Esse script ir\u00e1 realizar a programa\u00e7\u00e3o da FPGA com o hardware da Unidade L\u00f3gica Aritm\u00e9tica - ULA que voc\u00eas ter\u00e3o que implementar. Nesse os controles da ULA est\u00e3o mapeados para as chaves da FPGA, a sa\u00edda da ULA foi mapeada para LEDs: como ilustrado as figuras a seguir: Como isso \u00e9 feito em VHDL? De uma olhada no top level do projeto ( D-UnidadeLogicaAritmetica/src/TopLevel.vhd ) ula0: ALU port map ( x => x, Y => y, Zx => SW(0), Nx => SW(1), Zy => SW(2), Ny => SW(3), F => SW(4), No => SW(5), Zr => LEDR(8), Ng => LEDR(9), Saida(7 downto 0) => LEDR(7 downto 0), Saida(15 downto 8) => Open ); Note que ULA que iremos desenvolver no projeto D ter\u00e1 16 bits de largura, por\u00e9m como temos um limite de LEDs e bot\u00f5es na FPGA, estamos ignorando os valores mais significativos, sem afetar o projeto.","title":"Programando FPGA"},{"location":"D-ULA-Lab-2/#controlando-ula","text":"Com a FPGA programada podemos testar a ULA modificando seus sinais de controle. A seguir uma proposta de opera\u00e7\u00f5es l\u00f3gicas devem ser realizadas na FPGA, seus sinais de controle e resultado devem ser anotados nas tabelas. O projeto FIXA as entradas da ULA com os valores: X = 0x73 Y = 0x5F","title":"Controlando ULA"},{"location":"D-ULA-Lab-2/#out-x","text":"Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada X","title":"Out = X"},{"location":"D-ULA-Lab-2/#out-y","text":"Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada Y","title":"Out = Y"},{"location":"D-ULA-Lab-2/#out-y_1","text":"Configure os controles da ULA para fazer com que a sa\u00edda da ULA seja a entrada a entrada Y negada","title":"Out = !Y"},{"location":"D-ULA-Lab-2/#out-0","text":"Fa\u00e7a com que a sa\u00edda da ULA seja 0","title":"Out = 0"},{"location":"D-ULA-Lab-2/#out-1","text":"Fa\u00e7a com que a sa\u00edda da ULA seja 1","title":"Out = 1"},{"location":"D-ULA-Lab-2/#out-x-y","text":"Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X + a entrada Y","title":"Out = X + Y"},{"location":"D-ULA-Lab-2/#dificil-out-x-ou-y","text":"Fa\u00e7a com que a sa\u00edda da ULA seja X ou Y","title":"(dif\u00edcil) Out = X ou Y"},{"location":"D-ULA-Lab-2/#dificil-out-x-y","text":"Fa\u00e7a com que a sa\u00edda da ULA seja a entrada X menos a entrada Y","title":"(dif\u00edcil) Out = X - Y"},{"location":"D-ULA-Projeto/","text":"D - ULA \u00b6 Neste projeto seu grupo ter\u00e1 que desenvolver os componentes para a implementa\u00e7\u00e3o de uma unidade l\u00f3gica e aritm\u00e9tica (ULA) de 16 bit (proposta pelo livro texto) que ser\u00e1 capaz de realizar opera\u00e7\u00f5es bin\u00e1rias muito simples por\u00e9m que possibilitar\u00e1 realizarmos muitas coisas! Note Nas discuss\u00f5es com o grupo, o scrum master dever\u00e1 definir os m\u00f3dulos que cada integrante ir\u00e1 desenvolver. Crie uma rotina para commits e pull-requests. Tip Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Tip Sempre teste os m\u00f3dulos e verifique se est\u00e1 funcionando como o esperado. Instru\u00e7\u00f5es \u00b6 A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: /D-ULA testeULA.py programFPGA.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd; testeULA.py: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd: Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd: Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta D-UnidadeLogicaAritmetica/ e execute o script python localizado nessa pasta: $ ./testeULA.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail . O que deve ser feito: \u00b6 Al\u00e9m de implementar os m\u00f3dulos, deve-se gerar uma imagem com a forma de onda desse m\u00f3dulo. Para cada nova implementa\u00e7\u00e3o deve-se criar um novo branch e remover o coment\u00e1rio do arquivo: tests/config.txt somente o m\u00f3dulo que est\u00e1 sendo implementado. Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos do projeto anterior (C). Esses m\u00f3dulos anteriores, j\u00e1 s\u00e3o inclu\u00eddos, automaticamente (pelo script), na compila\u00e7\u00e3o dos m\u00f3dulos do projeto D. M\u00f3dulos \u00b6 Note Esses arquivos est\u00e3o localizados em D-UnidadeLogicaAritmetica/src/rtl/ Deve-se implementar os seguintes circuitos combinacionais: HalfAdder Arquivo : HalfAdder.vhd Descri\u00e7\u00e3o : Adiciona dois bits que resulta em um bit de soma e outro de carry out. Depend\u00eancia : N\u00e3o tem. FullAdder Arquivo : FullAdder.vhd Descri\u00e7\u00e3o : Adiciona tr\u00eas bits, dois referentes \u00e0s entradas e o outro referente ao carry in. O resultado \u00e9 um bit com a soma e outro com o carry out. Depend\u00eancia : N\u00e3o tem. Add16 Arquivo : Add16.vhd Descri\u00e7\u00e3o : Adiciona dois vetores de 16 bits resultando em um vetor de 16 bits (sem carry out do bit mais significativo - MSB). Depend\u00eancia : FullAdder Inc16 Arquivo : Inc16.vhd Descri\u00e7\u00e3o : Adiciona '1' a um vetor de 16 bits resultando em um vetor de 16 bits (sem carry out do MSB). Depend\u00eancia : Add16 Inversor16 Arquivo : Inversor16.vhd Descri\u00e7\u00e3o : Inverte um vetor de entrada quando o bit de controle n (nx ou ny) for igual a '1', e n\u00e3o modifica o vetor de entrada caso contr\u00e1rio. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Zerador16 Arquivo : Zerador16.vhd Descri\u00e7\u00e3o : Zera um vetor de entrada quando o bit de controle z (zx ou zy) for igual a '1'. N\u00e3o modifica o vetor de entrada se o bit for '0'. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Comparador16 Arquivo : Comparador16.vhd Descri\u00e7\u00e3o : Verifica se o vetor de sa\u00edda (16 bits) \u00e9 igual a zero ( zr ) e se menor que Zero ( ng ). Caso igual a zero, faz com que o sinal zr seja igual a '1' e caso contr\u00e1rio '0'. Se o sinal de entrada for negativo faz com que ng receba '1' e '0' caso contr\u00e1rio. Depend\u00eancia : N\u00e3o tem. Pseudo c\u00f3digo : if ( a == 0 ): zr = 1 else : zr = 0 if ( a < 0 ): ng = 1 else : ng = 0 ALU Arquivo : ALU.vhd Descri\u00e7\u00e3o : A entidade que faz o mapeamento de todas as demais, interligando os blocos (zerador, comparador, inversor, Add ....) em um \u00fanico bloco. Depend\u00eancia : Comparador16 , Zerador16 , Inversor16 , Add16 , Para implementar a ALU ser\u00e1 necess\u00e1rio usar os blocos desenvolvidos neste projeto e os blocos desenvolvidos no projeto anterior: And16, Mux16. O script de compila\u00e7\u00e3o e teste j\u00e1 faz a inclus\u00e3o deles. A arquitetura da ULA pode ser vista abaixo: Forma de onda \u00b6 Para cada teste realizado, deve-se carregar a interface gr\u00e1fica e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele ( lab 8 ). Essa imagem deve ser salva na mesma pasta dos arquivos VHDL (src/rtl/) e com o mesmo nome dos m\u00f3dulos. A pasta no final do projeto deve possuir os seguintes arquivos: /src/rtl/ Add16.vhd Add16.png ALU.vhd ALU.png Comparador16.vhd Comparador16.png FullAdder.vhd FullAdder.png HalfAdder.vhd HalfAdder.png Inc16.vhd Inc16.png Inversor16.vhd Inversor16.png Zerador16.vhd Zerador16.png Testando em HW \u00b6 Para testar os m\u00f3dulos em hardware, deve-se abrir o projeto (D-UnidadeLogicaAritmetica/Quartus). Ele j\u00e1 inclui todos os m\u00f3dulos desta entrega e tamb\u00e9m os m\u00f3dulos da entrega passada. O arquivo localizado em /rtl/toplevel.vhd j\u00e1 faz o mapeamento dos pinos da FPGA para os pinos da ULA (como no lab 9 ). Para testar no hardware basta compilar e programar a FPGA. Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - N\u00e3o implementou os m\u00f3dulos Add16, ULA, Comparador, FullAdder, HalfAdder, Inc16, Inversosr, Zerador. D - Implementou todos os m\u00f3dulos menos a ULA. C - Configurou o travis e funcionou. - Todos os testes passaram (ok). - ULA funcionando. - Todos os m\u00f3dulos sendo testados no Travis. - Possui a forma de onda de todos os m\u00f3dulos (.png). B - Compila no Quartus a ULA do grupo e fez um v\u00eddeo demonstrando o seu funcionamento (FPGA). O v\u00eddeo pode estar no git (se for pequeno) ou hospedado em algum site A - Modifica a ULA incluindo uma instru\u00e7\u00e3o a mais (exe: shift left/right) Desenvolvedor e Scrum Master \u00b6 As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link : Rubricas Scrum e Desenvolvedor","title":"Projeto"},{"location":"D-ULA-Projeto/#d-ula","text":"Neste projeto seu grupo ter\u00e1 que desenvolver os componentes para a implementa\u00e7\u00e3o de uma unidade l\u00f3gica e aritm\u00e9tica (ULA) de 16 bit (proposta pelo livro texto) que ser\u00e1 capaz de realizar opera\u00e7\u00f5es bin\u00e1rias muito simples por\u00e9m que possibilitar\u00e1 realizarmos muitas coisas! Note Nas discuss\u00f5es com o grupo, o scrum master dever\u00e1 definir os m\u00f3dulos que cada integrante ir\u00e1 desenvolver. Crie uma rotina para commits e pull-requests. Tip Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Tip Sempre teste os m\u00f3dulos e verifique se est\u00e1 funcionando como o esperado.","title":"D - ULA"},{"location":"D-ULA-Projeto/#instrucoes","text":"A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: /D-ULA testeULA.py programFPGA.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd; testeULA.py: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd: Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd: Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl.","title":"Instru\u00e7\u00f5es"},{"location":"D-ULA-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta D-UnidadeLogicaAritmetica/ e execute o script python localizado nessa pasta: $ ./testeULA.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail .","title":"Executando o Script de Teste"},{"location":"D-ULA-Projeto/#o-que-deve-ser-feito","text":"Al\u00e9m de implementar os m\u00f3dulos, deve-se gerar uma imagem com a forma de onda desse m\u00f3dulo. Para cada nova implementa\u00e7\u00e3o deve-se criar um novo branch e remover o coment\u00e1rio do arquivo: tests/config.txt somente o m\u00f3dulo que est\u00e1 sendo implementado. Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos do projeto anterior (C). Esses m\u00f3dulos anteriores, j\u00e1 s\u00e3o inclu\u00eddos, automaticamente (pelo script), na compila\u00e7\u00e3o dos m\u00f3dulos do projeto D.","title":"O que deve ser feito:"},{"location":"D-ULA-Projeto/#modulos","text":"Note Esses arquivos est\u00e3o localizados em D-UnidadeLogicaAritmetica/src/rtl/ Deve-se implementar os seguintes circuitos combinacionais: HalfAdder Arquivo : HalfAdder.vhd Descri\u00e7\u00e3o : Adiciona dois bits que resulta em um bit de soma e outro de carry out. Depend\u00eancia : N\u00e3o tem. FullAdder Arquivo : FullAdder.vhd Descri\u00e7\u00e3o : Adiciona tr\u00eas bits, dois referentes \u00e0s entradas e o outro referente ao carry in. O resultado \u00e9 um bit com a soma e outro com o carry out. Depend\u00eancia : N\u00e3o tem. Add16 Arquivo : Add16.vhd Descri\u00e7\u00e3o : Adiciona dois vetores de 16 bits resultando em um vetor de 16 bits (sem carry out do bit mais significativo - MSB). Depend\u00eancia : FullAdder Inc16 Arquivo : Inc16.vhd Descri\u00e7\u00e3o : Adiciona '1' a um vetor de 16 bits resultando em um vetor de 16 bits (sem carry out do MSB). Depend\u00eancia : Add16 Inversor16 Arquivo : Inversor16.vhd Descri\u00e7\u00e3o : Inverte um vetor de entrada quando o bit de controle n (nx ou ny) for igual a '1', e n\u00e3o modifica o vetor de entrada caso contr\u00e1rio. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Zerador16 Arquivo : Zerador16.vhd Descri\u00e7\u00e3o : Zera um vetor de entrada quando o bit de controle z (zx ou zy) for igual a '1'. N\u00e3o modifica o vetor de entrada se o bit for '0'. O resultado \u00e9 um novo vetor de 16 bits. Depend\u00eancia : N\u00e3o tem. Comparador16 Arquivo : Comparador16.vhd Descri\u00e7\u00e3o : Verifica se o vetor de sa\u00edda (16 bits) \u00e9 igual a zero ( zr ) e se menor que Zero ( ng ). Caso igual a zero, faz com que o sinal zr seja igual a '1' e caso contr\u00e1rio '0'. Se o sinal de entrada for negativo faz com que ng receba '1' e '0' caso contr\u00e1rio. Depend\u00eancia : N\u00e3o tem. Pseudo c\u00f3digo : if ( a == 0 ): zr = 1 else : zr = 0 if ( a < 0 ): ng = 1 else : ng = 0 ALU Arquivo : ALU.vhd Descri\u00e7\u00e3o : A entidade que faz o mapeamento de todas as demais, interligando os blocos (zerador, comparador, inversor, Add ....) em um \u00fanico bloco. Depend\u00eancia : Comparador16 , Zerador16 , Inversor16 , Add16 , Para implementar a ALU ser\u00e1 necess\u00e1rio usar os blocos desenvolvidos neste projeto e os blocos desenvolvidos no projeto anterior: And16, Mux16. O script de compila\u00e7\u00e3o e teste j\u00e1 faz a inclus\u00e3o deles. A arquitetura da ULA pode ser vista abaixo:","title":"M\u00f3dulos"},{"location":"D-ULA-Projeto/#forma-de-onda","text":"Para cada teste realizado, deve-se carregar a interface gr\u00e1fica e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele ( lab 8 ). Essa imagem deve ser salva na mesma pasta dos arquivos VHDL (src/rtl/) e com o mesmo nome dos m\u00f3dulos. A pasta no final do projeto deve possuir os seguintes arquivos: /src/rtl/ Add16.vhd Add16.png ALU.vhd ALU.png Comparador16.vhd Comparador16.png FullAdder.vhd FullAdder.png HalfAdder.vhd HalfAdder.png Inc16.vhd Inc16.png Inversor16.vhd Inversor16.png Zerador16.vhd Zerador16.png","title":"Forma de onda"},{"location":"D-ULA-Projeto/#testando-em-hw","text":"Para testar os m\u00f3dulos em hardware, deve-se abrir o projeto (D-UnidadeLogicaAritmetica/Quartus). Ele j\u00e1 inclui todos os m\u00f3dulos desta entrega e tamb\u00e9m os m\u00f3dulos da entrega passada. O arquivo localizado em /rtl/toplevel.vhd j\u00e1 faz o mapeamento dos pinos da FPGA para os pinos da ULA (como no lab 9 ). Para testar no hardware basta compilar e programar a FPGA.","title":"Testando em HW"},{"location":"D-ULA-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"D-ULA-Projeto/#projeto","text":"Conceito I - N\u00e3o implementou os m\u00f3dulos Add16, ULA, Comparador, FullAdder, HalfAdder, Inc16, Inversosr, Zerador. D - Implementou todos os m\u00f3dulos menos a ULA. C - Configurou o travis e funcionou. - Todos os testes passaram (ok). - ULA funcionando. - Todos os m\u00f3dulos sendo testados no Travis. - Possui a forma de onda de todos os m\u00f3dulos (.png). B - Compila no Quartus a ULA do grupo e fez um v\u00eddeo demonstrando o seu funcionamento (FPGA). O v\u00eddeo pode estar no git (se for pequeno) ou hospedado em algum site A - Modifica a ULA incluindo uma instru\u00e7\u00e3o a mais (exe: shift left/right)","title":"Projeto"},{"location":"D-ULA-Projeto/#desenvolvedor-e-scrum-master","text":"As rubricas a serem seguidas ser\u00e3o comuns a todos os projeto e est\u00e1 descrito no link : Rubricas Scrum e Desenvolvedor","title":"Desenvolvedor e Scrum Master"},{"location":"E-Sequencial-Lab-1/","text":"Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Atualize o Z01-Tools! submodule antes de come\u00e7ar. Nesse projeto tivemos umas melhorias na infra do curso. (realizar em dupla/ individual) Process VHDL \u00b6 Em VHDL quando desejamos fazer algo sequ\u00eancial \u00e9 necess\u00e1rio usarmos uma estrutura chamada de process, que possui a declara\u00e7\u00e3o a seguir: process (optional sensitivity list) declarations begin sequential statements end process; Nesse process possu\u00edmos a lista de sensibilidade ( sensitivity list ) que indica quando o process ser\u00e1 executado. Podemos pensar da seguinte maneira, sempre que algum sinal que est\u00e1 listado nessa lista de sensibilidade mudar de valor (0 -> 1, 1 -> 0) o processo ser\u00e1 executado. Vamos ver o exemplo a seguir: process(A) begin Q <= A; end process; Sempre que o sinal A (sinal ou porta) alterar de valor o sinal Q ser\u00e1 atribu\u00eddo com o seu valor Agora vamos criar um outro processo, esse estar\u00e1 errado : process(A) begin Q <= A and B; end process; A ideia por traz desse processo seria que o sinal Q receba o sinal A e B sempre que algum dos dois sofram alguma altera\u00e7\u00e3o, por\u00e9m essa implementa\u00e7\u00e3o n\u00e3o ir\u00e1 funcionar j\u00e1 que B n\u00e3o faz parte da lista de sensibilidade e se B mudar de valor o processo n\u00e3o ser\u00e1 chamado, o sinal Q s\u00f3 ser\u00e1 atualizado quando A mudar de valor. Reescreva na lousa o m\u00f3dulo anterior para corrigindo esse problema + Fa\u00e7a na lousa. Chame o professor para validar Clock \u00b6 Para inserirmos um clock (um sistema s\u00edncrono) precisamos necessariamente usar um process , e a arquitetura \u00e9 a seguinte: process(clock) begin if(rising_edge(clock)) then Q <= D; end if; end process; Sempre que o clock sofrer varia\u00e7\u00e3o (0 -> 1, 1 -> 0) o process \u00e9 chamado e verifica-se se a transi\u00e7\u00e3o foi de borda de subida ( rising_edge ) se for, atribui o sinal A ao sinal Q, caso contr\u00e1rio Q mant\u00e9m seu \u00faltimo valor. Modifique o arquivo E-LogicaSequencial/src/rtl/FlipFlopD.vhd que declara um Flip Flop do tipo D inserindo o c\u00f3digo de exemplo anterior. + Fa\u00e7a local no seu PC. \u00b6 Em FPGA um sinal digital n\u00e3o deve sofrer atualiza\u00e7\u00e3o em ambas as bordas: subida ( rising_edge ) e de descida ( falling_edge ) pois n\u00e3o ser\u00e1 suportado por hardware . Salvo em registradores DDR (duble data rate) especiais, exemplo do que n\u00e3o deve ser feito!: process(clock) begin if(rising_edge(clock)) then Q <= D; elsif(falling_edge(clock)) then Q <= D; end if; end process; RTL Viewer \u00b6 RTL \u00e9 uma forma de visualiza\u00e7\u00e3o de um circuito digital. Ela nos ajudar\u00e1 a entender o circuito que foi escrito em HDL. Muitas vezes a pr\u00f3pria ferramenta n\u00e3o compreende o hardware que desejamos descrever (lembre que HDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware, n\u00e3o de programa\u00e7\u00e3o). Com o RTL conseguimos ter uma no\u00e7\u00e3o de qual foi a 'interpreta\u00e7\u00e3o' do nosso hardware que a ferramenta (no caso o Quartus) entendeu. O RTL Viewer \u00e9 uma ferramenta do Quartus utilizada para visualizar o RTL (interpreta\u00e7\u00e3o do hardware descrito em HDL). + Fa\u00e7a os passos a seguir no seu PC. Para criarmos esse RTL de um m\u00f3dulo espec\u00edfico devemos no Quartus selecionar o componente em quest\u00e3o como TopLevel , para isso fa\u00e7a o seguinte: Abra o projeto no Quartus localizado em E-LogicaSequencial/Quartus/ No Project Navigator escolha por Files : Encontre o arquivo que deseja configurar como TopLevel : Clique com o bot\u00e3o direito no arquivo e selecione a op\u00e7\u00e3o: Set as Top Level Entity Agora o Quartus ir\u00e1 enterpretar esse m\u00f3dulo como sendo o \"top\" do projeto (podemos pensar como sendo o main ). Compile o Projeto ( Processing -> Start ) Abra o RTL Viewer ( Tools -> NetList Viewers -> RTL Viewer ) Esse c\u00f3digo em VHDL ir\u00e1 ser interpretada pelo compilador como um FlipFlop tipo D. Testando na FPGA \u00b6 No Quartus atribua ao toplevel o arquivo TopLevel.vhd (mesmo passos anteriores), esse m\u00f3dulo ir\u00e1 mapear o FF rec\u00e9m criado para os pinos da FPGA: Clock <= not KEY(0); -- os botoes quando nao apertado vale 1 -- e apertado 0, essa logica inverte isso clear <= not KEY(1); set <= not KEY(2); u0 : FlipFlopD port map ( clock => Clock, d => SW(0), clear => clear, preset => set, q => LEDR(0) ); Note que nesse c\u00f3digo estamos usando os bot\u00f5es ( KEY ) da FPGA, al\u00e9m dos LEDs e das Chaves (SW). COMPILE, PROGRAME E TESTE + Chame um professor para validar Esse exemplo n\u00e3o segue as boas pr\u00e1ticas de projetos em FPGA pois n\u00e3o se deve gerar um clock a partir de um pino qualquer da FPGA, a FPGA possui pinos espec\u00edficos para a gera\u00e7\u00e3o do clock. Por\u00e9m \u00e9 a melhor maneira did\u00e1tica de mostrar um FF operando. O correto seria colocarmos um pino de \"enable\" que ativaria ou n\u00e3o o FF quando o bot\u00e3o fosse pressionado. Reset e Preset \u00b6 Flip Flops possuem normalmente dois outros sinais de controle: Clear e Preset , usados respectivamente para for\u00e7ar '0' ou '1' em sua sa\u00edda. Vamos modificar o c\u00f3digo anterior para suportar essas duas outras funcionalidades. Nesse caso possu\u00edmos duas op\u00e7\u00f5es: Set/Clear : s\u00edncrono Set/Clear : ass\u00edncrono O modo s\u00edncrono seria que o set e o clear s\u00f3 podem ser executado na subida do clock e no ass\u00edncrono em qualquer momento que o sinal se set e clear forem alterados o FF ir\u00e1 responder imediatamente. Nesse caso, iremos implementar o FF com set e reset ass\u00edncrono, para isso utilize a seguinte estrutura a seguir que j\u00e1 implementa o sinal de clear : process(clock, clear) begin if (clear = '1') then Q <= '0'; elsif(rising_edge(clock)) then Q <= D; end if; end process; + Fa\u00e7a local no seu PC. Modifique o arquivo para implementar o set (o clear j\u00e1 est\u00e1 feito) Agora voc\u00ea pode executar o script de teste do projeto e verificar se a implementa\u00e7\u00e3o est\u00e1 correta, analise tamb\u00e9m a forma de onda via modelsim (rodando com -g ). Descomente o teste FlipFlopD.vhd do arquivo tests/config.txt execute testeLogicaSequencial.py -g no terminal Gere o RTL, analise o resultado e salve a forma de onda na pasta src/rtl/ do projeto. Compile e teste na FPGA COMPILE, PROGRAME E TESTE Voc\u00ea deve ser capaz de: + Chame um professor para validar sua explica\u00e7\u00e3o Validando \u00b6 Ao final desse laborat\u00f3rio voc\u00ea deve ser capaz de: Gerar um RTL Saber o que \u00e9 um process em VHDL e o impacto da lista de sensibilidade Saber o que \u00e9 um FlipFlop tipo D Explicar a forma de onda do FlipFlopD gerada no modelsim Explicar o RTL do FlipFlopD criado pelo Quartus","title":"10: E Sequencial Lab 1"},{"location":"E-Sequencial-Lab-1/#process-vhdl","text":"Em VHDL quando desejamos fazer algo sequ\u00eancial \u00e9 necess\u00e1rio usarmos uma estrutura chamada de process, que possui a declara\u00e7\u00e3o a seguir: process (optional sensitivity list) declarations begin sequential statements end process; Nesse process possu\u00edmos a lista de sensibilidade ( sensitivity list ) que indica quando o process ser\u00e1 executado. Podemos pensar da seguinte maneira, sempre que algum sinal que est\u00e1 listado nessa lista de sensibilidade mudar de valor (0 -> 1, 1 -> 0) o processo ser\u00e1 executado. Vamos ver o exemplo a seguir: process(A) begin Q <= A; end process; Sempre que o sinal A (sinal ou porta) alterar de valor o sinal Q ser\u00e1 atribu\u00eddo com o seu valor Agora vamos criar um outro processo, esse estar\u00e1 errado : process(A) begin Q <= A and B; end process; A ideia por traz desse processo seria que o sinal Q receba o sinal A e B sempre que algum dos dois sofram alguma altera\u00e7\u00e3o, por\u00e9m essa implementa\u00e7\u00e3o n\u00e3o ir\u00e1 funcionar j\u00e1 que B n\u00e3o faz parte da lista de sensibilidade e se B mudar de valor o processo n\u00e3o ser\u00e1 chamado, o sinal Q s\u00f3 ser\u00e1 atualizado quando A mudar de valor. Reescreva na lousa o m\u00f3dulo anterior para corrigindo esse problema + Fa\u00e7a na lousa. Chame o professor para validar","title":"Process VHDL"},{"location":"E-Sequencial-Lab-1/#clock","text":"Para inserirmos um clock (um sistema s\u00edncrono) precisamos necessariamente usar um process , e a arquitetura \u00e9 a seguinte: process(clock) begin if(rising_edge(clock)) then Q <= D; end if; end process; Sempre que o clock sofrer varia\u00e7\u00e3o (0 -> 1, 1 -> 0) o process \u00e9 chamado e verifica-se se a transi\u00e7\u00e3o foi de borda de subida ( rising_edge ) se for, atribui o sinal A ao sinal Q, caso contr\u00e1rio Q mant\u00e9m seu \u00faltimo valor. Modifique o arquivo E-LogicaSequencial/src/rtl/FlipFlopD.vhd que declara um Flip Flop do tipo D inserindo o c\u00f3digo de exemplo anterior.","title":"Clock"},{"location":"E-Sequencial-Lab-1/#faca-local-no-seu-pc","text":"Em FPGA um sinal digital n\u00e3o deve sofrer atualiza\u00e7\u00e3o em ambas as bordas: subida ( rising_edge ) e de descida ( falling_edge ) pois n\u00e3o ser\u00e1 suportado por hardware . Salvo em registradores DDR (duble data rate) especiais, exemplo do que n\u00e3o deve ser feito!: process(clock) begin if(rising_edge(clock)) then Q <= D; elsif(falling_edge(clock)) then Q <= D; end if; end process;","title":"+ Fa\u00e7a local no seu PC."},{"location":"E-Sequencial-Lab-1/#rtl-viewer","text":"RTL \u00e9 uma forma de visualiza\u00e7\u00e3o de um circuito digital. Ela nos ajudar\u00e1 a entender o circuito que foi escrito em HDL. Muitas vezes a pr\u00f3pria ferramenta n\u00e3o compreende o hardware que desejamos descrever (lembre que HDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware, n\u00e3o de programa\u00e7\u00e3o). Com o RTL conseguimos ter uma no\u00e7\u00e3o de qual foi a 'interpreta\u00e7\u00e3o' do nosso hardware que a ferramenta (no caso o Quartus) entendeu. O RTL Viewer \u00e9 uma ferramenta do Quartus utilizada para visualizar o RTL (interpreta\u00e7\u00e3o do hardware descrito em HDL). + Fa\u00e7a os passos a seguir no seu PC. Para criarmos esse RTL de um m\u00f3dulo espec\u00edfico devemos no Quartus selecionar o componente em quest\u00e3o como TopLevel , para isso fa\u00e7a o seguinte: Abra o projeto no Quartus localizado em E-LogicaSequencial/Quartus/ No Project Navigator escolha por Files : Encontre o arquivo que deseja configurar como TopLevel : Clique com o bot\u00e3o direito no arquivo e selecione a op\u00e7\u00e3o: Set as Top Level Entity Agora o Quartus ir\u00e1 enterpretar esse m\u00f3dulo como sendo o \"top\" do projeto (podemos pensar como sendo o main ). Compile o Projeto ( Processing -> Start ) Abra o RTL Viewer ( Tools -> NetList Viewers -> RTL Viewer ) Esse c\u00f3digo em VHDL ir\u00e1 ser interpretada pelo compilador como um FlipFlop tipo D.","title":"RTL Viewer"},{"location":"E-Sequencial-Lab-1/#testando-na-fpga","text":"No Quartus atribua ao toplevel o arquivo TopLevel.vhd (mesmo passos anteriores), esse m\u00f3dulo ir\u00e1 mapear o FF rec\u00e9m criado para os pinos da FPGA: Clock <= not KEY(0); -- os botoes quando nao apertado vale 1 -- e apertado 0, essa logica inverte isso clear <= not KEY(1); set <= not KEY(2); u0 : FlipFlopD port map ( clock => Clock, d => SW(0), clear => clear, preset => set, q => LEDR(0) ); Note que nesse c\u00f3digo estamos usando os bot\u00f5es ( KEY ) da FPGA, al\u00e9m dos LEDs e das Chaves (SW). COMPILE, PROGRAME E TESTE + Chame um professor para validar Esse exemplo n\u00e3o segue as boas pr\u00e1ticas de projetos em FPGA pois n\u00e3o se deve gerar um clock a partir de um pino qualquer da FPGA, a FPGA possui pinos espec\u00edficos para a gera\u00e7\u00e3o do clock. Por\u00e9m \u00e9 a melhor maneira did\u00e1tica de mostrar um FF operando. O correto seria colocarmos um pino de \"enable\" que ativaria ou n\u00e3o o FF quando o bot\u00e3o fosse pressionado.","title":"Testando na FPGA"},{"location":"E-Sequencial-Lab-1/#reset-e-preset","text":"Flip Flops possuem normalmente dois outros sinais de controle: Clear e Preset , usados respectivamente para for\u00e7ar '0' ou '1' em sua sa\u00edda. Vamos modificar o c\u00f3digo anterior para suportar essas duas outras funcionalidades. Nesse caso possu\u00edmos duas op\u00e7\u00f5es: Set/Clear : s\u00edncrono Set/Clear : ass\u00edncrono O modo s\u00edncrono seria que o set e o clear s\u00f3 podem ser executado na subida do clock e no ass\u00edncrono em qualquer momento que o sinal se set e clear forem alterados o FF ir\u00e1 responder imediatamente. Nesse caso, iremos implementar o FF com set e reset ass\u00edncrono, para isso utilize a seguinte estrutura a seguir que j\u00e1 implementa o sinal de clear : process(clock, clear) begin if (clear = '1') then Q <= '0'; elsif(rising_edge(clock)) then Q <= D; end if; end process; + Fa\u00e7a local no seu PC. Modifique o arquivo para implementar o set (o clear j\u00e1 est\u00e1 feito) Agora voc\u00ea pode executar o script de teste do projeto e verificar se a implementa\u00e7\u00e3o est\u00e1 correta, analise tamb\u00e9m a forma de onda via modelsim (rodando com -g ). Descomente o teste FlipFlopD.vhd do arquivo tests/config.txt execute testeLogicaSequencial.py -g no terminal Gere o RTL, analise o resultado e salve a forma de onda na pasta src/rtl/ do projeto. Compile e teste na FPGA COMPILE, PROGRAME E TESTE Voc\u00ea deve ser capaz de: + Chame um professor para validar sua explica\u00e7\u00e3o","title":"Reset e Preset"},{"location":"E-Sequencial-Lab-1/#validando","text":"Ao final desse laborat\u00f3rio voc\u00ea deve ser capaz de: Gerar um RTL Saber o que \u00e9 um process em VHDL e o impacto da lista de sensibilidade Saber o que \u00e9 um FlipFlop tipo D Explicar a forma de onda do FlipFlopD gerada no modelsim Explicar o RTL do FlipFlopD criado pelo Quartus","title":"Validando"},{"location":"E-Sequencial-Projeto/","text":"E - L\u00f3gica Sequencia \u00b6 Neste projeto voc\u00ea ter\u00e1 que desenvolver os componentes de mem\u00f3ria que ser\u00e3o utilizados no computador Z01. Instru\u00e7\u00f5es \u00b6 A pasta do projeto E-LogicaSequencial no reposit\u00f3rio Z01, possui a seguinte estrutura: /E-LogicaSequencial testeLogicaSequencial.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd ; scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd : Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta E-LogicaSequencial e execute o script python localizado nessa pasta: $ python testeLogicaSequencial.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Note Lembre que o arquivo tests/config.txt define quais testes ser\u00e3o executados. Projeto \u00b6 Deve-se gerar uma imagem com a forma de onda desses m\u00f3dulos. Deve-se gerar um RTL para cada m\u00f3dulo do projeto ( E-LogicaSequencial-Lab-1 ) Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos dos projetos anteriores. Para isso basta declarar o componente e usar o m\u00f3dulo. M\u00f3dulos \u00b6 Esses arquivos est\u00e3o localizados em E-LogicaSequencial/src/rtl/ e detalhados no Cap\u00edtulo 3 - The Elements of Computing Systems Flip Flop Arquivo : FlipFlopD.vhd Depend\u00eancia : \u00c9 \u00e9 um bloco elementar e sua implementa\u00e7\u00e3o \u00e9 criada no laborat\u00f3rio do projeto . Binary Digit Arquivo : BinaryDigit.vhd Depend\u00eancia : FlipFlopD e Mux2Way Descri\u00e7\u00e3o : \u00c9 um registrador feito para armazenar um \u00fanico bit de informa\u00e7\u00e3o (0 ou 1). A interface do m\u00f3dulo consiste em uma entrada (d) para o bit a ser armazenado, um sinal de load para indicar quando o bit de entrada deve ser armazenado um sinal de clock e a sa\u00edda output* que \u00e9 o bit armazenado: Register 8 Arquivo : Register8.vhd Depend\u00eancia : BinaryDigit Descri\u00e7\u00e3o : \u00c9 um registrador de 8 bits criado a partir do binaryDigit por\u00e9m agora para armazenar um vetor de entrada de 8 bits de tamanho. Register 16 Arquivo : Register16.vhd Depend\u00eancia : Register8 Descri\u00e7\u00e3o : \u00c9 um registrador de 16 bits criado a partir do Register8 por\u00e9m agora para armazenar um vetor de entrada de 16 bits de tamanho. Register 32 Arquivo : Register32.vhd Depend\u00eancia : Register16 Descri\u00e7\u00e3o : \u00c9 um registrador de 32 bits criado a partir do Register16 por\u00e9m agora para armazenar um vetor de entrada de 32 bits de tamanho. Register 64 Arquivo : Register64.vhd Depend\u00eancia : Register32 Descri\u00e7\u00e3o : \u00c9 um registrador de 64 bits criado a partir do Register32 por\u00e9m agora para armazenar um vetor de entrada de 64 bits de tamanho. Program Counter Arquivo : PC.vhd Depend\u00eancia : inc16 , mux16 , reg16 Descri\u00e7\u00e3o : O program counter ser\u00e1 o nosso endere\u00e7ador de mem\u00f3ria da CPU, ele ser\u00e1 respons\u00e1vel por apontar para a pr\u00f3xima instru\u00e7\u00e3o a ser executada. Como normalmente um c\u00f3digo segue um fluxo sequencial (uma linha na sequ\u00eancia da outra) o PC possui a habilidade de se auto incrementar a cada clock (apontando assim para a pr\u00f3xima instru\u00e7\u00e3o), mas ele tem que suportar condi\u00e7\u00f5es (if, while, ...) rompendo com esse fluxo cont\u00ednuo. Sua l\u00f3gica \u00e9 descrita no pseudo c\u00f3digo a seguir: If reset(t-1) then out(t)=0 else if load(t-1) then out(t)=in(t-1) else if inc(t-1) then out(t)=out(t-1)+1 else out(t)=out(t-1) Ram8 Arquivo : Ram8.vhd Depend\u00eancia : Register16 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : \u00c9 uma mem\u00f3ria de 8 endere\u00e7os com 16 bits de largura. O componente possui como entrada o vetor input de 16 bits, o endere\u00e7o a ser armazenado (address) o sinal load que indica quando \u00e9 para ser armazenado e o clock. Como sa\u00edda temos o valor lido no endere\u00e7o especificado quando load for igual a 0. Note que sinal LOAD tem como fun\u00e7\u00e3o similar o do READ/WRITE, quando zero, indica que queremos ler o valor armazenado, quando 1 indica que queremos escrever (write) nessa posi\u00e7\u00e3o. Ram64 Arquivo : Ram64.vhd Depend\u00eancia : Ram8 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 64 endere\u00e7os. Ram512 Arquivo : Ram512.vhd Depend\u00eancia : Ram64 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 512 endere\u00e7os. Ram4k Arquivo : Ram4k.vhd Depend\u00eancia : Ram512 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 4512 endere\u00e7os. Tip Todos esses m\u00f3dulos est\u00e3o bem documentados no livro The Elements of Computer System. Cap 3. Forma de onda \u00b6 Para cada teste realizado, deve-se carregar a interface gr\u00e1fica do simulador e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele. Essa imagem deve ser salva na mesma pasta dos arquivos vhdl ( src/doc/*_wave.png ) e com o mesmo nome dos m\u00f3dulos (similar ao projeto passado). Warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es. RTL \u00b6 Para cada m\u00f3dulo deve-se gerar o RTL e salvar uma imagem da implementa\u00e7\u00e3o na pasta src/doc/_rtl.png . !! warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es. Testando em Hardware \u00b6 No hardware voc\u00ea dever\u00e1 desenvolver um cen\u00e1rio de teste para o Program Counter ou para para a RAM8 . Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o foi implementando ou n\u00e3o passa no testes. C - Todos os m\u00f3dulos sendo testados no Travis - O ramo master passa nos testes do travis - Todos os m\u00f3dulos passam nos testes - Possui a forma de onda e rtl de todos os m\u00f3dulos (.png) B - Usou sempre que poss\u00edvel outros m\u00f3dulos para criar um novo (hierarquia) - Exemplo: usou o inc16 , mux16 e reg16 para criar PC A - Gravou e testou a mem\u00f3ria RAM8 na FPGA. (gravou um v\u00eddeo para mostrar o funcionamento) Desenvolvedor e Scrum Master \u00b6 Rubricas Scrum e Desenvolvedor","title":"Projeto"},{"location":"E-Sequencial-Projeto/#e-logica-sequencia","text":"Neste projeto voc\u00ea ter\u00e1 que desenvolver os componentes de mem\u00f3ria que ser\u00e3o utilizados no computador Z01.","title":"E - L\u00f3gica Sequencia"},{"location":"E-Sequencial-Projeto/#instrucoes","text":"A pasta do projeto E-LogicaSequencial no reposit\u00f3rio Z01, possui a seguinte estrutura: /E-LogicaSequencial testeLogicaSequencial.py /Quartus /src /rtl *.vhd /tests /tst *.vhd Quartus: Projeto Quartus que faz uso dos arquivos VHDL localizados em src/rtl/*.vhd ; scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/rtl/*.vhd : Arquivos VHDL que ser\u00e3o implementados pelo grupo; tests/tst/*.vhd : Arquivos VHDL que realizam o teste l\u00f3gico nos arquivos do rtl.","title":"Instru\u00e7\u00f5es"},{"location":"E-Sequencial-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta E-LogicaSequencial e execute o script python localizado nessa pasta: $ python testeLogicaSequencial.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.vhd e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Note Lembre que o arquivo tests/config.txt define quais testes ser\u00e3o executados.","title":"Executando o Script de Teste"},{"location":"E-Sequencial-Projeto/#projeto","text":"Deve-se gerar uma imagem com a forma de onda desses m\u00f3dulos. Deve-se gerar um RTL para cada m\u00f3dulo do projeto ( E-LogicaSequencial-Lab-1 ) Note que \u00e9 poss\u00edvel reaproveitar, via port map , os m\u00f3dulos dos projetos anteriores. Para isso basta declarar o componente e usar o m\u00f3dulo.","title":"Projeto"},{"location":"E-Sequencial-Projeto/#modulos","text":"Esses arquivos est\u00e3o localizados em E-LogicaSequencial/src/rtl/ e detalhados no Cap\u00edtulo 3 - The Elements of Computing Systems Flip Flop Arquivo : FlipFlopD.vhd Depend\u00eancia : \u00c9 \u00e9 um bloco elementar e sua implementa\u00e7\u00e3o \u00e9 criada no laborat\u00f3rio do projeto . Binary Digit Arquivo : BinaryDigit.vhd Depend\u00eancia : FlipFlopD e Mux2Way Descri\u00e7\u00e3o : \u00c9 um registrador feito para armazenar um \u00fanico bit de informa\u00e7\u00e3o (0 ou 1). A interface do m\u00f3dulo consiste em uma entrada (d) para o bit a ser armazenado, um sinal de load para indicar quando o bit de entrada deve ser armazenado um sinal de clock e a sa\u00edda output* que \u00e9 o bit armazenado: Register 8 Arquivo : Register8.vhd Depend\u00eancia : BinaryDigit Descri\u00e7\u00e3o : \u00c9 um registrador de 8 bits criado a partir do binaryDigit por\u00e9m agora para armazenar um vetor de entrada de 8 bits de tamanho. Register 16 Arquivo : Register16.vhd Depend\u00eancia : Register8 Descri\u00e7\u00e3o : \u00c9 um registrador de 16 bits criado a partir do Register8 por\u00e9m agora para armazenar um vetor de entrada de 16 bits de tamanho. Register 32 Arquivo : Register32.vhd Depend\u00eancia : Register16 Descri\u00e7\u00e3o : \u00c9 um registrador de 32 bits criado a partir do Register16 por\u00e9m agora para armazenar um vetor de entrada de 32 bits de tamanho. Register 64 Arquivo : Register64.vhd Depend\u00eancia : Register32 Descri\u00e7\u00e3o : \u00c9 um registrador de 64 bits criado a partir do Register32 por\u00e9m agora para armazenar um vetor de entrada de 64 bits de tamanho. Program Counter Arquivo : PC.vhd Depend\u00eancia : inc16 , mux16 , reg16 Descri\u00e7\u00e3o : O program counter ser\u00e1 o nosso endere\u00e7ador de mem\u00f3ria da CPU, ele ser\u00e1 respons\u00e1vel por apontar para a pr\u00f3xima instru\u00e7\u00e3o a ser executada. Como normalmente um c\u00f3digo segue um fluxo sequencial (uma linha na sequ\u00eancia da outra) o PC possui a habilidade de se auto incrementar a cada clock (apontando assim para a pr\u00f3xima instru\u00e7\u00e3o), mas ele tem que suportar condi\u00e7\u00f5es (if, while, ...) rompendo com esse fluxo cont\u00ednuo. Sua l\u00f3gica \u00e9 descrita no pseudo c\u00f3digo a seguir: If reset(t-1) then out(t)=0 else if load(t-1) then out(t)=in(t-1) else if inc(t-1) then out(t)=out(t-1)+1 else out(t)=out(t-1) Ram8 Arquivo : Ram8.vhd Depend\u00eancia : Register16 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : \u00c9 uma mem\u00f3ria de 8 endere\u00e7os com 16 bits de largura. O componente possui como entrada o vetor input de 16 bits, o endere\u00e7o a ser armazenado (address) o sinal load que indica quando \u00e9 para ser armazenado e o clock. Como sa\u00edda temos o valor lido no endere\u00e7o especificado quando load for igual a 0. Note que sinal LOAD tem como fun\u00e7\u00e3o similar o do READ/WRITE, quando zero, indica que queremos ler o valor armazenado, quando 1 indica que queremos escrever (write) nessa posi\u00e7\u00e3o. Ram64 Arquivo : Ram64.vhd Depend\u00eancia : Ram8 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 64 endere\u00e7os. Ram512 Arquivo : Ram512.vhd Depend\u00eancia : Ram64 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 512 endere\u00e7os. Ram4k Arquivo : Ram4k.vhd Depend\u00eancia : Ram512 , Mux8Way16 , Dmux8Way Descri\u00e7\u00e3o : Similar a RAM8 por\u00e9m com 4512 endere\u00e7os. Tip Todos esses m\u00f3dulos est\u00e3o bem documentados no livro The Elements of Computer System. Cap 3.","title":"M\u00f3dulos"},{"location":"E-Sequencial-Projeto/#forma-de-onda","text":"Para cada teste realizado, deve-se carregar a interface gr\u00e1fica do simulador e tirar um print da forma de onda do m\u00f3dulo com os testes aplicados a ele. Essa imagem deve ser salva na mesma pasta dos arquivos vhdl ( src/doc/*_wave.png ) e com o mesmo nome dos m\u00f3dulos (similar ao projeto passado). Warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es.","title":"Forma de onda"},{"location":"E-Sequencial-Projeto/#rtl","text":"Para cada m\u00f3dulo deve-se gerar o RTL e salvar uma imagem da implementa\u00e7\u00e3o na pasta src/doc/_rtl.png . !! warning N\u00e3o basta s\u00f3 gerar a imagem, voc\u00ea precisa analisar e entender. Isso ser\u00e1 cobrado nas avalia\u00e7\u00f5es.","title":"RTL"},{"location":"E-Sequencial-Projeto/#testando-em-hardware","text":"No hardware voc\u00ea dever\u00e1 desenvolver um cen\u00e1rio de teste para o Program Counter ou para para a RAM8 .","title":"Testando em Hardware"},{"location":"E-Sequencial-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"E-Sequencial-Projeto/#projeto_1","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o foi implementando ou n\u00e3o passa no testes. C - Todos os m\u00f3dulos sendo testados no Travis - O ramo master passa nos testes do travis - Todos os m\u00f3dulos passam nos testes - Possui a forma de onda e rtl de todos os m\u00f3dulos (.png) B - Usou sempre que poss\u00edvel outros m\u00f3dulos para criar um novo (hierarquia) - Exemplo: usou o inc16 , mux16 e reg16 para criar PC A - Gravou e testou a mem\u00f3ria RAM8 na FPGA. (gravou um v\u00eddeo para mostrar o funcionamento)","title":"Projeto"},{"location":"E-Sequencial-Projeto/#desenvolvedor-e-scrum-master","text":"Rubricas Scrum e Desenvolvedor","title":"Desenvolvedor e Scrum Master"},{"location":"F-Assembly-Dicas/","text":"F - Assembly - Dicas \u00b6 A seguir algumas dicas para atingir os conceitos B e A nessa entrega. Rubrica - B \u00b6 Fa\u00e7a um programa em python que gere automaticamente um c\u00f3digo em assembly de um texto. Existem v\u00e1rias alternativas: A entrada do programa \u00e9 um .png e a sa\u00edda \u00e9 um c\u00f3digo em nasm A entrada do programa \u00e9 uma tabela do excel e a sa\u00edda \u00e9 um c\u00f3digo em nasm Rubrica - A \u00b6 N\u00e3o precisa ser um jogo complexo, pode ser algo como um \"Genius\" com os LEDs e bot\u00f5es.","title":"Dicas"},{"location":"F-Assembly-Dicas/#f-assembly-dicas","text":"A seguir algumas dicas para atingir os conceitos B e A nessa entrega.","title":"F - Assembly - Dicas"},{"location":"F-Assembly-Dicas/#rubrica-b","text":"Fa\u00e7a um programa em python que gere automaticamente um c\u00f3digo em assembly de um texto. Existem v\u00e1rias alternativas: A entrada do programa \u00e9 um .png e a sa\u00edda \u00e9 um c\u00f3digo em nasm A entrada do programa \u00e9 uma tabela do excel e a sa\u00edda \u00e9 um c\u00f3digo em nasm","title":"Rubrica - B"},{"location":"F-Assembly-Dicas/#rubrica-a","text":"N\u00e3o precisa ser um jogo complexo, pode ser algo como um \"Genius\" com os LEDs e bot\u00f5es.","title":"Rubrica - A"},{"location":"F-Assembly-Lab-1/","text":"Ao final desse lab voc\u00ea deve ser capaz de: Usar o simulador gr\u00e1fico Fazer pequenas modifica\u00e7\u00f5es em um c\u00f3digo assembly Executar script de teste do projeto F - Assembly Antes de come\u00e7ar o Scrum deve atualizar o fork e todos devem atualizar o Z01-tools. Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Atualizem o Z01-Tools! submodule antes de come\u00e7ar (TODOS DEVEM FAZER) (realizar em dupla/ individual) Simulador \u00b6 Nosso c\u00f3digo assembly pode ser executado em hardware de verdade (FPGA) por\u00e9m nesse primeiro momento iremos trabalhar em um ambiente simulado que nos dar\u00e1 maior facilidade de programa\u00e7\u00e3o e depura\u00e7\u00e3o. Um pouco de contexto: O livro texto (The Elements Of Computer System) disponibiliza um simulador da CPU original todo escrito em java, esse c\u00f3digo \u00e9 fechado e n\u00e3o permite nenhuma customiza\u00e7\u00e3o. Em 2017 o Prof. Luciano Pereiro iniciou a cria\u00e7\u00e3o de um simulador Z0 (vers\u00e3o anterior) tamb\u00e9m em Java, onde ter\u00edamos controle total do software, o simulador funcionava. Percebemos alguns pontos negativos de utilizar um simulador em Java (ou qualquer outra linguagem) sendo o principal: Qualquer altera\u00e7\u00e3o no Hardware iria demandar uma altera\u00e7\u00e3o no simulador, sendo necess\u00e1rio mantermos dois projetos independentes e sincronizados. Nesse curso, iremos utilizar um simulador que utiliza o nosso pr\u00f3prio c\u00f3digo VHDL como descri\u00e7\u00e3o da CPU (e de tudo envolvido), uma altera\u00e7\u00e3o no hardware (VHDL) ir\u00e1 automaticamente alterar o simulador e o comportamento do computador. Para isso, fazemos uso do ModelSim, um software da Mentor Graphics que executa simula\u00e7\u00f2es em VHDL (o mesmo utilizado nos projetos anterios), desenvolvemos uma s\u00e9rie de APIs e configura\u00e7\u00f5es desse simulador para funcionar para a disciplina. As APIS de interface do simulador foram desenvolvidas por mim (vhdl/ tcl/ python) e a interface gr\u00e1fica pelo Prof. Eduardo Marossi (python/ qt5). O simulador possui a estrutura ilustrada a seguir: O simulador possui como entradas (para cada simula\u00e7\u00e3o): a arquitetura do computador (hardware); o conte\u00fado da mem\u00f3ria RAMl o conte\u00fado da mem\u00f3ria ROM e um tempo de execu\u00e7\u00e3o. Ap\u00f3s o t\u00e9rmino da simula\u00e7\u00e3o \u00e9 exportado diversos sinais internos da CPU, o estado final da mem\u00f3ria RAM e ROM. Esses sinais s\u00e3o ent\u00e3o lidos pela interface gr\u00e1fica e exibida de uma forma amig\u00e1vel. Arquivos \u00b6 O simulador est\u00e1 localizado nas pastas Z01-tools/ : Z01-Simulator-GUI : Parte gr\u00e1fica do simulador Z01-Simulator-RTL : Hardware a ser executado no modelsim para executar o programa. Para inicializar o simulador basta executar o script localizado na pasta do projeto F: ./F-Assembly/Z01simulador.py Interface do Simulador \u00b6 O simulador possui a interface a seguir, onde a coluna da esquerda \u00e9 referente a mem\u00f3ria ROM (programa), a coluna da direita referente a mem\u00f3ria RAM (dados). Toda vez que houver uma altera\u00e7\u00e3o em algum dos par\u00e2metros do simulador (RAM/ROM/Instru\u00e7\u00f5es,...) o programa ser\u00e1 novamente executado no simulador para obtermos um resultado atualizado. Isso pode dar a sensa\u00e7\u00e3o de \"lerdeza\" mas lembre da complexidade do sistema: estamos executando um programa em um hardware inteiramente simulado no computador de voc\u00eas. Programando \u00b6 Abra o simulador e insira o seguinte c\u00f3digo nasm (na parte referente a ROM), uma instru\u00e7\u00e3o por linha: leaw $ R1 , % A movw ( % A ), % D leaw $ R0 , % A addw ( % A ), % D , % S leaw $ R2 , % A movw % S , ( % A ) Esse c\u00f3digo soma o valor que est\u00e1 salvo na mem\u00f3ria RAM endere\u00e7o 0 com o valor da mem\u00f3ria RAM endere\u00e7o 1 e salva no endere\u00e7o 0: RAM[2] = RAM[0] + RAM[1] R0, R1, ... ? \u00b6 R0**, ** R0**, ** R1 , ... s\u00e3o nomes pr\u00e9 definidos de endere\u00e7os de mem\u00f3ria. O R0 indica o endere\u00e7o de mem\u00f3ria 0, R1 o endere\u00e7o de mem\u00f3ria 1 e assim por diante at\u00e9 o R15 . O mesmo c\u00f3digo pode ser escrito como: leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % S leaw $ 2 , % A movw % S , ( % A ) - N\u00e3o continue caso n\u00e3o entendeu o c\u00f3digo ! Agora ser\u00e1 necess\u00e1rio colocarmos valores iniciais na mem\u00f3ria RAM para validarmos o nosso c\u00f3digo, para isso altere a mem\u00f3ria RAM como demonstrado a seguir: Endere\u00e7o 0 = 5 Endere\u00e7o 1 = 8 + Com a mem\u00f3ria alterada voc\u00ea pode agora executar a simula\u00e7\u00e3o, + verifique se o valor da mem\u00f3ria 2 \u00e9 a soma dos endere\u00e7os 0 e 1. Treinando \u00b6 USE O RESUMO DAS INSTRU\u00c7\u00d5ES: AssemblyZ1 - Altere o c\u00f3digo para armazenar o resultado no endere\u00e7o RAM[5] - Altere o c\u00f3digo para n\u00e3o usar o registrador %S Script autom\u00e1tico de testes \u00b6 Al\u00e9m da interface gr\u00e1fica do simulador, possu\u00edmos um script de teste automatizado (similar ao do VHDL), esse script: F-Assembly/testeAssembly.py compila os c\u00f3digos que est\u00e3o na pasta F-Assembly/src/nasm para a pasta F-Assembly/bin/hack e executa os testes localizados em F-Assembly/tst/ . Somente os arquivos configurados no config.txt ser\u00e3o testados. config.txt \u00b6 O arquivo de configura\u00e7\u00e3o dos testes \u00e9 um pouco diferente, possui al\u00e9m do nome do m\u00f3dulo que ser\u00e1 testado um segundo par\u00e2metro que indica quantos testes ser\u00e3o executados para esse m\u00f3dulo e quantos microsegundos ele ficar\u00e1 na simula\u00e7\u00e3o (microsegundos suposto de um sistema real). Exemplo do config.txt # nome | quantidade de testes | us de execucao #add 1 1000 + Remova o coment\u00e1rio do m\u00f3dulo add Implementando o add.nasm \u00b6 Os arquivos a serem implementando est\u00e3o na pasta F-Assembly/src/nasm/ l\u00e1 voc\u00ea vai encontrar todos os c\u00f3digos fontes que dever\u00e3o ser feitos nesse projeto. + Edite o arquivo add.nasm com a implementa\u00e7\u00e3o do add anterior Agora com o m\u00f3dulo implementando podemos testar seu funcionamento. Para isso execute o script testeAssembly.py . Esse script ir\u00e1 compilar o nasm e gerar os arquivos .hack e .mif (salvos no /bin/hack/ ) que ser\u00e3o carregados no simulador junto com uma configura\u00e7\u00e3o inicial da mem\u00f3ria RAM (como no gui do simulador), ao t\u00e9rmino da simula\u00e7\u00e3o um arquivo com o estado final da RAM \u00e9 salvo na pasta /tests/tst/add/add0_end.mif . Executamos um script que compara o estado final da RAM com o um esperado ( add0_tst.mif ), em caso de algum erro, o scripr ir\u00e1 reportar falha. Se tudo ocorrer bem voc\u00ea dever\u00e1 ter a seguinte sa\u00edda : - Testando .... ------------------------- Starting add0 .... pass add0 ==== Summary =================================== + pass add teste: 0 Formato de arquivos \u00b6 A seguir uma lista dos principais formatos de arquivos utilizados : .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU","title":"11: F Assembly Lab 1"},{"location":"F-Assembly-Lab-1/#simulador","text":"Nosso c\u00f3digo assembly pode ser executado em hardware de verdade (FPGA) por\u00e9m nesse primeiro momento iremos trabalhar em um ambiente simulado que nos dar\u00e1 maior facilidade de programa\u00e7\u00e3o e depura\u00e7\u00e3o. Um pouco de contexto: O livro texto (The Elements Of Computer System) disponibiliza um simulador da CPU original todo escrito em java, esse c\u00f3digo \u00e9 fechado e n\u00e3o permite nenhuma customiza\u00e7\u00e3o. Em 2017 o Prof. Luciano Pereiro iniciou a cria\u00e7\u00e3o de um simulador Z0 (vers\u00e3o anterior) tamb\u00e9m em Java, onde ter\u00edamos controle total do software, o simulador funcionava. Percebemos alguns pontos negativos de utilizar um simulador em Java (ou qualquer outra linguagem) sendo o principal: Qualquer altera\u00e7\u00e3o no Hardware iria demandar uma altera\u00e7\u00e3o no simulador, sendo necess\u00e1rio mantermos dois projetos independentes e sincronizados. Nesse curso, iremos utilizar um simulador que utiliza o nosso pr\u00f3prio c\u00f3digo VHDL como descri\u00e7\u00e3o da CPU (e de tudo envolvido), uma altera\u00e7\u00e3o no hardware (VHDL) ir\u00e1 automaticamente alterar o simulador e o comportamento do computador. Para isso, fazemos uso do ModelSim, um software da Mentor Graphics que executa simula\u00e7\u00f2es em VHDL (o mesmo utilizado nos projetos anterios), desenvolvemos uma s\u00e9rie de APIs e configura\u00e7\u00f5es desse simulador para funcionar para a disciplina. As APIS de interface do simulador foram desenvolvidas por mim (vhdl/ tcl/ python) e a interface gr\u00e1fica pelo Prof. Eduardo Marossi (python/ qt5). O simulador possui a estrutura ilustrada a seguir: O simulador possui como entradas (para cada simula\u00e7\u00e3o): a arquitetura do computador (hardware); o conte\u00fado da mem\u00f3ria RAMl o conte\u00fado da mem\u00f3ria ROM e um tempo de execu\u00e7\u00e3o. Ap\u00f3s o t\u00e9rmino da simula\u00e7\u00e3o \u00e9 exportado diversos sinais internos da CPU, o estado final da mem\u00f3ria RAM e ROM. Esses sinais s\u00e3o ent\u00e3o lidos pela interface gr\u00e1fica e exibida de uma forma amig\u00e1vel.","title":"Simulador"},{"location":"F-Assembly-Lab-1/#arquivos","text":"O simulador est\u00e1 localizado nas pastas Z01-tools/ : Z01-Simulator-GUI : Parte gr\u00e1fica do simulador Z01-Simulator-RTL : Hardware a ser executado no modelsim para executar o programa. Para inicializar o simulador basta executar o script localizado na pasta do projeto F: ./F-Assembly/Z01simulador.py","title":"Arquivos"},{"location":"F-Assembly-Lab-1/#interface-do-simulador","text":"O simulador possui a interface a seguir, onde a coluna da esquerda \u00e9 referente a mem\u00f3ria ROM (programa), a coluna da direita referente a mem\u00f3ria RAM (dados). Toda vez que houver uma altera\u00e7\u00e3o em algum dos par\u00e2metros do simulador (RAM/ROM/Instru\u00e7\u00f5es,...) o programa ser\u00e1 novamente executado no simulador para obtermos um resultado atualizado. Isso pode dar a sensa\u00e7\u00e3o de \"lerdeza\" mas lembre da complexidade do sistema: estamos executando um programa em um hardware inteiramente simulado no computador de voc\u00eas.","title":"Interface do Simulador"},{"location":"F-Assembly-Lab-1/#programando","text":"Abra o simulador e insira o seguinte c\u00f3digo nasm (na parte referente a ROM), uma instru\u00e7\u00e3o por linha: leaw $ R1 , % A movw ( % A ), % D leaw $ R0 , % A addw ( % A ), % D , % S leaw $ R2 , % A movw % S , ( % A ) Esse c\u00f3digo soma o valor que est\u00e1 salvo na mem\u00f3ria RAM endere\u00e7o 0 com o valor da mem\u00f3ria RAM endere\u00e7o 1 e salva no endere\u00e7o 0: RAM[2] = RAM[0] + RAM[1]","title":"Programando"},{"location":"F-Assembly-Lab-1/#r0-r1","text":"R0**, ** R0**, ** R1 , ... s\u00e3o nomes pr\u00e9 definidos de endere\u00e7os de mem\u00f3ria. O R0 indica o endere\u00e7o de mem\u00f3ria 0, R1 o endere\u00e7o de mem\u00f3ria 1 e assim por diante at\u00e9 o R15 . O mesmo c\u00f3digo pode ser escrito como: leaw $ 1 , % A movw ( % A ), % D leaw $ 0 , % A addw ( % A ), % D , % S leaw $ 2 , % A movw % S , ( % A ) - N\u00e3o continue caso n\u00e3o entendeu o c\u00f3digo ! Agora ser\u00e1 necess\u00e1rio colocarmos valores iniciais na mem\u00f3ria RAM para validarmos o nosso c\u00f3digo, para isso altere a mem\u00f3ria RAM como demonstrado a seguir: Endere\u00e7o 0 = 5 Endere\u00e7o 1 = 8 + Com a mem\u00f3ria alterada voc\u00ea pode agora executar a simula\u00e7\u00e3o, + verifique se o valor da mem\u00f3ria 2 \u00e9 a soma dos endere\u00e7os 0 e 1.","title":"R0, R1, ... ?"},{"location":"F-Assembly-Lab-1/#treinando","text":"USE O RESUMO DAS INSTRU\u00c7\u00d5ES: AssemblyZ1 - Altere o c\u00f3digo para armazenar o resultado no endere\u00e7o RAM[5] - Altere o c\u00f3digo para n\u00e3o usar o registrador %S","title":"Treinando"},{"location":"F-Assembly-Lab-1/#script-automatico-de-testes","text":"Al\u00e9m da interface gr\u00e1fica do simulador, possu\u00edmos um script de teste automatizado (similar ao do VHDL), esse script: F-Assembly/testeAssembly.py compila os c\u00f3digos que est\u00e3o na pasta F-Assembly/src/nasm para a pasta F-Assembly/bin/hack e executa os testes localizados em F-Assembly/tst/ . Somente os arquivos configurados no config.txt ser\u00e3o testados.","title":"Script autom\u00e1tico de testes"},{"location":"F-Assembly-Lab-1/#configtxt","text":"O arquivo de configura\u00e7\u00e3o dos testes \u00e9 um pouco diferente, possui al\u00e9m do nome do m\u00f3dulo que ser\u00e1 testado um segundo par\u00e2metro que indica quantos testes ser\u00e3o executados para esse m\u00f3dulo e quantos microsegundos ele ficar\u00e1 na simula\u00e7\u00e3o (microsegundos suposto de um sistema real). Exemplo do config.txt # nome | quantidade de testes | us de execucao #add 1 1000 + Remova o coment\u00e1rio do m\u00f3dulo add","title":"config.txt"},{"location":"F-Assembly-Lab-1/#implementando-o-addnasm","text":"Os arquivos a serem implementando est\u00e3o na pasta F-Assembly/src/nasm/ l\u00e1 voc\u00ea vai encontrar todos os c\u00f3digos fontes que dever\u00e3o ser feitos nesse projeto. + Edite o arquivo add.nasm com a implementa\u00e7\u00e3o do add anterior Agora com o m\u00f3dulo implementando podemos testar seu funcionamento. Para isso execute o script testeAssembly.py . Esse script ir\u00e1 compilar o nasm e gerar os arquivos .hack e .mif (salvos no /bin/hack/ ) que ser\u00e3o carregados no simulador junto com uma configura\u00e7\u00e3o inicial da mem\u00f3ria RAM (como no gui do simulador), ao t\u00e9rmino da simula\u00e7\u00e3o um arquivo com o estado final da RAM \u00e9 salvo na pasta /tests/tst/add/add0_end.mif . Executamos um script que compara o estado final da RAM com o um esperado ( add0_tst.mif ), em caso de algum erro, o scripr ir\u00e1 reportar falha. Se tudo ocorrer bem voc\u00ea dever\u00e1 ter a seguinte sa\u00edda : - Testando .... ------------------------- Starting add0 .... pass add0 ==== Summary =================================== + pass add teste: 0","title":"Implementando o add.nasm"},{"location":"F-Assembly-Lab-1/#formato-de-arquivos","text":"A seguir uma lista dos principais formatos de arquivos utilizados : .nasm : Arquivo assembly .hack : Linguagem de m\u00e1quina (arquivo com zeros e uns) .mif : Arquivo .hack que pode ser salvo na mem\u00f3ria da FPGA .lst : sa\u00edda do simulador com os estados da CPU","title":"Formato de arquivos"},{"location":"F-Assembly-Lab-2/","text":"Ao final desse lab voc\u00ea deve ser capaz de: Conectar o LCD na FPGA Programar a FPGA com o Z01.1 Programar um programa em nasm no Z01.1 Conectando o LCD \u00b6 Programando a FPGA \u00b6 A FPGA \u00e9 um hardware que pode sr configur\u00e1vel para implementar 'qualquer' sistema digital, incluindo um computador. Iremos primeiramente prograr a FPGA com o Hardware do Z01 para ent\u00e3o podermos programar o nosso c\u00f3digo em assembly. Para isso, execute o script python: $ ./programFPGA.pt Esse script ir\u00e1 carregar na FPGA o hardware do Z01.1 - Nossa FPGA \u00e9 dita do tipo vol\u00e1til - ela perde a configura\u00e7\u00e3o sempre que for - desligada! - Essa etapa deve ser refeita sempre - que plugar a placa no PC. Programando o Z01.1 \u00b6 Agora com o Z01.1 configurado na FPGA podemos executar nosso programa no hardware, basta chamar o script programSoftware.py com o par\u00e2metro -n e o caminho para o c\u00f3digo nasm . Como no exemplo a seguir: ./programSoftware -b src/nasm/examples/R-LCD.nasm O mesmo deve executar um c\u00f3digo no Z01 que escreve a letra R no LCD. Programe os exemplos a seguir: pxLCD.nasm : Escreve apenas 16 pixels no LCD (um ponto) testeLED.nasm : Um programa que exibe um contador bin\u00e1rio nos LEDs da FPGA testeSW.nasm : Um programa que l\u00ea as chaves da FPGA e aciona os LEDs com base no seus resultados. Treinando \u00b6 Grave na FPGA o programa testeSW.nasm Mexa nas chaves SW e veja o que acontece com os LEDS. Altere o programa para ser o inverso do que foi programado. Quando as chaves estiverem para baixo, o respectivo LED acende e quando a chave estiver para cima o LED apaga. - Valide na FPGA! Chame um professor - para mostrar.","title":"12: F Assembly Lab 2"},{"location":"F-Assembly-Lab-2/#conectando-o-lcd","text":"","title":"Conectando o LCD"},{"location":"F-Assembly-Lab-2/#programando-a-fpga","text":"A FPGA \u00e9 um hardware que pode sr configur\u00e1vel para implementar 'qualquer' sistema digital, incluindo um computador. Iremos primeiramente prograr a FPGA com o Hardware do Z01 para ent\u00e3o podermos programar o nosso c\u00f3digo em assembly. Para isso, execute o script python: $ ./programFPGA.pt Esse script ir\u00e1 carregar na FPGA o hardware do Z01.1 - Nossa FPGA \u00e9 dita do tipo vol\u00e1til - ela perde a configura\u00e7\u00e3o sempre que for - desligada! - Essa etapa deve ser refeita sempre - que plugar a placa no PC.","title":"Programando a FPGA"},{"location":"F-Assembly-Lab-2/#programando-o-z011","text":"Agora com o Z01.1 configurado na FPGA podemos executar nosso programa no hardware, basta chamar o script programSoftware.py com o par\u00e2metro -n e o caminho para o c\u00f3digo nasm . Como no exemplo a seguir: ./programSoftware -b src/nasm/examples/R-LCD.nasm O mesmo deve executar um c\u00f3digo no Z01 que escreve a letra R no LCD. Programe os exemplos a seguir: pxLCD.nasm : Escreve apenas 16 pixels no LCD (um ponto) testeLED.nasm : Um programa que exibe um contador bin\u00e1rio nos LEDs da FPGA testeSW.nasm : Um programa que l\u00ea as chaves da FPGA e aciona os LEDs com base no seus resultados.","title":"Programando o Z01.1"},{"location":"F-Assembly-Lab-2/#treinando","text":"Grave na FPGA o programa testeSW.nasm Mexa nas chaves SW e veja o que acontece com os LEDS. Altere o programa para ser o inverso do que foi programado. Quando as chaves estiverem para baixo, o respectivo LED acende e quando a chave estiver para cima o LED apaga. - Valide na FPGA! Chame um professor - para mostrar.","title":"Treinando"},{"location":"F-Assembly-Lab-3/","text":"Ao final desse lab voc\u00ea deve ser capaz de: Fazer programas simples em assembly com saltos Entender ainda mais a linguagem Entender ainda mias o hardawre Para todos os programas: Trabalhe com o grupo! Fa\u00e7a primeiramente na LOUSA, chame seu professor para validar Alterne quem vai para a lousa Fa\u00e7a no simulador GUI Lembre de iniciar a mem\u00f3ria RAM para validar o teste! Descomente no arquivo test/conf.txt Sempre use a descri\u00e7\u00e3o do hardware. Pequenos problemas (que j\u00e1 contam na entrega) \u00b6 Com auxilio do exemplo do add e das instru\u00e7\u00f5es dispon\u00edveis no nosso hardware ( AssemblyZ1 ) fa\u00e7a na LOUSA e depois no Simulador GUI um programa que: sub \u00b6 Arquivo: sub.nasm Faz uma subtra\u00e7\u00e3o binaria do valor de: RAM[1] - RAM[0] gravando em RAM[2]. - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt) mov \u00b6 Arquivo: mov.nasm Movimenta\u00e7\u00e3o de dados da memoria RAM. tmp = RAM[0] RAM[0] = RAM[1] RAM[1] = tmp RAM[3] = 1 - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt) SW e LED \u00b6 Arquivo: SWeLED.nasm Fa\u00e7a os LEDs exibirem o resultado da soma entre as chaves da FPGA: LEDR = SW[9..6] + SW[3..0]. - Valide no hardawre - Fa\u00e7a um v\u00eddeo!","title":"13: F Assembly Lab 3"},{"location":"F-Assembly-Lab-3/#pequenos-problemas-que-ja-contam-na-entrega","text":"Com auxilio do exemplo do add e das instru\u00e7\u00f5es dispon\u00edveis no nosso hardware ( AssemblyZ1 ) fa\u00e7a na LOUSA e depois no Simulador GUI um programa que:","title":"Pequenos problemas (que j\u00e1 contam na entrega)"},{"location":"F-Assembly-Lab-3/#sub","text":"Arquivo: sub.nasm Faz uma subtra\u00e7\u00e3o binaria do valor de: RAM[1] - RAM[0] gravando em RAM[2]. - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt)","title":"sub"},{"location":"F-Assembly-Lab-3/#mov","text":"Arquivo: mov.nasm Movimenta\u00e7\u00e3o de dados da memoria RAM. tmp = RAM[0] RAM[0] = RAM[1] RAM[1] = tmp RAM[3] = 1 - FA\u00c7A NA LOUSA PRIMEIRO! CHAME UM PROF. PARA VALIDAR - SIMULE NO GUI - RODE O TESTE (descomente tests/conf.txt)","title":"mov"},{"location":"F-Assembly-Lab-3/#sw-e-led","text":"Arquivo: SWeLED.nasm Fa\u00e7a os LEDs exibirem o resultado da soma entre as chaves da FPGA: LEDR = SW[9..6] + SW[3..0]. - Valide no hardawre - Fa\u00e7a um v\u00eddeo!","title":"SW e LED"},{"location":"F-Assembly-Projeto/","text":"F - Assembly \u00b6 Nesse projeto cada grupo ter\u00e1 que implementar diversos c\u00f3digos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos. Instru\u00e7\u00f5es \u00b6 Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto. Entendendo a Organiza\u00e7\u00e3o do Projeto \u00b6 A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: F-Assembly/ testeAssembly.py Z01simulator.py /Quartus /src /nasm *.nasm /tests /tst /abs /add .... Quartus : Projeto Quartus para gravar o computador na FPGA *.py : Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/nasm/*.nasm : Arquivos ASSEMBLY que ser\u00e3o implementados pelo grupo; tests/tst/* : Arquivos que realizam o teste nos arquivos c\u00f3digos do rtl. Executando o Script de Teste \u00b6 Abra o terminal na pasta F-Assembly/ e execute o script python localizado nessa pasta: $ ./testeAssembly.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.nasm e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail . Tip Lembrando que o arquivo tests/config.txt define quais testes ser\u00e3o executados. Projeto \u00b6 Deve-se implementar diversos programas na linguagem de m\u00e1quina do Z01 que ir\u00e3o manipular a mem\u00f3ria RAM a fim de implementar o que \u00e9 pedido. A descri\u00e7\u00e3o a seguir est\u00e1 classificada em ordem de dificuldade, come\u00e7ando pelos mais simples. M\u00f3dulos \u00b6 Esses arquivos est\u00e3o localizados em F-Assembly/src/nasm/ A descri\u00e7\u00e3o de cada m\u00f3dulo est\u00e1 localizada no cabe\u00e7alho do arquivo. mov Arquivo : mov.nasm add Arquivo : add.nasm sub Arquivo : sub.nasm abs Arquivo : abs.nasm pow Arquivo : pow.nasm fatorial Arquivo : fatorial.nasm mod Arquivo : mod.nasm Chaves e Leds Arquivo : SWeLED.nasm Linha Arquivo : line.nasm Quadrado Arquivo : quadrado.nasm Letra Grupo Arquivo : LCDletraGrupo.nasm Conceito B \u00b6 String length Arquivo : stringLength.nasm \u00c9 par Arquivo : isEven.nasm Palindromo Arquivo : palindromo.nasm Nome grupo Arquivo : LCDnomeGrupo.nasm Conceito A \u00b6 Nome grupo Arquivo : jogo.nasm Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Configurou o travis para operar com o novo projeto. - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Programa que desenha a letra do grupo no LCD B - Escreve o nome do grupo no LCD (grava v\u00eddeo) - Implementa os m\u00f3dulos extras ( stringLength.nasm , ... ) A - Faz algum jogo com o Z01.1 ( jogo.nasm ) (grava v\u00eddeo) Dicas rubrica A/B Veja a dicas para as rubricas A e B","title":"Projeto"},{"location":"F-Assembly-Projeto/#f-assembly","text":"Nesse projeto cada grupo ter\u00e1 que implementar diversos c\u00f3digos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos.","title":"F - Assembly"},{"location":"F-Assembly-Projeto/#instrucoes","text":"Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto.","title":"Instru\u00e7\u00f5es"},{"location":"F-Assembly-Projeto/#entendendo-a-organizacao-do-projeto","text":"A pasta do projeto D, no reposit\u00f3rio Z01, possui a seguinte estrutura: F-Assembly/ testeAssembly.py Z01simulator.py /Quartus /src /nasm *.nasm /tests /tst /abs /add .... Quartus : Projeto Quartus para gravar o computador na FPGA *.py : Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; src/nasm/*.nasm : Arquivos ASSEMBLY que ser\u00e3o implementados pelo grupo; tests/tst/* : Arquivos que realizam o teste nos arquivos c\u00f3digos do rtl.","title":"Entendendo a Organiza\u00e7\u00e3o do Projeto"},{"location":"F-Assembly-Projeto/#executando-o-script-de-teste","text":"Abra o terminal na pasta F-Assembly/ e execute o script python localizado nessa pasta: $ ./testeAssembly.py O mesmo ir\u00e1 compilar os arquivos src/rtl/*.nasm e executar os testes unit\u00e1rios em cada um deles. Nesse momento do teste, como os m\u00f3dulos n\u00e3o est\u00e3o implementados, o resultado dever\u00e1 ser falho. Esse comando executa um teste unit\u00e1rio em cada um dos m\u00f3dulos, verificando se sua implementa\u00e7\u00e3o est\u00e1 correta. O resultado \u00e9 exibido na tela como : pass ou fail . Tip Lembrando que o arquivo tests/config.txt define quais testes ser\u00e3o executados.","title":"Executando o Script de Teste"},{"location":"F-Assembly-Projeto/#projeto","text":"Deve-se implementar diversos programas na linguagem de m\u00e1quina do Z01 que ir\u00e3o manipular a mem\u00f3ria RAM a fim de implementar o que \u00e9 pedido. A descri\u00e7\u00e3o a seguir est\u00e1 classificada em ordem de dificuldade, come\u00e7ando pelos mais simples.","title":"Projeto"},{"location":"F-Assembly-Projeto/#modulos","text":"Esses arquivos est\u00e3o localizados em F-Assembly/src/nasm/ A descri\u00e7\u00e3o de cada m\u00f3dulo est\u00e1 localizada no cabe\u00e7alho do arquivo. mov Arquivo : mov.nasm add Arquivo : add.nasm sub Arquivo : sub.nasm abs Arquivo : abs.nasm pow Arquivo : pow.nasm fatorial Arquivo : fatorial.nasm mod Arquivo : mod.nasm Chaves e Leds Arquivo : SWeLED.nasm Linha Arquivo : line.nasm Quadrado Arquivo : quadrado.nasm Letra Grupo Arquivo : LCDletraGrupo.nasm","title":"M\u00f3dulos"},{"location":"F-Assembly-Projeto/#conceito-b","text":"String length Arquivo : stringLength.nasm \u00c9 par Arquivo : isEven.nasm Palindromo Arquivo : palindromo.nasm Nome grupo Arquivo : LCDnomeGrupo.nasm","title":"Conceito B"},{"location":"F-Assembly-Projeto/#conceito-a","text":"Nome grupo Arquivo : jogo.nasm","title":"Conceito A"},{"location":"F-Assembly-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"F-Assembly-Projeto/#projeto_1","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Configurou o travis para operar com o novo projeto. - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Programa que desenha a letra do grupo no LCD B - Escreve o nome do grupo no LCD (grava v\u00eddeo) - Implementa os m\u00f3dulos extras ( stringLength.nasm , ... ) A - Faz algum jogo com o Z01.1 ( jogo.nasm ) (grava v\u00eddeo) Dicas rubrica A/B Veja a dicas para as rubricas A e B","title":"Projeto"},{"location":"G-CPU-Dicas-Conceito-B-e-A/","text":"Inserindo display HEX \u00b6 Para inserir o display sete segmentos (7s) ser\u00e1 necess\u00e1rio: Modificar o memoryIO Adicionar novas sa\u00eddas na entity Adicionar perif\u00e9rico que recebe vetor de bits e converte para sinais do 7s Decoder Modificar Computador.vhd Deve-se agora rotear os novos sinais do memoryIO para os pinos da FPGA, para isso modifique a entity do Computador.vhd para entity Computador is generic( IS_SIMULATION : std_logic := '0' ); port( -- Sistema CLOCK_50 : in std_logic; RESET_N : in std_logic; LEDR : out std_logic_vector(9 downto 0); SW : in std_logic_vector(9 downto 0); -- LCD EXTERNAL I/OS LCD_CS_N : out std_logic; LCD_D : inout std_logic_vector(15 downto 0); LCD_RD_N : out std_logic; LCD_RESET_N : out std_logic; LCD_RS : out std_logic; LCD_WR_N : out std_logic; LCD_ON : out std_logic; + --- Seven Seg + HEX0 : out std_logic_vector(6 downto 0); -- 7seg0 + HEX1 : out std_logic_vector(6 downto 0); -- 7seg1 + HEX2 : out std_logic_vector(6 downto 0); -- 7seg2 + HEX3 : out std_logic_vector(6 downto 0) -- 7seg3 ); end entity; Programando ROM com linguagem de m\u00e1quina \u00b6 Uma vez implementando as modifica\u00e7\u00f5es no HW n\u00e3o temos mais como realizar os testes l\u00f3gicos na CPU ( testeHW e testeAssemblyMyCPU ), j\u00e1 que o nosso Assembler n\u00e3o est\u00e1 adequado para essas modifica\u00e7\u00f5es. Uma alternativa para verificarmos se a altera\u00e7\u00e3o est\u00e1 certa \u00e9: 1. Compilar no Quartus o novo computador 1. Programar a FPGA com o novo HW ./programMyFPGA.py 1. Escreva um programa em linguagem de m\u00e1quina (adequado ao novo Instruction Set) que teste as novas funcionalidades. - Programa j\u00e1 em bin\u00e1rio, extens\u00e3o: .mif - Exemplo na pasta: Projeto/G-CPU/testeComputador.mif 1. Programar a mem\u00f3ria da ROM com arquivo .mif : ./programSoftware -m Arquivo.mif 1. Verificar a funcionalidade das modifica\u00e7\u00f5es. Arquivo .mif \u00b6 O .mif \u00e9 um formato de arquivo que possibilita carregarmos uma mem\u00f3ria na FPGA, ele possui a seguinte estrutura: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Voc\u00ea deve editar a linha DEPTH=5; para a quantidade de linhas que seu programa possui! Esse arquivo \u00e9 geralmente gerado pelo Assembler : assembler .nasm ---------> .mif v |---------> FPGA |---------> SIMULADOR Teclado como perif\u00e9rico \u00b6 Adicionar os seguintes sinais na entidade do Computador.vhd e do memoryIO.vhd PS2_CLK : in std_logic; PS2_DAT : in std_logic; E implementar a leitura das teclas no memoryIO . Dica: https://www.digikey.com/eewiki/pages/viewpage.action?pageId=28278929","title":"Dicas rubrica B"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#inserindo-display-hex","text":"Para inserir o display sete segmentos (7s) ser\u00e1 necess\u00e1rio: Modificar o memoryIO Adicionar novas sa\u00eddas na entity Adicionar perif\u00e9rico que recebe vetor de bits e converte para sinais do 7s Decoder Modificar Computador.vhd Deve-se agora rotear os novos sinais do memoryIO para os pinos da FPGA, para isso modifique a entity do Computador.vhd para entity Computador is generic( IS_SIMULATION : std_logic := '0' ); port( -- Sistema CLOCK_50 : in std_logic; RESET_N : in std_logic; LEDR : out std_logic_vector(9 downto 0); SW : in std_logic_vector(9 downto 0); -- LCD EXTERNAL I/OS LCD_CS_N : out std_logic; LCD_D : inout std_logic_vector(15 downto 0); LCD_RD_N : out std_logic; LCD_RESET_N : out std_logic; LCD_RS : out std_logic; LCD_WR_N : out std_logic; LCD_ON : out std_logic; + --- Seven Seg + HEX0 : out std_logic_vector(6 downto 0); -- 7seg0 + HEX1 : out std_logic_vector(6 downto 0); -- 7seg1 + HEX2 : out std_logic_vector(6 downto 0); -- 7seg2 + HEX3 : out std_logic_vector(6 downto 0) -- 7seg3 ); end entity;","title":"Inserindo display HEX"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#programando-rom-com-linguagem-de-maquina","text":"Uma vez implementando as modifica\u00e7\u00f5es no HW n\u00e3o temos mais como realizar os testes l\u00f3gicos na CPU ( testeHW e testeAssemblyMyCPU ), j\u00e1 que o nosso Assembler n\u00e3o est\u00e1 adequado para essas modifica\u00e7\u00f5es. Uma alternativa para verificarmos se a altera\u00e7\u00e3o est\u00e1 certa \u00e9: 1. Compilar no Quartus o novo computador 1. Programar a FPGA com o novo HW ./programMyFPGA.py 1. Escreva um programa em linguagem de m\u00e1quina (adequado ao novo Instruction Set) que teste as novas funcionalidades. - Programa j\u00e1 em bin\u00e1rio, extens\u00e3o: .mif - Exemplo na pasta: Projeto/G-CPU/testeComputador.mif 1. Programar a mem\u00f3ria da ROM com arquivo .mif : ./programSoftware -m Arquivo.mif 1. Verificar a funcionalidade das modifica\u00e7\u00f5es.","title":"Programando ROM com linguagem de m\u00e1quina"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#arquivo-mif","text":"O .mif \u00e9 um formato de arquivo que possibilita carregarmos uma mem\u00f3ria na FPGA, ele possui a seguinte estrutura: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; Voc\u00ea deve editar a linha DEPTH=5; para a quantidade de linhas que seu programa possui! Esse arquivo \u00e9 geralmente gerado pelo Assembler : assembler .nasm ---------> .mif v |---------> FPGA |---------> SIMULADOR","title":"Arquivo .mif"},{"location":"G-CPU-Dicas-Conceito-B-e-A/#teclado-como-periferico","text":"Adicionar os seguintes sinais na entidade do Computador.vhd e do memoryIO.vhd PS2_CLK : in std_logic; PS2_DAT : in std_logic; E implementar a leitura das teclas no memoryIO . Dica: https://www.digikey.com/eewiki/pages/viewpage.action?pageId=28278929","title":"Teclado como perif\u00e9rico"},{"location":"G-CPU-Projeto/","text":"G - CPU \u00b6 Nesse projeto cada grupo ter\u00e1 que implementar diversos codigos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos. Instru\u00e7\u00f5es \u00b6 Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto. Entendendo a Organiza\u00e7\u00e3o do Projeto \u00b6 A pasta do projeto G no reposit\u00f3rio Z01, possui a seguinte estrutura: G-Computador/ testeHW.py testeAssemblyMyCPU.py Z01SimuladorMyCPU.py generateMySOF.py programMySOF.py programNASM.py Quartus/ ... Z01-Simulator-RTL/ ... testeHW.py : Testa o controlUnit.vhd e memoryIO.vhd testeAssemblyMyCPU.py : Testa todo o HW do computador ( CPU.vhd ) Z01SimuladorMyCPU.py : Abre o simulador gr\u00e1fico do Z01.1 com o HW do grupo programMySOF.py : Programa a FPGA com o HW do grupo programNASM.PY : Programa a ROM do Z01.1 da FPGA com um nasm passado Z01-Simulator-RTL : Pasta com o simulador do computador (usa o hardware criado por voc\u00eas) Testando HW (ControlUnit e MemoryIO) \u00b6 Abra o terminal na pasta G-CPU e execute o script python localizado nessa pasta: $ ./testeHW.py Warning Esse script testa apenas uma pequena parte do Control Uniy e do MemoryIO! Passar nesse teste n\u00e3o indica 100% que o projeto est\u00e1 correto. \u00c9 poss\u00edvel testar apenas o controlUnit ou MemoryIO, execute o comando com: lib.tb_controlunit.all ou lib.tb_memoryio.all para testar apenas um m\u00f3dulo. $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all Testando o projeto completo \u00b6 Para testar se o computador est\u00e1 correto, iremos executar alguns programas realizados na etapa F-Assembly por\u00e9m agora no Harware que voc\u00eas montaram. Para isso execute. $ ./testeAssemblyMyCPU.py Esse script ir\u00e1 compilar todos os m\u00f3dulos (desde o projeto C) e executar o top level Computador.vhd , iremos comparar se a resposta (mem\u00f3ria RAM) possui o resultado esperado. Como os programas s\u00e3o complexos, esperamos com isso conseguir testar a totalidade do projeto. Travis \u00b6 Adicione ao Travis os dois testes, separando o memoryIO e o controlUnit: testeHW.py lib.tb_memoryio.all testeHW.py lib.tb_controlunit.all testeAssemblyMyCPU.py Projeto \u00b6 Deve-se implementar o Control Unit e integrar os m\u00f3dulos: MemoryIO e CPU . O HDL que descreve o Computador j\u00e1 foi fornecido pronto. M\u00f3dulos \u00b6 Note Esses arquivos est\u00e3o localizados em G-Computador/src/rtl/ Os m\u00f3dulos est\u00e3o listados de maneira Top - Down Computador (j\u00e1 est\u00e1 pronto!) Arquivo : computador.vhd Descri\u00e7\u00e3o : TopLevel do projeto, entidade que integra a mem\u00f3ria ROM o MemoryIO, CPU e PLL Depend\u00eancias : Dispositivos/ROM/ROM32K.vhd : ROM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/PLL/PLL.vhd : PLL a ser utilizada no projeto (j\u00e1 foi dado pronto) MemoryIO Arquivo : MemoryIO.vhd Descri\u00e7\u00e3o : Faz o mapa de mem\u00f3ria para a CPU. Depend\u00eancias : Dispositivos/RAM/RAM16K.vhd : RAM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/Screen/Screen.vhd : Controlador do LCD a ser utilizada no projeto (j\u00e1 foi dado pronto) CPU Arquivo : CPU.vhd Descri\u00e7\u00e3o : CPU do Z01 integra registradores, controlUnit, ULA e PC. Depend\u00eancias : ControlUnit.vhd : Unidade de controle a ser implementada ULA.vhd : Unidade l\u00f3gica desenvolvida no projeto D PC.vhd : Program counter do projeto E register16.vhd , mux16.vhd : Componentes do projeto C e D ControlUnit Arquivo : ControlUnit.vhd Descri\u00e7\u00e3o : Unidade de controle da CPU do Z01. Depend\u00eancias : n\u00e3o h\u00e1 Diagramas \u00b6 ControlUnit Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Construiu com os m\u00f3dulos do grupo o seu pr\u00f3prio computador - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Executa o escreve a letra do grupo no LCD usando o seu computador B - Adiciona um novo registrador a CPU - Adiciona os displays de Sete Segmentos aos perif\u00e9ricos do Computador (memoryIO) - Faz um c\u00f3digo e um v\u00eddeo que demonstra que ambos est\u00e3o funcionando A - Possibilita realizar carregamento efetivo em %D ( leaw $5, %D ) OU - Adiciona um teclado (externo) como um novo perif\u00e9rico - Faz um c\u00f3digo e um v\u00eddeo que demonstrando seu funcionamento Conceito A Para o conceito A \u00e9 necess\u00e1rio realizar apenas um item da lista.","title":"CPU Projeto"},{"location":"G-CPU-Projeto/#g-cpu","text":"Nesse projeto cada grupo ter\u00e1 que implementar diversos codigos em assembly a fim de entendermos a linguagem e as limita\u00e7\u00f5es do hardware propostos.","title":"G - CPU"},{"location":"G-CPU-Projeto/#instrucoes","text":"Seguir as intru\u00e7\u00f5es a seguir para desenvolvimento do projeto.","title":"Instru\u00e7\u00f5es"},{"location":"G-CPU-Projeto/#entendendo-a-organizacao-do-projeto","text":"A pasta do projeto G no reposit\u00f3rio Z01, possui a seguinte estrutura: G-Computador/ testeHW.py testeAssemblyMyCPU.py Z01SimuladorMyCPU.py generateMySOF.py programMySOF.py programNASM.py Quartus/ ... Z01-Simulator-RTL/ ... testeHW.py : Testa o controlUnit.vhd e memoryIO.vhd testeAssemblyMyCPU.py : Testa todo o HW do computador ( CPU.vhd ) Z01SimuladorMyCPU.py : Abre o simulador gr\u00e1fico do Z01.1 com o HW do grupo programMySOF.py : Programa a FPGA com o HW do grupo programNASM.PY : Programa a ROM do Z01.1 da FPGA com um nasm passado Z01-Simulator-RTL : Pasta com o simulador do computador (usa o hardware criado por voc\u00eas)","title":"Entendendo a Organiza\u00e7\u00e3o do Projeto"},{"location":"G-CPU-Projeto/#testando-hw-controlunit-e-memoryio","text":"Abra o terminal na pasta G-CPU e execute o script python localizado nessa pasta: $ ./testeHW.py Warning Esse script testa apenas uma pequena parte do Control Uniy e do MemoryIO! Passar nesse teste n\u00e3o indica 100% que o projeto est\u00e1 correto. \u00c9 poss\u00edvel testar apenas o controlUnit ou MemoryIO, execute o comando com: lib.tb_controlunit.all ou lib.tb_memoryio.all para testar apenas um m\u00f3dulo. $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all","title":"Testando HW (ControlUnit e MemoryIO)"},{"location":"G-CPU-Projeto/#testando-o-projeto-completo","text":"Para testar se o computador est\u00e1 correto, iremos executar alguns programas realizados na etapa F-Assembly por\u00e9m agora no Harware que voc\u00eas montaram. Para isso execute. $ ./testeAssemblyMyCPU.py Esse script ir\u00e1 compilar todos os m\u00f3dulos (desde o projeto C) e executar o top level Computador.vhd , iremos comparar se a resposta (mem\u00f3ria RAM) possui o resultado esperado. Como os programas s\u00e3o complexos, esperamos com isso conseguir testar a totalidade do projeto.","title":"Testando o projeto completo"},{"location":"G-CPU-Projeto/#travis","text":"Adicione ao Travis os dois testes, separando o memoryIO e o controlUnit: testeHW.py lib.tb_memoryio.all testeHW.py lib.tb_controlunit.all testeAssemblyMyCPU.py","title":"Travis"},{"location":"G-CPU-Projeto/#projeto","text":"Deve-se implementar o Control Unit e integrar os m\u00f3dulos: MemoryIO e CPU . O HDL que descreve o Computador j\u00e1 foi fornecido pronto.","title":"Projeto"},{"location":"G-CPU-Projeto/#modulos","text":"Note Esses arquivos est\u00e3o localizados em G-Computador/src/rtl/ Os m\u00f3dulos est\u00e3o listados de maneira Top - Down Computador (j\u00e1 est\u00e1 pronto!) Arquivo : computador.vhd Descri\u00e7\u00e3o : TopLevel do projeto, entidade que integra a mem\u00f3ria ROM o MemoryIO, CPU e PLL Depend\u00eancias : Dispositivos/ROM/ROM32K.vhd : ROM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/PLL/PLL.vhd : PLL a ser utilizada no projeto (j\u00e1 foi dado pronto) MemoryIO Arquivo : MemoryIO.vhd Descri\u00e7\u00e3o : Faz o mapa de mem\u00f3ria para a CPU. Depend\u00eancias : Dispositivos/RAM/RAM16K.vhd : RAM a ser utilizada no projeto (j\u00e1 foi dado pronto) Dispositivos/Screen/Screen.vhd : Controlador do LCD a ser utilizada no projeto (j\u00e1 foi dado pronto) CPU Arquivo : CPU.vhd Descri\u00e7\u00e3o : CPU do Z01 integra registradores, controlUnit, ULA e PC. Depend\u00eancias : ControlUnit.vhd : Unidade de controle a ser implementada ULA.vhd : Unidade l\u00f3gica desenvolvida no projeto D PC.vhd : Program counter do projeto E register16.vhd , mux16.vhd : Componentes do projeto C e D ControlUnit Arquivo : ControlUnit.vhd Descri\u00e7\u00e3o : Unidade de controle da CPU do Z01. Depend\u00eancias : n\u00e3o h\u00e1","title":"M\u00f3dulos"},{"location":"G-CPU-Projeto/#diagramas","text":"ControlUnit","title":"Diagramas"},{"location":"G-CPU-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"G-CPU-Projeto/#projeto_1","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Ao menos um m\u00f3dulo n\u00e3o est\u00e1 feito e n\u00e3o passa no testes. C - Construiu com os m\u00f3dulos do grupo o seu pr\u00f3prio computador - Todos os m\u00f3dulos sendo testados no Travis. - Todos os m\u00f3dulos passam nos testes. - Executa o escreve a letra do grupo no LCD usando o seu computador B - Adiciona um novo registrador a CPU - Adiciona os displays de Sete Segmentos aos perif\u00e9ricos do Computador (memoryIO) - Faz um c\u00f3digo e um v\u00eddeo que demonstra que ambos est\u00e3o funcionando A - Possibilita realizar carregamento efetivo em %D ( leaw $5, %D ) OU - Adiciona um teclado (externo) como um novo perif\u00e9rico - Faz um c\u00f3digo e um v\u00eddeo que demonstrando seu funcionamento Conceito A Para o conceito A \u00e9 necess\u00e1rio realizar apenas um item da lista.","title":"Projeto"},{"location":"G-CPU-Testando/","text":"G - CPU - Testando \u00b6 Para testar o projeto G-CPU \u00e9 necess\u00e1rio: Testar o controUnit e o memoryIo : $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all Somente ap\u00f3s passar os testes anteriores e com a CPU implementada: Testar o computador ( CPU , controlUnit e memoryIo ) com a execu\u00e7\u00e3o de c\u00f3digos em assembly: $ ./testeAssemblyMyCPU.py Tip SE O TESTE TRAVAR, VERIFICAR DICAS AO FINAL DESSA P\u00c1GINA Testar o Computador na FPGA Abrir Quartus e compilar projeto Executar programMyFPGA.py Executar o programa letra / nome : $ ./programSoftware.py -n ../F-Assembly/src/nasm/LCDnomeGrupo.nasm Rubrica B \u00b6 N\u00e3o vamos ter o teste do memoryIO nem do controlUnit adequados para as mudan\u00e7as, ser\u00e1 necess\u00e1rio testar direto no Hardware: Abrir Quartus e compilar projeto Executar programMyFPGA.py Como voc\u00eas alteraram o InstructionSet, ser\u00e1 necess\u00e1rio escrever um programa em linguagem de m\u00e1quina, para isso: Altere o arquivo: testeComputador.mif com suas opera\u00e7\u00f5es Execute ./programSoftware.py -m testeComputador.mif para programar a ROM do Z01.1 com seu programa. Note que o arquivo testeComputador.mif possui um campo que \u00e9 DEPTH=30; Voc\u00ea deve alterar esse valor para a quantidade de linhas que seu programa possui! Se o testeAssemblyMyCPU.py travar \u00b6 Se por algum motivo o teste testeAssemblyMyCPU.py travar no primeiro teste, isso \u00e9 sin\u00f4nimo de que algo est\u00e1 errado com o seu HDL. Esse teste faz o seguinte para cada arquivo .nasm incluso no arquivo de configura\u00e7\u00e3o do Projeto F : Compila o .nasm gerando o bin\u00e1rio .mif Carrega na ROM do seu computador ( Projeto G ) o bin\u00e1rio Executa o c\u00f3digo Verifica se o resultado est\u00e1 certo Se por algum motivo algum m\u00f3dulo estiver com problema esse teste pode falhar, o que \u00e9 aconselhado fazer: Comente todos os teste do Projeto F no arquivo de configura\u00e7\u00e3o ( F-Assembly/tests/config.txt ) com exce\u00e7\u00e3o o mov.nasm Esse m\u00f3dulo testa todos os registradores Execute o teste com a parte do waveform: ./testeAssemblyMyCPU.py -g An\u00e1lise o transcript em busca de erros! Inclua os sinais do Computador no waveform e execute o vunit_run Analise o que est\u00e1 acontecendo com o seu hardware, verifique a instru\u00e7\u00e3o que est\u00e1 entrando e o que deveria acontecer. Corrija o HW quando encontrar o problema, teste novamente. Descomente os m\u00f3dulos: abs.nasm e teste para saber se est\u00e1 :ok Esse m\u00f3dulo testa o loadPC e sa\u00eddas da ULA (ng e zr) Descomente os demais m\u00f3dulos e teste tudo.","title":"Dicas testando"},{"location":"G-CPU-Testando/#g-cpu-testando","text":"Para testar o projeto G-CPU \u00e9 necess\u00e1rio: Testar o controUnit e o memoryIo : $ ./testeHW.py lib.tb_memoryio.all $ ./testeHW.py lib.tb_controlunit.all Somente ap\u00f3s passar os testes anteriores e com a CPU implementada: Testar o computador ( CPU , controlUnit e memoryIo ) com a execu\u00e7\u00e3o de c\u00f3digos em assembly: $ ./testeAssemblyMyCPU.py Tip SE O TESTE TRAVAR, VERIFICAR DICAS AO FINAL DESSA P\u00c1GINA Testar o Computador na FPGA Abrir Quartus e compilar projeto Executar programMyFPGA.py Executar o programa letra / nome : $ ./programSoftware.py -n ../F-Assembly/src/nasm/LCDnomeGrupo.nasm","title":"G - CPU - Testando"},{"location":"G-CPU-Testando/#rubrica-b","text":"N\u00e3o vamos ter o teste do memoryIO nem do controlUnit adequados para as mudan\u00e7as, ser\u00e1 necess\u00e1rio testar direto no Hardware: Abrir Quartus e compilar projeto Executar programMyFPGA.py Como voc\u00eas alteraram o InstructionSet, ser\u00e1 necess\u00e1rio escrever um programa em linguagem de m\u00e1quina, para isso: Altere o arquivo: testeComputador.mif com suas opera\u00e7\u00f5es Execute ./programSoftware.py -m testeComputador.mif para programar a ROM do Z01.1 com seu programa. Note que o arquivo testeComputador.mif possui um campo que \u00e9 DEPTH=30; Voc\u00ea deve alterar esse valor para a quantidade de linhas que seu programa possui!","title":"Rubrica B"},{"location":"G-CPU-Testando/#se-o-testeassemblymycpupy-travar","text":"Se por algum motivo o teste testeAssemblyMyCPU.py travar no primeiro teste, isso \u00e9 sin\u00f4nimo de que algo est\u00e1 errado com o seu HDL. Esse teste faz o seguinte para cada arquivo .nasm incluso no arquivo de configura\u00e7\u00e3o do Projeto F : Compila o .nasm gerando o bin\u00e1rio .mif Carrega na ROM do seu computador ( Projeto G ) o bin\u00e1rio Executa o c\u00f3digo Verifica se o resultado est\u00e1 certo Se por algum motivo algum m\u00f3dulo estiver com problema esse teste pode falhar, o que \u00e9 aconselhado fazer: Comente todos os teste do Projeto F no arquivo de configura\u00e7\u00e3o ( F-Assembly/tests/config.txt ) com exce\u00e7\u00e3o o mov.nasm Esse m\u00f3dulo testa todos os registradores Execute o teste com a parte do waveform: ./testeAssemblyMyCPU.py -g An\u00e1lise o transcript em busca de erros! Inclua os sinais do Computador no waveform e execute o vunit_run Analise o que est\u00e1 acontecendo com o seu hardware, verifique a instru\u00e7\u00e3o que est\u00e1 entrando e o que deveria acontecer. Corrija o HW quando encontrar o problema, teste novamente. Descomente os m\u00f3dulos: abs.nasm e teste para saber se est\u00e1 :ok Esse m\u00f3dulo testa o loadPC e sa\u00eddas da ULA (ng e zr) Descomente os demais m\u00f3dulos e teste tudo.","title":"Se o testeAssemblyMyCPU.py travar"},{"location":"H-Assembler-Dicas-Macro/","text":"H - Assembler - Dica Macro \u00b6 Suponha o seguinte arquivo .nasm : % macro name nPar ... .. % endmacro name : Nome do macro nPar : Quantidade de par\u00e2metros (0, 1, 2), acess\u00edvel via : par0, par1 O macro serve para facilitar o reaproveitamento de c\u00f3digos, diferente de uma fun\u00e7\u00e3o que altera o fluxo de execu\u00e7\u00e3o do c\u00f3digo para o endere\u00e7o que a fun\u00e7\u00e3o est\u00e1 salva, o macro funciona copiando o macro para a onde ele foi chamado, como no exemplo a seguir: C\u00f3digo sem macro : ; carrega 5 em D leaw $5 , %A movw %A , %D ; salva valor em RAM8 leaw $8 , %A movw %D , ( %A ) C\u00f3digo com 2 macros definidos : movCntToReg : Move uma constante (par0) para uma registrador (par1) movRegtoRAM : Move um registrador (par0) para o endere\u00e7o de mem\u00f3ria (par1). % macro movCntToReg 2 leaw par0 , %A movw %A , par1 % endmacro % macro movRegtoRAM 2 leaw par0 , %A movw par1 , ( %A ) % endmacro ; carrega 5 em D movCntToReg $D , % 5 ; chama macro para salvar em RAM 8 movRegtoRAM %D , $8","title":"Dicas Macro"},{"location":"H-Assembler-Dicas-Macro/#h-assembler-dica-macro","text":"Suponha o seguinte arquivo .nasm : % macro name nPar ... .. % endmacro name : Nome do macro nPar : Quantidade de par\u00e2metros (0, 1, 2), acess\u00edvel via : par0, par1 O macro serve para facilitar o reaproveitamento de c\u00f3digos, diferente de uma fun\u00e7\u00e3o que altera o fluxo de execu\u00e7\u00e3o do c\u00f3digo para o endere\u00e7o que a fun\u00e7\u00e3o est\u00e1 salva, o macro funciona copiando o macro para a onde ele foi chamado, como no exemplo a seguir: C\u00f3digo sem macro : ; carrega 5 em D leaw $5 , %A movw %A , %D ; salva valor em RAM8 leaw $8 , %A movw %D , ( %A ) C\u00f3digo com 2 macros definidos : movCntToReg : Move uma constante (par0) para uma registrador (par1) movRegtoRAM : Move um registrador (par0) para o endere\u00e7o de mem\u00f3ria (par1). % macro movCntToReg 2 leaw par0 , %A movw %A , par1 % endmacro % macro movRegtoRAM 2 leaw par0 , %A movw par1 , ( %A ) % endmacro ; carrega 5 em D movCntToReg $D , % 5 ; chama macro para salvar em RAM 8 movRegtoRAM %D , $8","title":"H - Assembler - Dica Macro"},{"location":"H-Assembler-Dicas-SymbolTable/","text":"Tabela de S\u00edmbolos \u00b6 O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo. S\u00edmbolos padr\u00f5es \u00b6 Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 Labels \u00b6 S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp Endere\u00e7os de mem\u00f3ria \u00b6 S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis noSTART_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label. Exemplo \u00b6 Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x, %A 1: movw $1, (%A) 2: LOOP: 3: leaw $UPDATE, %A 4: je %D 5: nop 6: leaw $temp, %A 7: movw (%A), %A 8: addw %A, %S, %S 9: decw %D 10: leaw $LOOP, %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3, %A 15: movw %S, (%A) 16: END: 17: leaw $END, %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deveria ser: S\u00edmbolos Valor R0 0 R1 1 ... ... R15 15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 ------------ -------- x 16 y 17 LOOP 2 UPDATE 12 END 14","title":"Dicas SymbolTable"},{"location":"H-Assembler-Dicas-SymbolTable/#tabela-de-simbolos","text":"O Z01 possui alguns s\u00edmbolos definidos para facilitar o desenvolvimento de um programa em assembly, por exemplo, n\u00e3o \u00e9 preciso saber de cor que o LCD come\u00e7a no endere\u00e7o 16384, basta usarmos o s\u00edmbolo SCREEN no c\u00f3digo que o mesmo ser\u00e1 substitu\u00eddo pelo valor 16384. Al\u00e9m de facilitar o desenvolvimento, possibilita uma maior portabilidade j\u00e1 que o compilador que \u00e9 encarregado de substituir o valor, se o endere\u00e7o uma maior portabilidade do c\u00f3digo.","title":"Tabela de S\u00edmbolos"},{"location":"H-Assembler-Dicas-SymbolTable/#simbolos-padroes","text":"Esse s\u00e3o os s\u00edmbolos que s\u00e3o definidos estaticamente, sempre devem existir. Eles indicam um endere\u00e7o da mem\u00f3ria RAM. Exemplo : leaw $LED , %A movd %D , ( %A ) Simb Endere\u00e7o R0-R15 0-15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185","title":"S\u00edmbolos padr\u00f5es"},{"location":"H-Assembler-Dicas-SymbolTable/#labels","text":"S\u00e3o os s\u00edmbolos que indicam um endere\u00e7o da mem\u00f3ria ROM, s\u00e3o utilizados pelas opera\u00e7\u00f5es de salto para indicar o seu destino : LOOP: leaw $LOOP , %A jmp","title":"Labels"},{"location":"H-Assembler-Dicas-SymbolTable/#enderecos-de-memoria","text":"S\u00e3o endere\u00e7os de mem\u00f3ria criados automaticamente pelo assembler, ser\u00e1 utilizado pela VM e futuramente pelo compilador para alocar vari\u00e1veis noSTART_RAM_ADDRESS computador. Funciona da seguinte maneira : leaw $var , %A movw %D , ( %A ) O Assembler deve alocar um endere\u00e7o automaticamente ainda n\u00e3o utilizado para var0 , o valor a ser alocado \u00e9 a partir do endere\u00e7o 16 da RAM. Simb valor var0 16 O nome da vari\u00e1vel pode ser qualquer uma, desde que n\u00e3o repita um nome de label.","title":"Endere\u00e7os de mem\u00f3ria"},{"location":"H-Assembler-Dicas-SymbolTable/#exemplo","text":"Vamos supor o c\u00f3digo (que n\u00e3o faz nada coerente) a seguir: 0: leaw $x, %A 1: movw $1, (%A) 2: LOOP: 3: leaw $UPDATE, %A 4: je %D 5: nop 6: leaw $temp, %A 7: movw (%A), %A 8: addw %A, %S, %S 9: decw %D 10: leaw $LOOP, %A 11: jmp 12: nop 13: UPDATE: 14: leaw $3, %A 15: movw %S, (%A) 16: END: 17: leaw $END, %A 18: jmp 19: nop A tabela de s\u00edmbolos gerada deveria ser: S\u00edmbolos Valor R0 0 R1 1 ... ... R15 15 SP 0 LCL 1 ARG 2 THIS 3 THAT 4 SCREEN 16384 LED 21184 SW 21185 ------------ -------- x 16 y 17 LOOP 2 UPDATE 12 END 14","title":"Exemplo"},{"location":"H-Assembler-Lab-1-[parte-1]/","text":"Agora iremos desenvolver um programa em java que ser\u00e1 capaz de ler nossos programas em .nasm e converter eles para .hack (bin\u00e1rio). Nosso arquivo .hack \u00e9 um arquivo de texto que possui apenas 1 s e 0 s. Cada linha desse arquivo .hack \u00e9 uma instru\u00e7\u00e3o a ser armazenada na mem\u00f3ria. Exemplo de um arquivo .hack : 000000000000000101 100101100000010000 000000000000000001 100000000000100000 000000000000001011 Voc\u00ea pode abrir seus arquivos .hack, basta ir em F-Assembly/bin/hack/ que vai encontrar seus programas em linguagem de m\u00e1quina. O arquivo .hack \u00e9 um formato que n\u00e3o conseguimos fazer o download para a FPGA, \u00e9 necess\u00e1rio convertemos esse formato em um que o Quartus entenda. Esse formato do Quartus \u00e9 chamado de .mif e \u00e9 gerado automaticamente pelos scripts de teste, esse arquivo .mif \u00e9 simular ao .hack salvo um cabe\u00e7alho e a indica\u00e7\u00e3o do endere\u00e7o na qual a linha deve ser salva: WIDTH=18; DEPTH=5; ADDRESS_RADIX=UNS; DATA_RADIX=BIN; CONTENT BEGIN 0 : 000000000000000101; 1 : 100101100000010000; 2 : 000000000000000001; 3 : 100000000000100000; 4 : 000000000000001011; END; O Assembler de voc\u00eas deve gerar um arquivo .hack. A convers\u00e3o para o .mif \u00e9 feita pelos scripts em python j\u00e1 fornecidos assembler script .nasm ---------> .hack --------> .mif v |---------> FPGA |---------> SIMULADOR Assembler \u00b6 O assembler ser\u00e1 um programa escrito em java e que foi estruturado em quatro classes : Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o a de programar o Computador na FPGA e executarmos c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Note que o 'orquestrador' da montagem (esse \u00e9 o termo em portugu\u00eas utilizado) \u00e9 a classe 'Assemble', nela que estar\u00e1 toda a l\u00f3gica de montagem acessoada pelas demais classes. Pr\u00f3ximos passos \u00b6 Agora vamos come\u00e7ar a trabalhar no c\u00f3digo java. SIGA PARA PARTE 2","title":"Parte 1"},{"location":"H-Assembler-Lab-1-[parte-1]/#assembler","text":"O assembler ser\u00e1 um programa escrito em java e que foi estruturado em quatro classes : Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o a de programar o Computador na FPGA e executarmos c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Note que o 'orquestrador' da montagem (esse \u00e9 o termo em portugu\u00eas utilizado) \u00e9 a classe 'Assemble', nela que estar\u00e1 toda a l\u00f3gica de montagem acessoada pelas demais classes.","title":"Assembler"},{"location":"H-Assembler-Lab-1-[parte-1]/#proximos-passos","text":"Agora vamos come\u00e7ar a trabalhar no c\u00f3digo java. SIGA PARA PARTE 2","title":"Pr\u00f3ximos passos"},{"location":"H-Assembler-Lab-1-[parte-2]/","text":"Warning Todos do grupo devem realizar de forma individual! Iremos realizar o desenvolvimento do Assembler na IDE do Intellij, para isso precisamos importar um projeto do tipo maven. Com o Intellij instalado : Import Project: Importe a pasta do Projeto H-Assebler/Assembler : Escolha o Maven : Iremos trabalhar com o JDK 8 java-8-oracle . Ser\u00e1 necess\u00e1rio adicionar o mesmo na ferramenta: O caminho normalmente \u00e9 /usr/lib/jvm/","title":"Parte 2"},{"location":"H-Assembler-Lab-1-[parte-3]/","text":"Deve ser realizado em dupla Iremos agora implementar um dos m\u00e9todos da classe Code , a parte respons\u00e1vel por gerar os tr\u00eas bits referentes ao jump : No Intellij abra o c\u00f3digo code.java e procure pelo m\u00e9todo jump : /** * Retorna o c\u00f3digo bin\u00e1rio do mnem\u00f4nico para realizar uma opera\u00e7\u00e3o de jump (salto). * @param mnemnonic vetor de mnem\u00f4nicos \"instru\u00e7\u00e3o\" a ser analisada. * @return Opcode (String de 3 bits) com c\u00f3digo em linguagem de m\u00e1quina para a instru\u00e7\u00e3o. */ public static String jump ( String [] mnemnonic ) { return \"\" ; } Note que o input dessa fun\u00e7\u00e3o \u00e9 um array de strings, chamado mnemnonic e seu retorno \u00e9 uma string. No mnemnonic ser\u00e1 passado a instru\u00e7\u00e3o a ser executada da seguinte forma: {\"jmp\"} {\"jge\", \"S\"} {\"jg\", \"%D\"} ... E deve retornar o bin\u00e1rio correspondente aos bits j2, j1 e j0 do comando de jump : 111 , 011 , 010 , .... Note que aesa classe n\u00e3o precisa se preocupar com a origem do jump (%S, %D, ...) apenas com o seu tipo jmp , jge , ... Implementando \u00b6 Vamos implementar algo bem simples que est\u00e1 incompleto, mas vai servir para entendermos o fluxo. Modifique o c\u00f3digo com o exemplo a seguir : public static String jump ( String [] mnemnonic ) { switch ( mnemnonic [ 0 ]){ case \"jmp\" : return \"111\" ; default : return \"000\" ; } } Com a classe implementada, podemos executar o teste unit\u00e1rio dela. No Intellij: Com o bot\u00e3o direito no test/java/assembler/CodeTest Note que o teste falhou, j\u00e1 que a nossa implementa\u00e7\u00e3o est\u00e1 incompleta. terminando \u00b6 Retorne a classe jump e termine sua implementa\u00e7\u00e3o. Execute novamente o teste at\u00e9 passar. Antes de continuar Termine de implementar essa classe","title":"Parte 3"},{"location":"H-Assembler-Lab-1-[parte-3]/#implementando","text":"Vamos implementar algo bem simples que est\u00e1 incompleto, mas vai servir para entendermos o fluxo. Modifique o c\u00f3digo com o exemplo a seguir : public static String jump ( String [] mnemnonic ) { switch ( mnemnonic [ 0 ]){ case \"jmp\" : return \"111\" ; default : return \"000\" ; } } Com a classe implementada, podemos executar o teste unit\u00e1rio dela. No Intellij: Com o bot\u00e3o direito no test/java/assembler/CodeTest Note que o teste falhou, j\u00e1 que a nossa implementa\u00e7\u00e3o est\u00e1 incompleta.","title":"Implementando"},{"location":"H-Assembler-Lab-1-[parte-3]/#terminando","text":"Retorne a classe jump e termine sua implementa\u00e7\u00e3o. Execute novamente o teste at\u00e9 passar. Antes de continuar Termine de implementar essa classe","title":"terminando"},{"location":"H-Assembler-Lab-1-[parte-4]/","text":"Deve ser realizado em dupla```diff Desenvolvimento baseado em testes \u00e9 uma t\u00e9cnica que temos utilizado at\u00e9 agora para os nosso projetos, nesse m\u00e9todo fragmentando o desenvolvimento em pequenos m\u00f3dulos que s\u00e3o testados de forma individual, por testes unit\u00e1rios. O desenvolvimento \u00e9 focado em fazer com que os m\u00f3dulos passem nos testes. Como os testes n\u00e3o s\u00e3o perfeitos e n\u00e3o conseguem cobrir toda a funcionalidade do m\u00f3dulo, \u00e9 necess\u00e1rio realizarmos o teste de integra\u00e7\u00e3o, onde juntamos todas as pe\u00e7as e testamos o sistema como um todo. Utilizaremos o mesmo recurso agora em java, onde cada m\u00f3dulo (m\u00e9todo) possui um teste e quando todos os m\u00f3dulos estivem implementados e funcionando realizamos um teste de integra\u00e7\u00e3o que valida tudo. Os testes unit\u00e1rios foram feitos com o JUnit e est\u00e3o na pasta do projeto: H-Assembler/Assembler/test/java/assembler . Os testes cobrem todas os m\u00e9todos do projeto. Exemplo parser \u00b6 Os testes s\u00e3o uma guia do que cada m\u00e9todo deve fazer, e eles servir\u00e3o como complemento da documenta\u00e7\u00e3o do m\u00f3dulo. Iremos seguir o fluxo: Ler descri\u00e7\u00e3o do m\u00e9todo Abrir teste unit\u00e1rio e entender o que \u00e9 passado e o que \u00e9 esperado Desenvolver m\u00e9todo Testar Falhou? Volte para 1. Vamos pegar como exemplo o m\u00e9todo commandType do parser : /** * Retorna o tipo da instru\u00e7\u00e3o passada no argumento: * A_COMMAND para leaw, por exemplo leaw $1,%A * L_COMMAND para labels, por exemplo Xyz: , onde Xyz \u00e9 um s\u00edmbolo. * C_COMMAND para todos os outros comandos * @param command instru\u00e7\u00e3o a ser analisada. * @return o tipo da instru\u00e7\u00e3o. */ public CommandType commandType ( String command ) { return null ; } E seu teste unit\u00e1rio: /** * Teste para a instru\u00e7\u00e3o commandType */ @Test public void testParser_commandType () { try { assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); assertTrue ( \"abc:\" , parser . commandType ( \"abc:\" )== Parser . CommandType . L_COMMAND ); assertTrue ( \"movw %A,%D\" , parser . commandType ( \"movw %A,%D\" )== Parser . CommandType . C_COMMAND ); assertTrue ( \"movw %A,%S\" , parser . commandType ( \"movw %A,%S\" )== Parser . CommandType . C_COMMAND ); .... .... } } Vamos analisar o primeiro teste: assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); ` Nesse teste \u00e9 passado a string \"leaw $0,%A\" para o m\u00e9todo parser.commandType e esperasse na sa\u00edda A_COMMAND . Com essa informa\u00e7\u00e3o complementar conseguimos inciar o desenvolvimento dessa classe. Antes de continuar Implemente a classe parser.commandType Execute o teste unit\u00e1rio do parser at\u00e9 que o comandType passe nos testes.**","title":"Parte 4"},{"location":"H-Assembler-Lab-1-[parte-4]/#exemplo-parser","text":"Os testes s\u00e3o uma guia do que cada m\u00e9todo deve fazer, e eles servir\u00e3o como complemento da documenta\u00e7\u00e3o do m\u00f3dulo. Iremos seguir o fluxo: Ler descri\u00e7\u00e3o do m\u00e9todo Abrir teste unit\u00e1rio e entender o que \u00e9 passado e o que \u00e9 esperado Desenvolver m\u00e9todo Testar Falhou? Volte para 1. Vamos pegar como exemplo o m\u00e9todo commandType do parser : /** * Retorna o tipo da instru\u00e7\u00e3o passada no argumento: * A_COMMAND para leaw, por exemplo leaw $1,%A * L_COMMAND para labels, por exemplo Xyz: , onde Xyz \u00e9 um s\u00edmbolo. * C_COMMAND para todos os outros comandos * @param command instru\u00e7\u00e3o a ser analisada. * @return o tipo da instru\u00e7\u00e3o. */ public CommandType commandType ( String command ) { return null ; } E seu teste unit\u00e1rio: /** * Teste para a instru\u00e7\u00e3o commandType */ @Test public void testParser_commandType () { try { assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); assertTrue ( \"abc:\" , parser . commandType ( \"abc:\" )== Parser . CommandType . L_COMMAND ); assertTrue ( \"movw %A,%D\" , parser . commandType ( \"movw %A,%D\" )== Parser . CommandType . C_COMMAND ); assertTrue ( \"movw %A,%S\" , parser . commandType ( \"movw %A,%S\" )== Parser . CommandType . C_COMMAND ); .... .... } } Vamos analisar o primeiro teste: assertTrue ( \"leaw $0,%A\" , parser . commandType ( \"leaw $0,%A\" )== Parser . CommandType . A_COMMAND ); ` Nesse teste \u00e9 passado a string \"leaw $0,%A\" para o m\u00e9todo parser.commandType e esperasse na sa\u00edda A_COMMAND . Com essa informa\u00e7\u00e3o complementar conseguimos inciar o desenvolvimento dessa classe. Antes de continuar Implemente a classe parser.commandType Execute o teste unit\u00e1rio do parser at\u00e9 que o comandType passe nos testes.**","title":"Exemplo parser"},{"location":"H-Assembler-Lab-1-[parte-5]/","text":"+ Deve ser realizado em dupla Implemente o m\u00e9todo initialize da classe SymbolTable utilizando os conceitos visto nos outros labs. Dicas sobre o SymbolTable","title":"Parte 5"},{"location":"H-Assembler-Lab-1/","text":"Esse laborat\u00f3rio introduz uma s\u00e9rie de conceitos e ferramentas e deve ser realizado individualmente ou em dupla (como indicado no come\u00e7o de cada parte). Ao final do laborat\u00f3rio voc\u00ea dever\u00e1: Entender o que \u00e9 um arquivo .hack e .mif Ter um projeto importado no Intellij Ter o m\u00e9todo code.jump implementando Saber como executar os testes unit\u00e1rios Ter o m\u00e9todo parser.commandType implementando Saber como extrair informa\u00e7\u00f5es dos testes unit\u00e1rios Ter o fillSymbolTable.initialize implementando Pr\u00f3ximos passos \u00b6 Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Scrum Master atualize o reposit\u00f3rio com o upstream antes de continuar SEGUIR PARA A PRIMEIRA PARTE","title":"H Assembler Lab 1"},{"location":"H-Assembler-Lab-1/#proximos-passos","text":"Voc\u00ea \u00e9 Scrum Master e n\u00e3o sabe por onde come\u00e7ar? De uma olhada nessas dicas: Vixi! Sou Scrum Master Scrum Master atualize o reposit\u00f3rio com o upstream antes de continuar SEGUIR PARA A PRIMEIRA PARTE","title":"Pr\u00f3ximos passos"},{"location":"H-Assembler-Prerequisitos/","text":"(contanto com o restante da infra j\u00e1 esteja funcionando) Java JDK 8 Maven https://maven.apache.org/install.html IDE Intellij Se voc\u00ea est\u00e1 usando o SSD fornecido, precisa apenas executar os comandos a seguir: $ sudo apt install maven $ python3 -m pip install joblib --user $ sudo snap install intellij-idea-community --classic --edge Caso contr\u00e1rio precisa instalar o JAVA 8 oficial (o open n\u00e3o funciona).","title":"Prerequisitos"},{"location":"H-Assembler-Projeto/","text":"H - Assembler \u00b6 Nesse projeto iremos criar o programa assembler que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em Assembly para a linguagem de m\u00e1quina. Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio 1 desse projeto. M\u00f3dulos a serem implementados \u00b6 O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo AssemblerZ01.java j\u00e1 est\u00e1 pronto. Tip Os m\u00f3dulos est\u00e3o listados de maneira Top - Down AssemblerZ01 Arquivo : AssemblerZ01.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .nasm e o nome do arquivo bin\u00e1rio de m\u00e1quina .hack . a ser escrito, passa essas informa\u00e7\u00f5es para a classe Assemble. Essa classe que inicializa a tabela de s\u00edmbolo ( fillSymbolTable ) e chama o m\u00e9todo generateMachineCode para efetivamente gerar o arquivo de sa\u00edda. Depend\u00eancias : Assemble.java Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Teste unit\u00e1rio ou Teste integra\u00e7\u00e3o n\u00e3o passa C - Criado assembler a partir de estrutura de c\u00f3digo disponibilizada - Todos os testes unit\u00e1rios passam no teste - Os testes de integra\u00e7\u00e3o passam nos testes - Travis configurado corretamente B - Implementando modo verbose (-v) que possibilita analisar o assembler e suas etapas - Verifica se instru\u00e7\u00e3o de jump \u00e9 seguida de NOP, caso contr\u00e1rio da erro B+ - Insere automaticamente um NOP ap\u00f3s intru\u00e7\u00e3o de JUMP que n\u00e3o \u00e9 seguida de nop. Imprime mensagem de alerta que isso foi feito. A - Possui macros para facilitar desenvolvimento no assembly* A+ - C\u00f3digo e documenta\u00e7\u00e3o gerada com DoxyGen Dicas Macro - Rubrica A Veja a dica de como implementar Macros","title":"Projeto"},{"location":"H-Assembler-Projeto/#h-assembler","text":"Nesse projeto iremos criar o programa assembler que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em Assembly para a linguagem de m\u00e1quina.","title":"H - Assembler"},{"location":"H-Assembler-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio 1 desse projeto.","title":"Instru\u00e7\u00f5es"},{"location":"H-Assembler-Projeto/#modulos-a-serem-implementados","text":"O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo AssemblerZ01.java j\u00e1 est\u00e1 pronto. Tip Os m\u00f3dulos est\u00e3o listados de maneira Top - Down AssemblerZ01 Arquivo : AssemblerZ01.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .nasm e o nome do arquivo bin\u00e1rio de m\u00e1quina .hack . a ser escrito, passa essas informa\u00e7\u00f5es para a classe Assemble. Essa classe que inicializa a tabela de s\u00edmbolo ( fillSymbolTable ) e chama o m\u00e9todo generateMachineCode para efetivamente gerar o arquivo de sa\u00edda. Depend\u00eancias : Assemble.java Assemble Arquivo : Assemble.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo de m\u00e1quina, ela que efetivamente faz a varredura do arquivo .nasm de entrada e escreve o arquivo .hack de sa\u00edda, gerando o c\u00f3digo de m\u00e1quina. Depend\u00eancias : Code.java , Parser.java , SymbolTable.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz mnem\u00f4nicos da linguagem assembly para c\u00f3digos bin\u00e1rios da arquitetura Z0. Depend\u00eancias : none Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem assembly, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none SymbolTable Arquivo : SymbolTable.java Descri\u00e7\u00e3o : Mant\u00e9m uma tabela com a correspond\u00eancia entre os r\u00f3tulos simb\u00f3licos e endere\u00e7os num\u00e9ricos de mem\u00f3ria. Depend\u00eancias : none","title":"M\u00f3dulos a serem implementados"},{"location":"H-Assembler-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"H-Assembler-Projeto/#projeto","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - Teste unit\u00e1rio ou Teste integra\u00e7\u00e3o n\u00e3o passa C - Criado assembler a partir de estrutura de c\u00f3digo disponibilizada - Todos os testes unit\u00e1rios passam no teste - Os testes de integra\u00e7\u00e3o passam nos testes - Travis configurado corretamente B - Implementando modo verbose (-v) que possibilita analisar o assembler e suas etapas - Verifica se instru\u00e7\u00e3o de jump \u00e9 seguida de NOP, caso contr\u00e1rio da erro B+ - Insere automaticamente um NOP ap\u00f3s intru\u00e7\u00e3o de JUMP que n\u00e3o \u00e9 seguida de nop. Imprime mensagem de alerta que isso foi feito. A - Possui macros para facilitar desenvolvimento no assembly* A+ - C\u00f3digo e documenta\u00e7\u00e3o gerada com DoxyGen Dicas Macro - Rubrica A Veja a dica de como implementar Macros","title":"Projeto"},{"location":"H-Assembler-Testando/","text":"A pasta do projeto H, possui a seguinte estrutura: scripts: Scripts em python que automatizam a execu\u00e7\u00e3o dos testes; compileNasmMyAssembler : Compila os nasms do projeto F-Assembly com o assembler do grupo e salva o resultado em bin/hack/ testeAssembler : Compila os nasms com o assembler do grupo e executa a simula\u00e7\u00e3o no Z01.1 ( standard-professor ). testeAssemblerMyCPU : Compila os nasms com o assembler do grupo e executa a simula\u00e7\u00e3o no Z01.1 do grupo ( projeto G-CPU ). genJAR : Gera um Jar que ser\u00e1 utilizado pelos testes anteriores a partir das fontes em Assembler/src/main/ -> Salva em Assembler/Z01-Assembler.jar . Esses scripts de testes utilizam o projeto F-Assembly! bin/hack/*.hack : Arquivos .hack convertidos via Z01-Assembler.jar Assembler/src/main/java/assembler : C\u00f3digo fonte em java do assembler, que deve ser implementando por voc\u00eas! Testes \u00b6 \u00c9 disponibilizado dois tipos de testes: Unit\u00e1rio para as classes em java e de Integra\u00e7\u00e3o para o Assembler como um todo. Os testes unit\u00e1rios das classes est\u00e3o localizados em Assembler/src/tsts/ e pode ser executado de duas maneiras: Via IDE (Intellij) Via maven na gera\u00e7\u00e3o do jar (`genJAR.py**) J\u00e1 o teste de integra\u00e7\u00e3o que considera como as classes foram utilizadas para a gera\u00e7\u00e3o do Assembler \u00e9 executado via script testeAssembler.py , executando os seguintes passos : Gera o jar ( genJAR.py ) input : Assembler/src/main/java/assembler/*.java* output: Z01-Assembler.jar Compila os nasms input: F-Assembly/src/nasm/*.nasm* output: H-Assembler/bin/hack/*.mif* Executa os testes no hardware (usando o hardware de refer\u00eancia) input: F-Assembly/tests/* input: H-Assembler/bin/hack/*.mif* output: F-Assembly/tests/tst/name/*_end.mif* Compara resultado com esperado input : F-Assembly/tests/tst/name/*_tst.mif* output: Terminal","title":"Testando"},{"location":"H-Assembler-Testando/#testes","text":"\u00c9 disponibilizado dois tipos de testes: Unit\u00e1rio para as classes em java e de Integra\u00e7\u00e3o para o Assembler como um todo. Os testes unit\u00e1rios das classes est\u00e3o localizados em Assembler/src/tsts/ e pode ser executado de duas maneiras: Via IDE (Intellij) Via maven na gera\u00e7\u00e3o do jar (`genJAR.py**) J\u00e1 o teste de integra\u00e7\u00e3o que considera como as classes foram utilizadas para a gera\u00e7\u00e3o do Assembler \u00e9 executado via script testeAssembler.py , executando os seguintes passos : Gera o jar ( genJAR.py ) input : Assembler/src/main/java/assembler/*.java* output: Z01-Assembler.jar Compila os nasms input: F-Assembly/src/nasm/*.nasm* output: H-Assembler/bin/hack/*.mif* Executa os testes no hardware (usando o hardware de refer\u00eancia) input: F-Assembly/tests/* input: H-Assembler/bin/hack/*.mif* output: F-Assembly/tests/tst/name/*_end.mif* Compara resultado com esperado input : F-Assembly/tests/tst/name/*_tst.mif* output: Terminal","title":"Testes"},{"location":"I-VM-Ferramental-Memoria/","text":"Para a m\u00e1quina virtual funcionar corretamente devemos agora definir regi\u00f5es de mem\u00f3ria que servir\u00e1 para aplica\u00e7\u00f5es espec\u00edficas, tal como armazenar: o topo da pilha ( SP , Stack Pointer), os locais dos par\u00e2metros passados na chamada de fun\u00e7\u00e3o ( ARG , argument), os endere\u00e7os das vari\u00e1veis locais de uma fun\u00e7\u00e3o ( LCL , local) ... A seguir um resumo dos endere\u00e7os de mem\u00f3ria e suas fun\u00e7\u00f5es : Endere\u00e7o (RAM) S\u00edmbolo Nome Uso 0 SP Stack Pointer Ponteiro para o topo da pilha 1 LCL Local Ponteiro para a base das vari\u00e1veis de um fun\u00e7\u00e3o 2 ARG Argument Ponteiro para a base dos argumentos de uma fun\u00e7\u00e3o 3 THIS This Ponteiro para a base do segmento this 4 THAT That Ponteiro para a base do segmento that 5..12 Temp Temporary Endere\u00e7os para armazenar vari\u00e1veis tempor\u00e1rias Al\u00e9m dos endere\u00e7os espec\u00edficos (que possuem papeis especiais), devemos tamb\u00e9m definir regi\u00f5es da mem\u00f3ria que ser\u00e3o utilizadas para armazenar tipos de dados espec\u00edficos, s\u00e3o eles : Endere\u00e7o (RAM) Nome Uso 16-255 Static Vari\u00e1veis est\u00e1ticas (acess\u00edveis por todas as fun\u00e7\u00f5es) 256-2047 Stack Pilha utilizada pela vm (stack pointer) 2048-16383 Heap Usada para armazenar objetos e vetores 16384- I/O Perif\u00e9ricos mapeados em mem\u00f3ria Iremos detalhar um pouco de cada item descrito nesse resumo. Stack \u00b6 A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influencia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMtranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o. Stack Pointer \u00b6 \u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir : Stack overflow? \u00b6 Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 oclocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada peara o Heap, corrompendo os dados ali salvos. Fun\u00e7\u00e3o \u00b6 Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9 : Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha : Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o) LCL - Local \u00b6 Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n ARG - Argumento \u00b6 O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n Static variables \u00b6 \u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/ HEAP \u00b6 O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria. This \u00b6 This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm That \u00b6 O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"VM Mem\u00f3ria"},{"location":"I-VM-Ferramental-Memoria/#stack","text":"A stack \u00e9 a regi\u00e3o de mem\u00f3ria utilizada pela VM para armazenar valores e realizar opera\u00e7\u00f5es, funciona como uma forma de abstra\u00e7\u00e3o do hardware, j\u00e1 que agora toda manipula\u00e7\u00e3o de dados acontece na Stack e n\u00e3o mais nos registradores. \u00c9 claro que essa manipula\u00e7\u00e3o influencia nos registradores do hardware, mas o programador n\u00e3o mais precisa ter todo o conhecimento do hardware nas opera\u00e7\u00f5es. Por exemplo a opera\u00e7\u00e3o : push constant 5 push constant 3 add Adiciona o valor 5 e o 3 para o topo da pilha e os soma, resultando em um \u00fanico valor : 8. Notem que para essa opera\u00e7\u00e3o ser realizada no hardware do Z01 tivemos que usar os registradores para tornar a opera\u00e7\u00e3o vi\u00e1vel, por\u00e9m isso n\u00e3o \u00e9 mais vis\u00edvel do programa VM. Nesse camada de software n\u00e3o interessa mais se o hardware possui 2, 3, ... N registradores o resultado da opera\u00e7\u00e3o ser\u00e1 a mesma. Teremos 8 no topo da pilha. O hardware vai influenciar o VMtranslator que deve traduzir a linguagem de m\u00e1quina virtual por pilha para a linguagem assembly, o n\u00famero de registradores pode influenciar a performance do computador mas n\u00e3o ir\u00e1 mudar o conceito de pilha. A stack \u00e9 utilizada tamb\u00e9m para armazenar os valores passados na chamada de fun\u00e7\u00e3o e tamb\u00e9m para armazenar o resultado (return) de uma fun\u00e7\u00e3o.","title":"Stack"},{"location":"I-VM-Ferramental-Memoria/#stack-pointer","text":"\u00c9 um ponteiro que indica a onde est\u00e1 o endere\u00e7o do topo da pilha, como a pilha cresce e diminui dinamicamente (conforme os push, pops e opera\u00e7\u00f5es) necessitamos armazenar em algum local o endere\u00e7o do topo da pilha, conforme figura a seguir :","title":"Stack Pointer"},{"location":"I-VM-Ferramental-Memoria/#stack-overflow","text":"Agora fica mais claro o significado do site stack overflow ? Indica o estouro da pilha. Imagine a situa\u00e7\u00e3o na qual s\u00f3 oclocamos dados na pilha e nunca tiramos ( pop , em algum momento a pilha ir\u00e1 passar seu valor m\u00e1ximo, que no nosso caso \u00e9 : 2047 - 256 = 1791 endere\u00e7os e come\u00e7ar\u00e1 a escrever na regi\u00e3o reservada peara o Heap, corrompendo os dados ali salvos.","title":"Stack overflow?"},{"location":"I-VM-Ferramental-Memoria/#funcao","text":"Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o o ARG indica o endere\u00e7o da stack na qual os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 indicado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9 : Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar os locals Atualiza os ponteiros : SP, LCL, ARG O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha : Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o)","title":"Fun\u00e7\u00e3o"},{"location":"I-VM-Ferramental-Memoria/#lcl-local","text":"Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais : aux0, aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis (aux0, aux1) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir: O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira : function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n Tip Endere\u00e7o local n = LCL + n","title":"LCL - Local"},{"location":"I-VM-Ferramental-Memoria/#arg-argumento","text":"O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Tip Endere\u00e7o argument n = ARG + n","title":"ARG - Argumento"},{"location":"I-VM-Ferramental-Memoria/#static-variables","text":"\u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } Note As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/","title":"Static variables"},{"location":"I-VM-Ferramental-Memoria/#heap","text":"O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria.","title":"HEAP"},{"location":"I-VM-Ferramental-Memoria/#this","text":"This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm","title":"This"},{"location":"I-VM-Ferramental-Memoria/#that","text":"O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir: M\u00e9todo objeto Celeste: void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal: void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"That"},{"location":"I-VM-Lab-1/","text":"Descri\u00e7\u00e3o \u00b6 Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator . M\u00f3dulos a serem implementados \u00b6 Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 2a-Calculadora 1c-Dic 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto. Exemplos \u00b6 Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/ Linguagem VM \u00b6 A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o mais lidam com registradores do computador mas sim com dados que s\u00e3o colocados e tirados de uma pilha (stack). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer esse programa), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual : a. Abstra\u00e7\u00e3o de Hardware - (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) c. Portabilidade b. C\u00f3digo mais alto n\u00edvel - (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...) Pilha \u00b6 A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (come\u00e7ando no endere\u00e7o 256) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es de pull (retirar dados da pilha) s\u00e3o executadas. Stack Pointer (SP) \u00b6 O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria (RAM[0]) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0), e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada. Opera\u00e7\u00e3o \u00b6 Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add executa: X + Y sub executa: X - Y neg executa: - Y - Y (complemento de dois) eq compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and executa: X and Y (bit a bit) or executa: X or Y (bit a bit) not executa: not Y (bit a bit) Note que as opera\u00e7\u00f5es de compara\u00e7\u00e3o (eq, gt, lt) resulta em um True e False e esse resultado \u00e9 salvo na pilha, considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 2 3 e 5, e ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False (0xFFFF ou 0x0000). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> As opera\u00e7\u00f5es na pilha n\u00e3o apagam o resultado que j\u00e1 estava na pilha, se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo. Acesso a mem\u00f3ria \u00b6 Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pila (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM Exemplo, acessando o temp \u00b6 Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3 PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1a-Add Projetos/I-VM/src/vm/1b-Add Projetos/I-VM/src/vm/2a-Calculadora Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos os programas! Escrevendo um pixel no LCD \u00b6 Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF GOTO \u00b6 Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em .vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push temp 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END labels \u00b6 Os labels s\u00e3o definidos pela keyword label + nome : label nome PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1c-div Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos o programa! Fun\u00e7\u00f5es \u00b6 A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Nesse projeto SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es : O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em python para vm : def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em vm: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos. return \u00b6 A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico Chamada de fun\u00e7\u00e3o \u00b6 A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2 Graficamente \u00b6 PROGRAMANDO \u00b6 Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/2b-Calculadora Projetos/I-VM/src/vm/2c-Calculadora Projetos/I-VM/src/vm/2d-Calculadora Antes de continuar Escreva os programas e teste.","title":"16: I VM Lab 1"},{"location":"I-VM-Lab-1/#descricao","text":"Nesse lab iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator .","title":"Descri\u00e7\u00e3o"},{"location":"I-VM-Lab-1/#modulos-a-serem-implementados","text":"Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 2a-Calculadora 1c-Dic 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto.","title":"M\u00f3dulos a serem implementados"},{"location":"I-VM-Lab-1/#exemplos","text":"Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/","title":"Exemplos"},{"location":"I-VM-Lab-1/#linguagem-vm","text":"A linguagem VM proposta para o curso \u00e9 baseada em pilha (assim como tantas outras), as opera\u00e7\u00f5es nesse n\u00edvel n\u00e3o mais lidam com registradores do computador mas sim com dados que s\u00e3o colocados e tirados de uma pilha (stack). Uma grande vantagem disso \u00e9 a abstra\u00e7\u00e3o do hardware, agora n\u00e3o precisamos mais nos preocuparmos com a manipula\u00e7\u00e3o dos dados em baixo n\u00edvel (o VMTranslator ser\u00e1 encarregado disso). Um c\u00f3digo escrito em VM passa pelas seguintes etapas antes de ser executado em m\u00e1quina : VMTranslator Assembler .vm -------------> .nasm -------------> .hack O c\u00f3digo vm \u00e9 traduzido para linguagem nasm pelo VMTranslator (voc\u00eas v\u00e3o ter que fazer esse programa), e ent\u00e3o \u00e9 montado pelo Assembler para linguagem de m\u00e1quina. Temos diversas vantagens quando programamos em linguagem virtual : a. Abstra\u00e7\u00e3o de Hardware - (j\u00e1 n\u00e3o mais lidamos com o hardware diretamente) c. Portabilidade b. C\u00f3digo mais alto n\u00edvel - (chamada de fun\u00e7\u00f5es, linguagem mais pr\u00f3xima do que estamos acostumados, ...)","title":"Linguagem VM"},{"location":"I-VM-Lab-1/#pilha","text":"A linguagem VM \u00e9 baseada em pilha, ou seja, todas as opera\u00e7\u00f5es que ser\u00e3o realizadas ser\u00e3o feitas na pilha. A pilha \u00e9 uma regi\u00e3o da mem\u00f3ria RAM (come\u00e7ando no endere\u00e7o 256) reservada para armazenar os dados que est\u00e3o sendo manipulados. A pilha cresce conforme opera\u00e7\u00f5es de push (envio de dados para a pilha) v\u00e3o sendo executados, e decresce conforme opera\u00e7\u00f5es de pull (retirar dados da pilha) s\u00e3o executadas.","title":"Pilha"},{"location":"I-VM-Lab-1/#stack-pointer-sp","text":"O Stack Pointer \u00e9 o endere\u00e7o de mem\u00f3ria (RAM[0]) reservado por apontar o topo da pilha, ou seja, a pr\u00f3xima posi\u00e7\u00e3o vazia da pilha. O SP \u00e9 salvo na RAM 0 (R0), e deve ser incrementado/decrementado conforme a pilha vai sendo manipulada.","title":"Stack Pointer (SP)"},{"location":"I-VM-Lab-1/#operacao","text":"Considerando a seguinte disposi\u00e7\u00e3o na pilha : ... ... X Y SP -> S\u00e3o suportadas as seguintes opera\u00e7\u00f5es aritm\u00e9ticas na pilha: add executa: X + Y sub executa: X - Y neg executa: - Y - Y (complemento de dois) eq compara X == Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 gt compara X > Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 lt compara X < Y True : resulta em b\"11111111111111111\", 0xFFFF False: resulta em b\"0000000000000000\"\", 0x0000 and executa: X and Y (bit a bit) or executa: X or Y (bit a bit) not executa: not Y (bit a bit) Note que as opera\u00e7\u00f5es de compara\u00e7\u00e3o (eq, gt, lt) resulta em um True e False e esse resultado \u00e9 salvo na pilha, considere o exemplo a seguir (em hexa) que possui inicialmente na pilha os valores 2 3 e 5, e ap\u00f3s a opera\u00e7\u00e3o de eq os valores 3 e 5 s\u00e3o comparados e resulta em um valor True ou False (0xFFFF ou 0x0000). -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x5 SP-> SP-> As opera\u00e7\u00f5es na pilha n\u00e3o apagam o resultado que j\u00e1 estava na pilha, se olharmos a mem\u00f3ria real do exemplo anterior seria a seguinte: -> eq -> -> gt -> 0x2 0x2 0xFFFF 0x3 0x0 SP-> 0x0 0x5 SP-> 0x5 0x5 SP-> 0x0 0x0 0x0 O mesmo acontece com arquivos que s\u00e3o deletados do seu computador, o sistema operacional n\u00e3o \"limpa a mem\u00f3ria\" sempre que um arquivo \u00e9 exclu\u00eddo, apenas apaga o ponteiro para aquele arquivo.","title":"Opera\u00e7\u00e3o"},{"location":"I-VM-Lab-1/#acesso-a-memoria","text":"Os comandos push e pop s\u00e3o a \u00fanica maneira que temos de acessar/manipular a mem\u00f3ria. O comando push traz para a pilha um valor da mem\u00f3ria (RAM ou ROM) e o comando pop salva na mem\u00f3ria um valor da pila (RAM). Os comandos possuem a seguinte sintaxe : push segment index pop segment index Onde index \u00e9 um n\u00famero inteiro positivo e segment pode ser um dos casos a seguir: segment Uso Index Coment\u00e1rio argument Local onde o argumento da fun\u00e7\u00e3o est\u00e1 salvo 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada local Local das vari\u00e1veis locais da fun\u00e7\u00e3o 0 .. Alocado dinamicamente pelo VMTranslator quando a fun\u00e7\u00e3o \u00e9 chamada static Local onde as vari\u00e1veis do objeto est\u00e3o salvos 0 .. Essas vari\u00e1veis s\u00e3o compartilhadas por todas as fun\u00e7\u00f5es do mesmo .vm, assim como em um objeto constant Carrega uma constante na pilha 0 .. 32767 Mesmo uso do leaw (carrega da ROM um valor na RAM) this/that Segmentos de uso geral, pode apontar para qualquer lugar 0 .. Usado para ler e escrever de endere\u00e7os da mem\u00f3ria, por exemplo, acessar o LCD pointer Altera os valores do this e do that 0, 1 Usado para modificar a onde o this e o that apontam temp Local para uso de vari\u00e1veis tempor\u00e1rias 0 .. 7 Acessado por qualquer fun\u00e7\u00e3o, \u00e9 armazenado nos endere\u00e7os R5 .. R12 da RAM","title":"Acesso a mem\u00f3ria"},{"location":"I-VM-Lab-1/#exemplo-acessando-o-temp","text":"Por exemplo, para trazermos para a pilha uma constante realizamos a seguinte opera\u00e7\u00e3o: push constant 15 nesse caso o segmento acessado \u00e9 o constant e o par\u00e2metro \u00e9 o 15. Para salvarmos o valor 15 no temp 3 (endere\u00e7o da RAM 7), basta: push constant 15 pop temp 3 Podemos tamb\u00e9m trazer o temp 3 para a pilha: push temp 3","title":"Exemplo, acessando o temp"},{"location":"I-VM-Lab-1/#programando","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1a-Add Projetos/I-VM/src/vm/1b-Add Projetos/I-VM/src/vm/2a-Calculadora Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos os programas!","title":"PROGRAMANDO"},{"location":"I-VM-Lab-1/#escrevendo-um-pixel-no-lcd","text":"Para atualizarmos o LCD via VM ser\u00e1 necess\u00e1rio primeiro atualizarmos para onde o that aponta, that \u00e9 a maneira que possu\u00edmos de escrever em qualquer endere\u00e7o da mem\u00f3ria. O exemplo a seguir ilustra como usamos o segmento that para escrever nos pixels centrais do LCD, supondo que gostar\u00edamos de realizar a seguinte opera\u00e7\u00e3o em C. int * pLCD = 16384 * ( pLCD + 1200 ) = 0xFFFF Nesse pequeno c\u00f3digo em C o que est\u00e1 acontecendo \u00e9 que primeiramente definimos um ponteiro pLCD que aponta para 16384, depois fazemos com que o endere\u00e7o desse ponteiro + 1200 receba 0xFFFF, o mesmo c\u00f3digo em VM \u00e9 realizado da seguinte maneira : push constant 16384 -- carrega 16384 para a pilha pop pointer 1 -- atualiza para onde that aponta (int *pLCD = 16384) push contant 1 -- carrega 1 para a pilha neg -- nega o 1 para obter o valor 0xFFFF -- poderia ter realizado o push contant 4095 no lugar -- dessas duas opera\u00e7\u00f5es pop that 1200 -- faz com que o endere\u00e7o da mem\u00f3ria 16384 + 1200 = 0xFFFF","title":"Escrevendo um pixel no LCD"},{"location":"I-VM-Lab-1/#goto","text":"Goto \u00e9 a maneira de desviarmos uma execu\u00e7\u00e3o em .vm, e possui a seguinte sintaxe: goto LABEL if-goto LABEL podemos utilizar dois tipos : goto : incondicional , salta sem condi\u00e7\u00e3o if-goto : condiconal, salta se o \u00faltimo valor da pilha for True Exemplo: Salto para igual se 3 = 2 push constant 3 push constant 2 eq if-goto IGUAL .. .. label IGUAL .. .. Exemplo: Contador utilizando for utilizando goto // for(i=0; i<10; i++) // x = x+1; push constant 0 pop temp 0 push constant 1 pop temp 1 label LOOP_START push temp 0 push constant 10 eq if-goto END // se temp0 = 10 salta para o fim push temp 0 push constant 1 add pop temp 0 push temp 1 push temp 1 add pop temp 1 goto LOOP_START // If counter > 0, goto LOOP_START label END","title":"GOTO"},{"location":"I-VM-Lab-1/#labels","text":"Os labels s\u00e3o definidos pela keyword label + nome : label nome","title":"labels"},{"location":"I-VM-Lab-1/#programando_1","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/1c-div Antes de Continuar S\u00f3 Continue ap\u00f3s implementar e testar todos o programa!","title":"PROGRAMANDO"},{"location":"I-VM-Lab-1/#funcoes","text":"A linguagem VM possibilita o uso de fun\u00e7\u00f5es, as fun\u00e7\u00f5es s\u00e3o definidas em novos arquivos .vm na mesma pasta do arquivo Main.vm. Por exemplo : Nesse projeto SimpleFunction possu\u00edmos duas fun\u00e7\u00f5es : O Main.vm e a SimpleFunction.vm . A fun\u00e7\u00e3o main deve sempre existir no projeto, e ser\u00e1 a primeira chamada na inicializa\u00e7\u00e3o do sistema (assim como no python e C). Para definirmos uma fun\u00e7\u00e3o em VM basta criarmos um arquivo com a extens\u00e3o .vm (que precisa ter o mesmo nome da fun\u00e7\u00e3o) que ser\u00e1 como uma classe do nosso projeto, podendo conter mais que um m\u00e9todo/fun\u00e7\u00e3o. Note Olhe o exemplo src/vmExamples/StatiTest/ para ver como isso funciona. Uma fun\u00e7\u00e3o \u00e9 definida pela seguinte estrutura : function functionName numberOfVars Onde : function: \u00e9 uma palavra reservado (keyword) para definir fun\u00e7\u00f5es functionName: \u00e9 o nome da fun\u00e7\u00e3o numberOfVars: a quantidade de vari\u00e1veis locais que essa fun\u00e7\u00e3o possui. Como exemplo, vamos transformar a seguinte fun\u00e7\u00e3o em python para vm : def SimpleFunction ( a , b ): aux0 = a + b aux1 = a - b return ( aux1 + aux0 ) Em vm: function SimpleFunction 2 push argument 0 push argument 1 add pop local 0 // aux0 = a + b push argument 0 push argument 1 sub pop local 1 // aux1 = a - b push local 0 push local 1 add // aux0 + aux1 return Essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais, que pode ser acessada pelo segmento local , os par\u00e2metros passados para a fun\u00e7\u00e3o (a e b) s\u00e3o acess\u00edveis pelo segmento argument : push argument 0 acessa o primeiro argumento da fun\u00e7\u00e3o ( a ), trazendo o dado para a pilha. push argument 1 acessa o primeiro argumento da fun\u00e7\u00e3o ( b ), trazendo o dado para a pilha. push/pop temp 0 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux0 ). push/pop temp 1 acessa ou grava na primeiro vari\u00e1vel local da fun\u00e7\u00e3o ( aux1 ). Note que os par\u00e2metros devem ser apenas leitura, n\u00e3o devendo escrever nesses segmentos.","title":"Fun\u00e7\u00f5es"},{"location":"I-VM-Lab-1/#return","text":"A fun\u00e7\u00e3o considera como retorno o \u00faltimo valor da pilha, e sempre retorna um \u00fanico","title":"return"},{"location":"I-VM-Lab-1/#chamada-de-funcao","text":"A chamada de fun\u00e7\u00e3o ocorre na pr\u00f3pria pilha, para isso \u00e9 necess\u00e1rio colocar na pilha os par\u00e2metros da fun\u00e7\u00e3o, no exemplo anterior : a b SP-> e em seguida fazer a chamada de fun\u00e7\u00e3o que possui a seguinte estrutura: call functionName numberOfParameters Onde : call : palavra reservada para chamada de fun\u00e7\u00f5es functioName : nome da fun\u00e7\u00e3o a ser chamada numberOfPar : quantidade de par\u00e2metros que essa fun\u00e7\u00e3o recebe. O exemplo a seguir chama a fun\u00e7\u00e3o SimpleFunction com os valores 5 e 8 function Main.main 0 push constant 5 push constant 8 call SimpleFunction 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"I-VM-Lab-1/#graficamente","text":"","title":"Graficamente"},{"location":"I-VM-Lab-1/#programando_2","text":"Implemente os programas a seguir e teste com testeVm.py . Projetos/I-VM/src/vm/2b-Calculadora Projetos/I-VM/src/vm/2c-Calculadora Projetos/I-VM/src/vm/2d-Calculadora Antes de continuar Escreva os programas e teste.","title":"PROGRAMANDO"},{"location":"I-VM-Projeto/","text":"I - VM \u00b6 Nesse projeto iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator . Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio I-VM-Lab-1 . M\u00f3dulos a serem implementados \u00b6 Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 1c-Dic 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto. Exemplos \u00b6 Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/","title":"Projeto"},{"location":"I-VM-Projeto/#i-vm","text":"Nesse projeto iremos criar programas em VM para o nosso Z01.1, essa entrega \u00e9 individual e n\u00e3o vale nota, mas ser\u00e1 cobrado em prova e servir\u00e1 para voc\u00eas entenderem o pr\u00f3ximo projeto: F-VMTranslator .","title":"I - VM"},{"location":"I-VM-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no laborat\u00f3rio I-VM-Lab-1 .","title":"Instru\u00e7\u00f5es"},{"location":"I-VM-Projeto/#modulos-a-serem-implementados","text":"Os m\u00f3dulos est\u00e3o na pasta Projetos/I-VM/src/vm/ e est\u00e3o organizados por ordem de dificuldade: 1a-Add 1b-Add 1c-Dic 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora Para testar, basta editar o arquivo tests/config.txt com os m\u00f3dulos que deseja executar e ent\u00e3o executar o script: testeVM.py localizado na pasta do projeto.","title":"M\u00f3dulos a serem implementados"},{"location":"I-VM-Projeto/#exemplos","text":"Existem diversos exemplos de programas escritos em linguagem VM, eles est\u00e3o na pasta src/vmExamples/","title":"Exemplos"},{"location":"J-VMtranslator-Lab-1/","text":"Vm Translator \u00b6 O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01. Testando \u00b6 Para testar, basta executar os dois comandos: $. /genJar.py $ ./testeVMtraslator.py O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto J Traduzir o arquivo .vm -> .nasm Para isso foi criado alguns programas ( I-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha : add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110 teste: \u00b6 A seguir uma lista de como cada parte do VMTranslator \u00e9 testado: code.writePushPop \u00b6 pop SimplePopTemp : pop temp ... SimplePopLocal : pop local ... SimplePopThat : pop that ... SimplePopThis : pop this ... push SimplePushConst : push constant .... SimplePushTemp : push tempo .... SimplePushLocal : push local .... SimplePushArg : push argument ... SimplePushThis : push this ... SimplePushThat : push that ... code.writeArithmetic \u00b6 SimpleAdd : add SimpleNeg : neg SimpleSub : sub SimpleEq : eq SimpleGt : gt SimpleLt : lt SimpleAnd : and SimpleOr : or Implementando \u00b6 Vamos agora fazer a implementa\u00e7\u00e3o do comando push constant 3 no VMtranslator. Crie o projeto no IntelliJ da mesma maneira que do projeto H-Assembler o arquivo maven est\u00e1 na pasta J-VMTranslator/VMtranslator Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...). Editando o code.java \u00b6 No code.java encontre a implementa\u00e7\u00e3o do m\u00e9todo push , linha 119 public void writePushPop ( Parser . CommandType command , String segment , Integer index ) { ... ... ... else if ( command == Parser . CommandType . C_PUSH ) { commands . add ( String . format ( \"; %d - PUSH %s %d\" , lineCode ++ , segment , index )); if ( segment . equals ( \"constant\" )) { } Essa m\u00e9todo \u00e9 chamado sempre que um comando push/pop for ser interpretado, exemplo: push constant 3 command: C_PUSH segment: constant Index: 3 Precisamos agora traduzir a execu\u00e7\u00e3o desse comando em vm para nasm , seguindos os passos a seguir: Carregar o valor da constante em um registrador dispon\u00edvel Busca no StackPointer(SP) o endere\u00e7o da posi\u00e7\u00e3o vazia da stack Move o valor do Index (no caso 3) para essa posi\u00e7\u00e3o vazia Incrementa SP em um Exemplo de implementa\u00e7\u00e3o do segundo, deve se adicionar as instru\u00e7\u00f5es na lista de comandos commands . add ( \"leaw $SP,%A\" ); commands . add ( \"movw (%A),%A\" ); Para testar o projeto VMtranslator, n\u00e3o h\u00e1 testes unit\u00e1rios dispon\u00edveis, no entanto, podemos j\u00e1 realizar o teste de integra\u00e7\u00e3o direto (simula\u00e7\u00e3o), usando o testeVMtranslator.py . No caso do push constant , temos o teste SimplePushConst, bastando apenas habilitar este teste na config ( tests/config.txt ). Se observar o arquivo, ir\u00e1 perceber que existem diversos outros testes b\u00e1sicos, como SimplePushLocal , SimplePopLocal e outros ( lista ) que podem ser habilitados conforme forem implementado estes recursos no seu VMtranslator.","title":"17: J VM Translator Lab 1"},{"location":"J-VMtranslator-Lab-1/#vm-translator","text":"O VMTranslator \u00e9 um programa escrito em Java que faz a tradu\u00e7\u00e3o de c\u00f3digos escrito na linguagem VM definida no curso e traduz para linguagem Assembly do computador Z01.","title":"Vm Translator"},{"location":"J-VMtranslator-Lab-1/#testando","text":"Para testar, basta executar os dois comandos: $. /genJar.py $ ./testeVMtraslator.py O teste executa: genJAR.py | | V VMTranslator Assembler Z01-Simulator ------------------ arquivo.vm -------------> .nasm -----------> .hack > ------------> - Verifica sa\u00edda - ------------------ ^ | |- Desenvolvido no projeto J Traduzir o arquivo .vm -> .nasm Para isso foi criado alguns programas ( I-VM/src/vmExamples/ ) em VM muito espec\u00edficos que testam somente um comando, ou uma parte da tradu\u00e7\u00e3o do VMTranslator . Por exemplo o teste SimpleAdd possui somente a seguinte linha : add Esse teste foi criado para testar o Code.writeArithmetic no caso de um comando add . Para isso, antes da execu\u00e7\u00e3o desse c\u00f3digo, o simulador faz a inicializa\u00e7\u00e3o da RAM, simulando valores na pilha e j\u00e1 configurando o SP para uma situa\u00e7\u00e3o real. A mem\u00f3ria antes da execu\u00e7\u00e3o da instru\u00e7\u00e3o add \u00e9 a seguinte: 0 : 0000000100000010; 256 : 0000000000000010; 257 : 0000000000000100; 258 : 0000000000000000; Note I-VM/tests/tst/SimpleAdd/SimpleAdd0_in.mif Espera-se o resultado final ap\u00f3s a execu\u00e7\u00e3o do comando add : 0 : 0000000100000001 256 : 0000000000000110","title":"Testando"},{"location":"J-VMtranslator-Lab-1/#teste","text":"A seguir uma lista de como cada parte do VMTranslator \u00e9 testado:","title":"teste:"},{"location":"J-VMtranslator-Lab-1/#codewritepushpop","text":"pop SimplePopTemp : pop temp ... SimplePopLocal : pop local ... SimplePopThat : pop that ... SimplePopThis : pop this ... push SimplePushConst : push constant .... SimplePushTemp : push tempo .... SimplePushLocal : push local .... SimplePushArg : push argument ... SimplePushThis : push this ... SimplePushThat : push that ...","title":"code.writePushPop"},{"location":"J-VMtranslator-Lab-1/#codewritearithmetic","text":"SimpleAdd : add SimpleNeg : neg SimpleSub : sub SimpleEq : eq SimpleGt : gt SimpleLt : lt SimpleAnd : and SimpleOr : or","title":"code.writeArithmetic"},{"location":"J-VMtranslator-Lab-1/#implementando","text":"Vamos agora fazer a implementa\u00e7\u00e3o do comando push constant 3 no VMtranslator. Crie o projeto no IntelliJ da mesma maneira que do projeto H-Assembler o arquivo maven est\u00e1 na pasta J-VMTranslator/VMtranslator Nesse projeto voc\u00eas ter\u00e3o que mexer apenas no code.java , os demais m\u00f3dulos j\u00e1 est\u00e3o prontos (similar ao projeto do Assembler, temos nesse o parser , VMTranslator , ...).","title":"Implementando"},{"location":"J-VMtranslator-Lab-1/#editando-o-codejava","text":"No code.java encontre a implementa\u00e7\u00e3o do m\u00e9todo push , linha 119 public void writePushPop ( Parser . CommandType command , String segment , Integer index ) { ... ... ... else if ( command == Parser . CommandType . C_PUSH ) { commands . add ( String . format ( \"; %d - PUSH %s %d\" , lineCode ++ , segment , index )); if ( segment . equals ( \"constant\" )) { } Essa m\u00e9todo \u00e9 chamado sempre que um comando push/pop for ser interpretado, exemplo: push constant 3 command: C_PUSH segment: constant Index: 3 Precisamos agora traduzir a execu\u00e7\u00e3o desse comando em vm para nasm , seguindos os passos a seguir: Carregar o valor da constante em um registrador dispon\u00edvel Busca no StackPointer(SP) o endere\u00e7o da posi\u00e7\u00e3o vazia da stack Move o valor do Index (no caso 3) para essa posi\u00e7\u00e3o vazia Incrementa SP em um Exemplo de implementa\u00e7\u00e3o do segundo, deve se adicionar as instru\u00e7\u00f5es na lista de comandos commands . add ( \"leaw $SP,%A\" ); commands . add ( \"movw (%A),%A\" ); Para testar o projeto VMtranslator, n\u00e3o h\u00e1 testes unit\u00e1rios dispon\u00edveis, no entanto, podemos j\u00e1 realizar o teste de integra\u00e7\u00e3o direto (simula\u00e7\u00e3o), usando o testeVMtranslator.py . No caso do push constant , temos o teste SimplePushConst, bastando apenas habilitar este teste na config ( tests/config.txt ). Se observar o arquivo, ir\u00e1 perceber que existem diversos outros testes b\u00e1sicos, como SimplePushLocal , SimplePopLocal e outros ( lista ) que podem ser habilitados conforme forem implementado estes recursos no seu VMtranslator.","title":"Editando o code.java"},{"location":"J-VMtranslator-Projeto/","text":"Nesse projeto iremos criar o programa VM translator que \u00e9 respons\u00e1vel por traduzir os c\u00f3digos escrito em linguagem VM de pilha para a linguagem assembly. Instru\u00e7\u00f5es \u00b6 As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no lab 17, parte 1 e parte 2 M\u00f3dulos a serem implementados \u00b6 Apenas o Code.java . O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo VMTranslator.java , VMtranslate.java , Parser.java e Error.java j\u00e1 est\u00e3o foram entregues implementados. Os m\u00f3dulos est\u00e3o listados de maneira Top - Down VMTranslator Arquivo : VMTranslator.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .vm (ou diret\u00f3rio) e o nome do arquivo bin\u00e1rio assembly ( .nasm ) a ser escrito, passa essas informa\u00e7\u00f5es para a classe VMtranslate. Depend\u00eancias : VMtranslate.java VMtranslate Arquivo : VMtranslate.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo assembly, ela que efetivamente faz a varredura do arquivo .vm de entrada e escreve o arquivo .nasm de sa\u00edda, gerando a tradu\u00e7\u00e3o vm -> nasm. Depend\u00eancias : Code.java , Parser.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz comandos da linguagem vm para os comandos em nasm que a executam. Depend\u00eancias : None Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem vm, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none Sugest\u00e3o de implementa\u00e7\u00e3o (partes) \u00b6 Sugerimos que o VMTranslator seja implementado em duas partes, a primeira implementa somente o Parser.java e opera\u00e7\u00f5es aritm\u00e9ticas e push/pop . A segunda parte faz a implementa\u00e7\u00e3o de fun\u00e7\u00f5es, goto e chamada de fun\u00e7\u00f5es. Parte 1 - Conceito C \u00b6 Code.writeArithmetic() Code.writePushPop() Parte 2 - Conceito B \u00b6 Code.writeGoto() Code.writeIf() Parte 3 - Conceito A Code.writeCall() Code.writeReturn() Code.writeFunction() Rubricas para avalia\u00e7\u00e3o de projetos \u00b6 Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel). Projeto \u00b6 Conceito I - Menos da metade dos m\u00f3dulos funcionando D - writeArithmetic OU writePushPop C - writeArithmetic E writePushPop B - writeLabel, writeGoto, writeIf A - writeCall, writeReturn, writeFunction Para testar \u00b6 A seguir os testes que devem passar para cada nota : C \u00b6 SimpleAdd SimpleNeg SimpleSub SimpleEq SimpleGt SimpleLt SimpleAnd SimpleOr SimplePushConst SimplePushTemp SimplePushLocal SimplePushArg SimplePushThis SimplePushThat SimplePopTemp SimplePopLocal SimplePopThat SimplePopThis SimplePushAdd SimplePopPointer StackTest (opcional) B \u00b6 BasicLoop A \u00b6 SimpleFunction StaticsTest Mult 1a-Add 1b-Add 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora SimpleGoto SimpleIfGoto","title":"Projeto"},{"location":"J-VMtranslator-Projeto/#instrucoes","text":"As instru\u00e7\u00f5es t\u00e9cnicas referente ao projeto est\u00e3o no lab 17, parte 1 e parte 2","title":"Instru\u00e7\u00f5es"},{"location":"J-VMtranslator-Projeto/#modulos-a-serem-implementados","text":"Apenas o Code.java . O projeto no total possui 5 m\u00f3dulos, sendo que o m\u00f3dulo VMTranslator.java , VMtranslate.java , Parser.java e Error.java j\u00e1 est\u00e3o foram entregues implementados. Os m\u00f3dulos est\u00e3o listados de maneira Top - Down VMTranslator Arquivo : VMTranslator.java Descri\u00e7\u00e3o : Main do projeto. Recebe como par\u00e2metro o nome do arquivo .vm (ou diret\u00f3rio) e o nome do arquivo bin\u00e1rio assembly ( .nasm ) a ser escrito, passa essas informa\u00e7\u00f5es para a classe VMtranslate. Depend\u00eancias : VMtranslate.java VMtranslate Arquivo : VMtranslate.java Descri\u00e7\u00e3o : Classe respons\u00e1vel por criar o c\u00f3digo assembly, ela que efetivamente faz a varredura do arquivo .vm de entrada e escreve o arquivo .nasm de sa\u00edda, gerando a tradu\u00e7\u00e3o vm -> nasm. Depend\u00eancias : Code.java , Parser.java Code Arquivo : Code.java Descri\u00e7\u00e3o : Traduz comandos da linguagem vm para os comandos em nasm que a executam. Depend\u00eancias : None Parser Arquivo : Parser.java Descri\u00e7\u00e3o : Encapsula o c\u00f3digo de leitura. Carrega as instru\u00e7\u00f5es na linguagem vm, analisa, e oferece acesso as partes da instru\u00e7\u00e3o (campos e s\u00edmbolos). Al\u00e9m disso, remove todos os espa\u00e7os em branco e coment\u00e1rios. Depend\u00eancias : none","title":"M\u00f3dulos a serem implementados"},{"location":"J-VMtranslator-Projeto/#sugestao-de-implementacao-partes","text":"Sugerimos que o VMTranslator seja implementado em duas partes, a primeira implementa somente o Parser.java e opera\u00e7\u00f5es aritm\u00e9ticas e push/pop . A segunda parte faz a implementa\u00e7\u00e3o de fun\u00e7\u00f5es, goto e chamada de fun\u00e7\u00f5es.","title":"Sugest\u00e3o de implementa\u00e7\u00e3o (partes)"},{"location":"J-VMtranslator-Projeto/#parte-1-conceito-c","text":"Code.writeArithmetic() Code.writePushPop()","title":"Parte 1 - Conceito C"},{"location":"J-VMtranslator-Projeto/#parte-2-conceito-b","text":"Code.writeGoto() Code.writeIf() Parte 3 - Conceito A Code.writeCall() Code.writeReturn() Code.writeFunction()","title":"Parte 2 - Conceito B"},{"location":"J-VMtranslator-Projeto/#rubricas-para-avaliacao-de-projetos","text":"Cada integrante do grupo ir\u00e1 receber duas notas: uma referente ao desenvolvimento total do projeto (Projeto) e outra referente a sua participa\u00e7\u00e3o individual no grupo (que depende do seu papel).","title":"Rubricas para avalia\u00e7\u00e3o de projetos"},{"location":"J-VMtranslator-Projeto/#projeto","text":"Conceito I - Menos da metade dos m\u00f3dulos funcionando D - writeArithmetic OU writePushPop C - writeArithmetic E writePushPop B - writeLabel, writeGoto, writeIf A - writeCall, writeReturn, writeFunction","title":"Projeto"},{"location":"J-VMtranslator-Projeto/#para-testar","text":"A seguir os testes que devem passar para cada nota :","title":"Para testar"},{"location":"J-VMtranslator-Projeto/#c","text":"SimpleAdd SimpleNeg SimpleSub SimpleEq SimpleGt SimpleLt SimpleAnd SimpleOr SimplePushConst SimplePushTemp SimplePushLocal SimplePushArg SimplePushThis SimplePushThat SimplePopTemp SimplePopLocal SimplePopThat SimplePopThis SimplePushAdd SimplePopPointer StackTest (opcional)","title":"C"},{"location":"J-VMtranslator-Projeto/#b","text":"BasicLoop","title":"B"},{"location":"J-VMtranslator-Projeto/#a","text":"SimpleFunction StaticsTest Mult 1a-Add 1b-Add 2a-Calculadora 2b-Calculadora 2c-Calculadora 2d-Calculadora SimpleGoto SimpleIfGoto","title":"A"},{"location":"J-VMtranslator-memoria/","text":"Fun\u00e7\u00e3o \u00b6 Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. O ARG indica em qual endere\u00e7o da stack os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 usado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais da fun\u00e7\u00e3o. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o primeiro argumento colocado na stack \u00e9 o de index 0 Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar as vari\u00e1veis locais Atualiza os ponteiros: SP, LCL, ARG, THIS e THAT O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha, NA ORDEM A SEGUIR: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o) LCL - Local \u00b6 Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais: aux0 e aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis ( aux0 , aux1 ) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir : O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira: function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n endere\u00e7o local n = LCL + n ARG - Argumento \u00b6 O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Os ARG s\u00e3o salvos na pr\u00f3pria pilha, antes da chamada da fun\u00e7\u00e3o: pilha comando VM endere\u00e7os -------------------------------------------- 12 | call mult 2 | 12 <- ARG 13 | | 13 SP -> | |----\\ | | |----/ | Exemplo Stack chamada de fun\u00e7\u00e3o \u00b6 258 : SP 265 : SP 257 : SP 333 : LCL 263 : LCL 333 : LCL 444 : ARG call mult 2 256 : ARG return 444 : ARG 555 : THIS |----\\ 555 : THIS |----\\ 555 : THIS 666 : THAT |----/ 666 : THAT |----/ 666 : THAT ~~~~~~~~~~~~ ~~~~~~~~~~~ ~~~~~~~~~~~~ 8 : 256 8 : 256 <- LCL 32 : 256 4 : 257 4 : 257 4 : 257 <- SP 0 : 258 <- SP 256 : 258 : RETURN 0 : 258 333 : 259 : LCL 444 : 260 : ARG 555 : 261 : THIS 666 : 262 : THAT 0 : 263 <- LCL 0 : 264 0 : 265 <- SP Static variables \u00b6 \u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/ HEAP \u00b6 O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria. This \u00b6 This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm That \u00b6 O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir : M\u00e9todo objetoCeleste : void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal : void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM ? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"VM Fun\u00e7\u00e3o"},{"location":"J-VMtranslator-memoria/#funcao","text":"Os ponteiros LCL e ARG s\u00e3o utilizados somente na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. O ARG indica em qual endere\u00e7o da stack os par\u00e2metros que ser\u00e3o passados para a fun\u00e7\u00e3o est\u00e3o salvos e o LCL \u00e9 usado para apontar para o endere\u00e7o na pilha utilizado para armazenar vari\u00e1veis locais da fun\u00e7\u00e3o. O fluxo de chamada de fun\u00e7\u00e3o, de forma simplificada \u00e9: Coloca na pilha os argumentos que ser passado para a fun\u00e7\u00e3o a quantidade varia conforme a demanda da fun\u00e7\u00e3o primeiro argumento colocado na stack \u00e9 o de index 0 Chama a fun\u00e7\u00e3o ( call ) Aloca na pilha os endere\u00e7os de mem\u00f3ria para armazenar as vari\u00e1veis locais Atualiza os ponteiros: SP, LCL, ARG, THIS e THAT O fluxo de chamada de fun\u00e7\u00e3o (call) \u00e9 um pouco complexo, pois demanda que salvemos algumas informa\u00e7\u00f5es da pilha antes de executarmos a fun\u00e7\u00e3o (precisamos conseguir ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o retornar para um estado similar antes da execu\u00e7\u00e3o). Para isso \u00e9 salvo na pilha, NA ORDEM A SEGUIR: Endere\u00e7o de retorno LCL (antes da chamada de fun\u00e7\u00e3o) ARG (antes da chamada de fun\u00e7\u00e3o) This (antes da chamada de fun\u00e7\u00e3o) That (antes da chamada de fun\u00e7\u00e3o)","title":"Fun\u00e7\u00e3o"},{"location":"J-VMtranslator-memoria/#lcl-local","text":"Local indica o endere\u00e7o na pilha na qual foi alocado para as vari\u00e1veis locais de uma fun\u00e7\u00e3o, a quantidade de endere\u00e7os alocados varia conforme a declara\u00e7\u00e3o da fun\u00e7\u00e3o, que pode possuir zero ou mais vari\u00e1veis tempor\u00e1rias. Peguemos como exemplo uma fun\u00e7\u00e3o em java : void example(int a, int b){ int aux0; int aux1; aux0 = a; aux1 = b; } Note que essa fun\u00e7\u00e3o possui duas vari\u00e1veis locais: aux0 e aux1 , que s\u00e3o vis\u00edveis somente dentro do escopo da fun\u00e7\u00e3o, essas vari\u00e1veis s\u00e3o alocadas quando a fun\u00e7\u00e3o \u00e9 chamada e desalocada quando a fun\u00e7\u00e3o retorna. Essas vari\u00e1veis ( aux0 , aux1 ) servem como vari\u00e1veis locais da fun\u00e7\u00e3o, e s\u00e3o salvas na stack, como a ilustra\u00e7\u00e3o a seguir : O exemplo em java anterior seria traduzido para a linguagem VM (de forma imediata) na seguinte maneira: function example 2 push argument 0 // coloca na pilha o valor a pop local 0 // aux0 = a push argument 1 // coloca na pilha o valor b pop local 1 // aux1 = b Note que o que define local 0 e local 1 \u00e9 a ordem na qual as vari\u00e1veis foram declaradas, como a vari\u00e1vel aux0 foi declarada primeiro, ela \u00e9 alocada no local 0 . O LCL aponta apenas para o endere\u00e7o do primeiro local , os demais s\u00e3o inferidos da seguinte maneira: push local n endere\u00e7o local n = LCL + n","title":"LCL - Local"},{"location":"J-VMtranslator-memoria/#arg-argumento","text":"O ponteiro ARG indica a onde na pilha est\u00e3o salvos os argumentos que a fun\u00e7\u00e3o pode acessar, e segue a mesma l\u00f3gica do LCL, onde o ARG aponta para o primeiro argumento e o endere\u00e7o dos demais s\u00e3o inferidos com base no endere\u00e7o do primeiro. Os ARG s\u00e3o salvos na pr\u00f3pria pilha, antes da chamada da fun\u00e7\u00e3o: pilha comando VM endere\u00e7os -------------------------------------------- 12 | call mult 2 | 12 <- ARG 13 | | 13 SP -> | |----\\ | | |----/ |","title":"ARG - Argumento"},{"location":"J-VMtranslator-memoria/#exemplo-stack-chamada-de-funcao","text":"258 : SP 265 : SP 257 : SP 333 : LCL 263 : LCL 333 : LCL 444 : ARG call mult 2 256 : ARG return 444 : ARG 555 : THIS |----\\ 555 : THIS |----\\ 555 : THIS 666 : THAT |----/ 666 : THAT |----/ 666 : THAT ~~~~~~~~~~~~ ~~~~~~~~~~~ ~~~~~~~~~~~~ 8 : 256 8 : 256 <- LCL 32 : 256 4 : 257 4 : 257 4 : 257 <- SP 0 : 258 <- SP 256 : 258 : RETURN 0 : 258 333 : 259 : LCL 444 : 260 : ARG 555 : 261 : THIS 666 : 262 : THAT 0 : 263 <- LCL 0 : 264 0 : 265 <- SP","title":"Exemplo Stack chamada de fun\u00e7\u00e3o"},{"location":"J-VMtranslator-memoria/#static-variables","text":"\u00c9 a regi\u00e3o da mem\u00f3ria utilizada para armazenar vari\u00e1veis compartilhadas entre o mesmo arquivo .vm, conforme figura a seguir : A static n\u00e3o \u00e9 vis\u00edvel entre diferentes arquivos .vm, deixando as vari\u00e1veis limitadas a um escopo. O static ser\u00e1 utilizado para armazenar as vari\u00e1veis est\u00e1ticas de uma determinada classe. Exemplo de acesso ao static : O exemplo a seguir demonstra duas classes (class1.vm e class2.vm) sendo utilizadas com os seus respectivos stacks. Nesse exemplo, a fun\u00e7\u00e3o main inicializa o static da classe 1 em : static[0] = 6, static[1] = 8 e o static ca classe 2 em : static[0] = 23, static[0] = 15. Isso ser\u00e1 bastante utilizado para fazer a implementa\u00e7\u00e3o da estrutura a seguir : public class class1 { static int valor0 ; // alocado no static 0 static int valor1 ; // alocado no static 1 public void set ( int var1 , va2 ){ valor0 = var1 ; valor1 = var2 ; } public void get ( void ){ return ( valor0 - valor1 ); } As vari\u00e1veis est\u00e1ticas s\u00e3o compartilhadas entre os objetos inicializados a partir da mesma classe, alocando assim apenas um slot de mem\u00f3ria para todos os objetos criados a partir dessa classe ^1. ^1: https://beginnersbook.com/2013/05/static-variable/","title":"Static variables"},{"location":"J-VMtranslator-memoria/#heap","text":"O HEAP \u00e9 a regi\u00e3o de mem\u00f3ria a ser utilizada para armazenamento objetos e vetores, um objeto ser\u00e1 constru\u00eddo a partir de uma classe e compartilhar\u00e1 as mesma vari\u00e1veis est\u00e1ticas mas n\u00e3o as mesmas vari\u00e1veis locais ao objeto. Vamos tomar como ponto de partida o exemplo a seguir que inicializa dois objetos (terra e lua) do tipo corpoCeleste : void main (){ corpoCeleste terra = new corpoCeletes (); terra . setMassa ( 1200 ); corpoCeleste lua = new corpoCeleste (); lua . setMassa ( 32 ); lua . pi = 314 ; } public class corpoCeleste (){ static int pi ; int raio ; int gravidade ; int massa ; void getMassa (){ return ( this . massa ); } void setMassa ( int m ){ this . massa = m ; } } Esse exemplo aloca no Heap tr\u00eas endere\u00e7os em locais diferentes para cada objeto criado do tipo corpoCeleste, por\u00e9m a vari\u00e1vel pi , que \u00e9 est\u00e1tica \u00e9 comum a todos os objetos criados a partir da mesma classe. A figura a seguir ilustra como essas vari\u00e1veis seriam alocadas em mem\u00f3ria.","title":"HEAP"},{"location":"J-VMtranslator-memoria/#this","text":"This \u00e9 o ponteiro que refer\u00eancia o pr\u00f3prio objeto: objeto na qual o m\u00e9todo ou construtor est\u00e1 sendo chamado. No caso da chamada do m\u00e9todo getMassa() da classe corpoCeleste, o ponteiro This ser\u00e1 ajustado para apontar para o objeto na qual o m\u00e9todo foi chamado. O fluxo da m\u00e1quina virtual ser\u00e1 o seguinte : Ajusta o this para apontar para o in\u00edcio do HEAP pertencente ao objeto chama a fun\u00e7\u00e3o getMassa do arquivo corpoCeleste.vm","title":"This"},{"location":"J-VMtranslator-memoria/#that","text":"O ponteiro That \u00e9 utilizado para referenciar outro objeto, utilizado no exemplo a seguir : M\u00e9todo objetoCeleste : void compareMassa ( corpoCeleste outro ){ if ( this . massa == outro . massa ){ return ( True ); } else { return ( False ); } } C\u00f3digo principal : void main (){ ... rtn = terra . compareMassa ( lua ); } Nesse exemplo, inclu\u00edmos um novo m\u00e9todo (compareMass) na classe corpoCeleste, esse novo m\u00e9todo compara a massa de um outro objeto com a do pr\u00f3prio objeto, retornando verdadeiro ou falso dependendo do resultado. Como esse c\u00f3digo seria traduzido para VM ? O objeto em quest\u00e3o ser\u00e1 acessado utilizando o ponteiro this e o objeto a ser comparado ser\u00e1 acessado via o that . O compilador da linguagem de alto n\u00edvel para VM ser\u00e1 respons\u00e1vel por alocar os objetos nos endere\u00e7os certos. function main 0 ... push constant 2048 // endere\u00e7o objeto terra push constant 2051 // endere\u00e7o objeto lua call cortpoCeleste.compare mass 2 function corpoCeleste.compareMass 0 push argument 0 pop pointer 0 // atualiza endere\u00e7o this push argument 1 pop pointer 1 // atualiza endere\u00e7o that push this 2 // this 0 = gravidade; this 1 = raio; this 2 = massa push that 2 // that 0 = gravidade; this 1 = raio; this 2 = massa eq return Note que quando o m\u00e9todo for chamado (no caso da vm o m\u00e9todo ser\u00e1 traduzido para uma fun\u00e7\u00e3o), os ponteiros this e that devem ser passados via a chama da fun\u00e7\u00e3o, e no come\u00e7o da fun\u00e7\u00e3o atualizado os endere\u00e7os RAM[3] - This e RAM[4] - That.","title":"That"},{"location":"Sobre-Criterios-de-Avaliacao/","text":"Descri\u00e7\u00e3o \u00b6 Ao longo do semestre ser\u00e3o utilizados os seguintes crit\u00e9rios de avalia\u00e7\u00e3o: Provas \u00b6 Ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre. Projetos / APS \u00b6 O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso. Rubricas Individual \u00b6 Desenvolvedor Conceito Insatisfat\u00f3rio (I) - Se comprometeu a fazer algum desenvolvimento (kanban) e n\u00e3o fez. - Criou o branch mas n\u00e3o fez o desenvolvimento completo. - N\u00e3o trabalhou ativamente no projeto (avalia\u00e7\u00e3o cruzada / Facilitador) - N\u00e3o cumpriu com os itens do A Satisfat\u00f3rio (A) - Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! - Acompanhou o Kanban board (github project). Ex: Puxou tarefas, etc. - Submeteu altera\u00e7\u00f5es por pull requests. Facilitador Conceito Insatisfat\u00f3rio (I) - N\u00e3o acompanhou o projeto, deixando os colegas sozinhos. - Avaliado pelos pr\u00f3prios colegas - O relat\u00f3rio das atividades n\u00e3o \u00e9 condizente com o real desempenho dos integrantes (analisado via git). - N\u00e3o participou das duas aulas referentes ao projeto - N\u00e3o cumpriu com os itens do A Satisfat\u00f3rio (A) - Atualizou o reposit\u00f3rio pelo Fork. - Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, da feedback de inssues. - Aceitou os pull-requests. - Resolveu conflitos de merge nos pull requests. - Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio - Entregou o branch master sem nenhum erro (passando no travis) - Fez o relat\u00f3rio das atividades descrevendo o papel de cada integrante com clareza. Crit\u00e9rios \u00b6 Os alunos devem: Ter acumulado 60 pontos de HW nas provas Ter acumulado 60 pontos de SW nas provas Ter no m\u00ednimo conceito C no quesito Grupo em todos os Projetos. Ter ate duas notas inferiores a C na avalia\u00e7\u00e3o individual do projeto ( Individual ). Uma vez que os crit\u00e9rios foram atingidos: Projeto \u00b6 A nota de projeto \u00e9 constitu\u00edda por todas as notas de APS de projetos sendo o conceito final definido por: A: 9 das APS de projetos com nota A e as demais com nota superior a C e nenhuma contribui\u00e7\u00e3o individual negativa nos projetos. B: 8 das APS de projetos com nota igual ou superior a B e as demais com nota igual ou superior a C e apenas uma contribui\u00e7\u00e3o negativa nos projetos. C: 12 das APS de projetos com nota igual ou superior a C e at\u00e9 duas contribui\u00e7\u00f5es negativas. D: At\u00e9 uma nota abaixo de C nas APS de projetos ou mais de duas contribui\u00e7\u00f5es negativas. I: At\u00e9 quatro notas abaixo de C nas APS de projetos ou mais que seis contribui\u00e7\u00f5es negativas. Nota final \u00b6 A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([HW, SW, Projeto])","title":"Crit\u00e9rios de Avalia\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#descricao","text":"Ao longo do semestre ser\u00e3o utilizados os seguintes crit\u00e9rios de avalia\u00e7\u00e3o:","title":"Descri\u00e7\u00e3o"},{"location":"Sobre-Criterios-de-Avaliacao/#provas","text":"Ao longo do semestre o aluno deve acumular 60 pontos de Software e 60 pontos de Hardware esses pontos estar\u00e3o distribu\u00eddos nas quatro provas (P1,P2,P3,P4) que ser\u00e3o aplicadas ao longo do semestre.","title":"Provas"},{"location":"Sobre-Criterios-de-Avaliacao/#projetos-aps","text":"O projeto \u00e9 composto por duas notas: Grupo e Individual sendo que cada uma segue uma rubrica diferente e avalia objetivo diferentes do curso.","title":"Projetos / APS"},{"location":"Sobre-Criterios-de-Avaliacao/#rubricas-individual","text":"Desenvolvedor Conceito Insatisfat\u00f3rio (I) - Se comprometeu a fazer algum desenvolvimento (kanban) e n\u00e3o fez. - Criou o branch mas n\u00e3o fez o desenvolvimento completo. - N\u00e3o trabalhou ativamente no projeto (avalia\u00e7\u00e3o cruzada / Facilitador) - N\u00e3o cumpriu com os itens do A Satisfat\u00f3rio (A) - Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! - Acompanhou o Kanban board (github project). Ex: Puxou tarefas, etc. - Submeteu altera\u00e7\u00f5es por pull requests. Facilitador Conceito Insatisfat\u00f3rio (I) - N\u00e3o acompanhou o projeto, deixando os colegas sozinhos. - Avaliado pelos pr\u00f3prios colegas - O relat\u00f3rio das atividades n\u00e3o \u00e9 condizente com o real desempenho dos integrantes (analisado via git). - N\u00e3o participou das duas aulas referentes ao projeto - N\u00e3o cumpriu com os itens do A Satisfat\u00f3rio (A) - Atualizou o reposit\u00f3rio pelo Fork. - Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, da feedback de inssues. - Aceitou os pull-requests. - Resolveu conflitos de merge nos pull requests. - Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio - Entregou o branch master sem nenhum erro (passando no travis) - Fez o relat\u00f3rio das atividades descrevendo o papel de cada integrante com clareza.","title":"Rubricas Individual"},{"location":"Sobre-Criterios-de-Avaliacao/#criterios","text":"Os alunos devem: Ter acumulado 60 pontos de HW nas provas Ter acumulado 60 pontos de SW nas provas Ter no m\u00ednimo conceito C no quesito Grupo em todos os Projetos. Ter ate duas notas inferiores a C na avalia\u00e7\u00e3o individual do projeto ( Individual ). Uma vez que os crit\u00e9rios foram atingidos:","title":"Crit\u00e9rios"},{"location":"Sobre-Criterios-de-Avaliacao/#projeto","text":"A nota de projeto \u00e9 constitu\u00edda por todas as notas de APS de projetos sendo o conceito final definido por: A: 9 das APS de projetos com nota A e as demais com nota superior a C e nenhuma contribui\u00e7\u00e3o individual negativa nos projetos. B: 8 das APS de projetos com nota igual ou superior a B e as demais com nota igual ou superior a C e apenas uma contribui\u00e7\u00e3o negativa nos projetos. C: 12 das APS de projetos com nota igual ou superior a C e at\u00e9 duas contribui\u00e7\u00f5es negativas. D: At\u00e9 uma nota abaixo de C nas APS de projetos ou mais de duas contribui\u00e7\u00f5es negativas. I: At\u00e9 quatro notas abaixo de C nas APS de projetos ou mais que seis contribui\u00e7\u00f5es negativas.","title":"Projeto"},{"location":"Sobre-Criterios-de-Avaliacao/#nota-final","text":"A nota final ser\u00e1 composta pela nota de Projeto e a nota da Prova: Nota Final = mean([HW, SW, Projeto])","title":"Nota final"},{"location":"Sobre-Objetivos-de-Aprendizagem/","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Implementar um computador digital simples a partir de componentes eletr\u00f4nicos. Integrar as camadas de programa\u00e7\u00e3o e execu\u00e7\u00e3o de um computador simples. Trabalhar de forma colaborativa no desenvolvimento de um sistema computacional. Compreender a evolu\u00e7\u00e3o da inform\u00e1tica. Descrever como dados e instru\u00e7\u00f5es s\u00e3o armazenados e tratados em computadores. Conte\u00fado Program\u00e1tico: L\u00f3gica Combinacional Unidade L\u00f3gica Aritm\u00e9tica L\u00f3gica Sequencial L\u00f3gica de Controle Linguagem de M\u00e1quinas Assembly Assembler M\u00e1quina Virtual Controle de programa Linguagem Orientada a Objetos An\u00e1lise L\u00e9xica e Sint\u00e1tica Linguagens","title":"Sobre Objetivos de Aprendizagem"},{"location":"Sobre-Rubricas/","text":"Rubricas a serem usadas para os papeis: Facilitador e Desenvolvedor Desenvolvedor \u00b6 Conceito Insatisfat\u00f3rio (I) - Se comprometeu a fazer algum desenvolvimento (kanban) e n\u00e3o fez. - Criou o branch mas n\u00e3o fez o desenvolvimento completo. Satisfat\u00f3rio (A) - Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! - Acompanhou o Kanban board (github project). Ex: Puxou tarefas, etc. - Submeteu altera\u00e7\u00f5es por pull requests. Facilitador \u00b6 Conceito Insatisfat\u00f3rio (I) - N\u00e3o acompanhou o projeto, deixando os colegas sozinhos. - O relat\u00f3rio das atividades n\u00e3o \u00e9 condizente com o real desempenho dos integrantes (analisado via git). Satisfat\u00f3rio (A) - Atualizou o reposit\u00f3rio pelo Fork. - Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, da feedback de inssues. - Aceitou os pull-requests. - Resolveu conflitos de merge nos pull requests. - Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio - Entregou o branch master sem nenhum erro (passando no travis) - Fez o relat\u00f3rio das atividades descrevendo o papel de cada integrante com clareza.","title":"Rubricas Projetos"},{"location":"Sobre-Rubricas/#desenvolvedor","text":"Conceito Insatisfat\u00f3rio (I) - Se comprometeu a fazer algum desenvolvimento (kanban) e n\u00e3o fez. - Criou o branch mas n\u00e3o fez o desenvolvimento completo. Satisfat\u00f3rio (A) - Desenvolveu as rotinas atribu\u00eddas pelo Facilitador para passarem nos testes! - Acompanhou o Kanban board (github project). Ex: Puxou tarefas, etc. - Submeteu altera\u00e7\u00f5es por pull requests.","title":"Desenvolvedor"},{"location":"Sobre-Rubricas/#facilitador","text":"Conceito Insatisfat\u00f3rio (I) - N\u00e3o acompanhou o projeto, deixando os colegas sozinhos. - O relat\u00f3rio das atividades n\u00e3o \u00e9 condizente com o real desempenho dos integrantes (analisado via git). Satisfat\u00f3rio (A) - Atualizou o reposit\u00f3rio pelo Fork. - Fez a manuten\u00e7\u00e3o do Kanban board (GitHub project). Ex: cria cards, atribui tarefas, da feedback de inssues. - Aceitou os pull-requests. - Resolveu conflitos de merge nos pull requests. - Acompanhou o desenvolvimento do grupo, dando o suporte sempre que necess\u00e1rio - Entregou o branch master sem nenhum erro (passando no travis) - Fez o relat\u00f3rio das atividades descrevendo o papel de cada integrante com clareza.","title":"Facilitador"},{"location":"Util-Aulas/","text":"Resumo Aulas \u00b6 CPU \u00b6 Laborat\u00f3rios G CPU Lab 14 Projeto associado G CPU Projeto Dicas testando Dicas rubrica B Assembly \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Slides Handout Lista Conte\u00fado Laborat\u00f3rios F Assembly Lab 11 F Assembly Lab 12 F Assembly Lab 13 Projeto associado F Assembly Projeto Leitura Cap\u00edtulo 7 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf L\u00f3gica Sequencial \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio E Sequencial Lab 1 Projeto associado E Sequencial Projeto Leitura Cap\u00edtulo 3 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_862828b3a3464a809cda6f44d9ad2ec9.pdf Unidade L\u00f3gica Aritm\u00e9tica \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rios D ULA Lab 2 D ULA Lab 1 Projeto associado D ULA Projeto Leitura Cap\u00edtulo 2 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf L\u00f3gica Combinacional \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio 4 Laborat\u00f3rio 5 Laborat\u00f3rio 6 Laborat\u00f3rio 7 Transistores e Circuitos Integrados \u00b6 04 - Circuitos Integrados Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado sobre Circuitos Integrados 03 - Transistores Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Transistores MOSFET V\u00eddeos Extra Transistor Logic Gates Livros [Cap. 8 TOCCI, 2011] [Cap 7. FLOYD, 2007] \u00c1lgebra Booleana \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado de \u00c1lgebra Booleana V\u00eddeos Extra Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Livros [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004] Organiza\u00e7\u00e3o de Computadores \u00b6 Sala Sala Casa V\u00eddeo aula Slides Handout Lista V\u00eddeos Extra Khan Academy - Introducing How Computers Work","title":"Aulas"},{"location":"Util-Aulas/#resumo-aulas","text":"","title":"Resumo Aulas"},{"location":"Util-Aulas/#cpu","text":"Laborat\u00f3rios G CPU Lab 14 Projeto associado G CPU Projeto Dicas testando Dicas rubrica B","title":"CPU"},{"location":"Util-Aulas/#assembly","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Slides Handout Lista Conte\u00fado Laborat\u00f3rios F Assembly Lab 11 F Assembly Lab 12 F Assembly Lab 13 Projeto associado F Assembly Projeto Leitura Cap\u00edtulo 7 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf","title":"Assembly"},{"location":"Util-Aulas/#logica-sequencial","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio E Sequencial Lab 1 Projeto associado E Sequencial Projeto Leitura Cap\u00edtulo 3 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_862828b3a3464a809cda6f44d9ad2ec9.pdf","title":"L\u00f3gica Sequencial"},{"location":"Util-Aulas/#unidade-logica-aritmetica","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rios D ULA Lab 2 D ULA Lab 1 Projeto associado D ULA Projeto Leitura Cap\u00edtulo 2 - The Elements of Computing Systems https://docs.wixstatic.com/ugd/44046b_f0eaab042ba042dcb58f3e08b46bb4d7.pdf","title":"Unidade L\u00f3gica Aritm\u00e9tica"},{"location":"Util-Aulas/#logica-combinacional","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Laborat\u00f3rio 4 Laborat\u00f3rio 5 Laborat\u00f3rio 6 Laborat\u00f3rio 7","title":"L\u00f3gica Combinacional"},{"location":"Util-Aulas/#transistores-e-circuitos-integrados","text":"04 - Circuitos Integrados Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado sobre Circuitos Integrados 03 - Transistores Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado Transistores MOSFET V\u00eddeos Extra Transistor Logic Gates Livros [Cap. 8 TOCCI, 2011] [Cap 7. FLOYD, 2007]","title":"Transistores e  Circuitos Integrados"},{"location":"Util-Aulas/#algebra-booleana","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista Conte\u00fado de \u00c1lgebra Booleana V\u00eddeos Extra Logic 101 (#11): Truth Tables Logic 101 (#12): Truth Table Practice Livros [Cap1. Cap2. NISAN, 2005] [Cap6. TOCCI, 2011] [Cap1. FLOYD, 2007] [LAING, 2004]","title":"\u00c1lgebra Booleana"},{"location":"Util-Aulas/#organizacao-de-computadores","text":"Sala Sala Casa V\u00eddeo aula Slides Handout Lista V\u00eddeos Extra Khan Academy - Introducing How Computers Work","title":"Organiza\u00e7\u00e3o de Computadores"},{"location":"Util-Dicas-GIT/","text":"Clonando reposit\u00f3rio \u00b6 $ git clone URL_DO_SEU_REP Instalando/Atualizando Z01-tools \u00b6 $ cd SEU_REP $ ./updateZ01tools.sh O script updateZ01tools.sh clona o reposit\u00f3rio http://github.com/Insper/z01-tools e o salva em sua pasta $HOME (/home/user/). O script serve para instalar e/ou atualizar a infra da disciplina, deve ser executado sempre que indicado pelo professor. Configurando upstream (Z01.1 professor) \u00b6 Referenciando reposit\u00f3rio original da disciplina: $ git remote add upstream https://github.com/insper/Z01.1 Atualizando reposit\u00f3rio do grupo \u00b6 Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout master $ git merge upstream/master $ git push origin master","title":"Dicas git"},{"location":"Util-Dicas-GIT/#clonando-repositorio","text":"$ git clone URL_DO_SEU_REP","title":"Clonando reposit\u00f3rio"},{"location":"Util-Dicas-GIT/#instalandoatualizando-z01-tools","text":"$ cd SEU_REP $ ./updateZ01tools.sh O script updateZ01tools.sh clona o reposit\u00f3rio http://github.com/Insper/z01-tools e o salva em sua pasta $HOME (/home/user/). O script serve para instalar e/ou atualizar a infra da disciplina, deve ser executado sempre que indicado pelo professor.","title":"Instalando/Atualizando Z01-tools"},{"location":"Util-Dicas-GIT/#configurando-upstream-z011-professor","text":"Referenciando reposit\u00f3rio original da disciplina: $ git remote add upstream https://github.com/insper/Z01.1","title":"Configurando upstream (Z01.1 professor)"},{"location":"Util-Dicas-GIT/#atualizando-repositorio-do-grupo","text":"Atualizando reposit\u00f3rio do grupo com altera\u00e7\u00f5es feitas no reposit\u00f3rio da disciplina: $ git fetch upstream $ git checkout master $ git merge upstream/master $ git push origin master","title":"Atualizando reposit\u00f3rio do grupo"},{"location":"Util-Infraestrutura/","text":"Os softwares que ser\u00e3o utilizados ao longo do semestre s\u00e3o: Intel Quartus : Software da Intel/ Altera utilizado para programar FPGAs (compilador, IDE, ...). ModelSim : Software da MentorGraphics utilizado para simular HDL (VHDL/Verilog) Python 3 : Para automatizar os testes Java JDK 8 : Java Development Kit Editor de texto : Editor de texto para programa\u00e7\u00e3o em VHDL/Java IDE de programa\u00e7\u00e3o JAVA : Eclipse / IntelliJ IDEA Voc\u00ea ir\u00e1 receber um SSD com Linux e a infra de elementos j\u00e1 instalada. Detalhes dessa instala\u00e7\u00e3o pode se encontrado em: Infraestrutura Detalhada","title":"Infraestrutura"},{"location":"Util-InstructionSet/","text":"Download em PDF","title":"Instruction Set"},{"location":"Util-Resumo-Assembly/","text":"Tipo A LEA - Carregamento Efetivo do Endere\u00e7o Tipo C MOV - Copia Valores ADD - Adi\u00e7\u00e3o de Inteiros SUB - Subtra\u00e7\u00e3o de Inteiros RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa INC - Incrementa Inteiro DEC - Decrementa Inteiro NOT - Nega\u00e7\u00e3o por Complemento de Um NEG - Nega\u00e7\u00e3o por Complemento de dois AND - Operador E (and) OR - Operador OU (or) JMP - Jump JE - Desvia Execu\u00e7\u00e3o se Igual a Zero JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero JG - Desvia Execu\u00e7\u00e3o se Maior que Zero JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero JL - Desvia Execu\u00e7\u00e3o se Menor que Zero JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero NOP - N\u00e3o faz nada (No Operation) Nota\u00e7\u00e3o \u00b6 reg : Registrador ( %A , %D , %S ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....) Instru\u00e7\u00f5es \u00b6 LEA - Carregamento Efetivo do Endere\u00e7o (Valor) \u00b6 leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o lea armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A MOV - Copia Valores \u00b6 movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: S = RAM[A] movw ( % A ), % S ADD - Adi\u00e7\u00e3o de Inteiros \u00b6 addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: S = RAM[A]+D addw ( % A ), % D , % S SUB - Subtra\u00e7\u00e3o de Inteiros \u00b6 subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa \u00b6 rsubw reg/mem/im*, rem/mem, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A INC - Incrementa Inteiro \u00b6 incw reg/mem Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D DEC - Decrementa Inteiro \u00b6 decw reg/mem A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A NOT - Nega\u00e7\u00e3o por Complemento de Um \u00b6 notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D NEG - Nega\u00e7\u00e3o por Complemento de dois \u00b6 negw reg/mem A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A AND - Operador E (and) \u00b6 andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D OR - Operador OU (or) \u00b6 orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D JMP - Jump \u00b6 jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp JE - Desvia Execu\u00e7\u00e3o se Igual a Zero \u00b6 je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % S JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero \u00b6 jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D JG - Desvia Execu\u00e7\u00e3o se Maior que Zero \u00b6 jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % s JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero \u00b6 jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % S JL - Desvia Execu\u00e7\u00e3o se Menor que Zero \u00b6 jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % S JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero \u00b6 jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D NOP - N\u00e3o faz nada (No Operation) \u00b6 nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop Descri\u00e7\u00e3o Detalhada \u00b6 Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D ou %S. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Resumo Assembly"},{"location":"Util-Resumo-Assembly/#notacao","text":"reg : Registrador ( %A , %D , %S ) mem : Acesso a mem\u00f3ria (%A) im : Imediato, pode ser: ( $1 , $0 , $-1 ) const : Constante positiva ( $0 , $9 , ....)","title":"Nota\u00e7\u00e3o"},{"location":"Util-Resumo-Assembly/#instrucoes","text":"","title":"Instru\u00e7\u00f5es"},{"location":"Util-Resumo-Assembly/#lea-carregamento-efetivo-do-endereco-valor","text":"leaw const, reg Restri\u00e7\u00e3o A opera\u00e7\u00e3o de leaw s\u00f3 aceita o registrador %A A instru\u00e7\u00e3o lea armazena o valor passado ( const ) no registrador especificado ; Exemplo: %A = 15 leaw $ 15 , % A","title":"LEA - Carregamento Efetivo do Endere\u00e7o (Valor)"},{"location":"Util-Resumo-Assembly/#mov-copia-valores","text":"movw im*/reg/mem, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o de mov faz na verde uma c\u00f3pia, deixando a origem com o dado original. A instru\u00e7\u00e3o mov, copia o valor da primeira posi\u00e7\u00e3o para a segunda posi\u00e7\u00e3o (terceira e quarta opcional). ; Exemplo: S = RAM[A] movw ( % A ), % S","title":"MOV - Copia Valores"},{"location":"Util-Resumo-Assembly/#add-adicao-de-inteiros","text":"addw reg/mem, reg/mem/im*, reg/mem {, reg/mem, reg/mem} Dica A opera\u00e7\u00e3o permite salvar o resultado em mais de um destino. instru\u00e7\u00e3o add, soma o primeiro valor ao segundo valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: S = RAM[A]+D addw ( % A ), % D , % S","title":"ADD - Adi\u00e7\u00e3o de Inteiros"},{"location":"Util-Resumo-Assembly/#sub-subtracao-de-inteiros","text":"subw reg/mem, rem/mem/im*, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o sub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = D - RAM[A] subw % D , ( % A ), % A","title":"SUB - Subtra\u00e7\u00e3o de Inteiros"},{"location":"Util-Resumo-Assembly/#rsub-subtracao-de-inteiros-reversa","text":"rsubw reg/mem/im*, rem/mem, reg/mem {, reg/mem, reg/mem} A instru\u00e7\u00e3o rsub, subtrai o segundo valor do primeiro valor e armazena o resultado no terceiro par\u00e2metro (quarto e quinto opcional). ; Exemplo: A = RAM[A] - D rsubw % D , ( % A ), % A","title":"RSUB - Subtra\u00e7\u00e3o de Inteiros Reversa"},{"location":"Util-Resumo-Assembly/#inc-incrementa-inteiro","text":"incw reg/mem Restri\u00e7\u00e3o O destino \u00e9 o pr\u00f3prio registrador! A opera\u00e7\u00e3o n\u00e3o permite salvar em um registrador diferente. Dica Se quiser fazer a opera\u00e7\u00e3o de inc e salvar em outro registrador, pode utilizar a opera\u00e7\u00e3o de addw : ; D = A + 1 addw $ 1 , % A , % D A instru\u00e7\u00e3o inc, adiciona um (1) ao valor do registrador ou mem\u00f3ria. ; Exemplo: D = D + 1 incw % D","title":"INC - Incrementa Inteiro"},{"location":"Util-Resumo-Assembly/#dec-decrementa-inteiro","text":"decw reg/mem A instru\u00e7\u00e3o dec, subtrai um (1) do valor do registrador ou mem\u00f3ria. ; Exemplo: A = A-1 decw % A","title":"DEC - Decrementa Inteiro"},{"location":"Util-Resumo-Assembly/#not-negacao-por-complemento-de-um","text":"notw reg A instru\u00e7\u00e3o not, inverte o valor de cada bit do reg origem, ou seja, se um bit tem valor 0 fica com 1 e vice-versa. ; Exemplo: D = !D notw % D","title":"NOT - Nega\u00e7\u00e3o por Complemento de Um"},{"location":"Util-Resumo-Assembly/#neg-negacao-por-complemento-de-dois","text":"negw reg/mem A instru\u00e7\u00e3o neg, faz o valor ficar negativo, ou seja, um valor de x \u00e9 modificado para -x. ; Exemplo: A = -A negw % A","title":"NEG - Nega\u00e7\u00e3o por Complemento de dois"},{"location":"Util-Resumo-Assembly/#and-operador-e-and","text":"andw reg/mem, rem/mem A instru\u00e7\u00e3o and executa o operador l\u00f3gico E (and). ; Exemplo: D = A&D andw % A , % D , % D","title":"AND - Operador E (and)"},{"location":"Util-Resumo-Assembly/#or-operador-ou-or","text":"orw reg/mem, rem/mem A instru\u00e7\u00e3o or executa o operador l\u00f3gico Ou (or). ; Exemplo: D = RAM[A] | D orw ( % A ), % D , % D","title":"OR - Operador OU (or)"},{"location":"Util-Resumo-Assembly/#jmp-jump","text":"jmp A instru\u00e7\u00e3o jmp executa um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A. jmp","title":"JMP - Jump"},{"location":"Util-Resumo-Assembly/#je-desvia-execucao-se-igual-a-zero","text":"je reg A instru\u00e7\u00e3o je faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for igual a zero. je % S","title":"JE - Desvia Execu\u00e7\u00e3o se Igual a Zero"},{"location":"Util-Resumo-Assembly/#jne-desvia-execucao-se-diferente-de-zero","text":"jne reg A instru\u00e7\u00e3o jne faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for diferente de zero. jne % D","title":"JNE - Desvia Execu\u00e7\u00e3o se Diferente de Zero"},{"location":"Util-Resumo-Assembly/#jg-desvia-execucao-se-maior-que-zero","text":"jg reg A instru\u00e7\u00e3o jg desvia, o fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior que zero. jg % s","title":"JG - Desvia Execu\u00e7\u00e3o se Maior que Zero"},{"location":"Util-Resumo-Assembly/#jge-desvia-execucao-se-maior-igual-a-zero","text":"jge reg A instru\u00e7\u00e3o jge faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for maior ou igual a zero. jge % S","title":"JGE - Desvia Execu\u00e7\u00e3o se Maior Igual a Zero"},{"location":"Util-Resumo-Assembly/#jl-desvia-execucao-se-menor-que-zero","text":"jl reg A instru\u00e7\u00e3o jl faz desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor que zero. jl % S","title":"JL - Desvia Execu\u00e7\u00e3o se Menor que Zero"},{"location":"Util-Resumo-Assembly/#jle-desvia-execucao-se-menor-igual-a-zero","text":"jle reg A instru\u00e7\u00e3o jle faz um desvio, no fluxo de execu\u00e7\u00e3o, para o endere\u00e7o armazenado em %A, somente se o valor do reg. for menor ou igual a zero. jle % D","title":"JLE - Desvia Execu\u00e7\u00e3o se Menor Igual a Zero"},{"location":"Util-Resumo-Assembly/#nop-nao-faz-nada-no-operation","text":"nop A instru\u00e7\u00e3o nop n\u00e3o faz nada, usado para pular um ciclo de execu\u00e7\u00e3o. nop","title":"NOP - N\u00e3o faz nada (No Operation)"},{"location":"Util-Resumo-Assembly/#descricao-detalhada","text":"Formato das Instru\u00e7\u00f5es Em Assembly, codificamos uma instru\u00e7\u00e3o por linha e ela \u00e9 constru\u00edda a partir do mnem\u00f4nico da opera\u00e7\u00e3o e seus argumentos. Al\u00e9m disso, temos marcadores de posi\u00e7\u00e3o (endere\u00e7o usado em desvios), constantes e poss\u00edveis vari\u00e1veis. O formato das instru\u00e7\u00f5es na sintaxe AT&T segue o seguinte formato: mnem\u00f4nico origem, destino Registradores Todos os registradores devem ter como prefixo o sinal de porcentagem '%\\', por exemplo: %A ou %D ou %S. Valores Literais Todos os valores literais devem ter como prefixo o sinal de cifr\u00e3o '$\\', por exemplo: $55, $376, sendo o maior valor 2047 (15 bits). Endere\u00e7amento de Mem\u00f3ria Na sintaxe AT&T, a mem\u00f3ria \u00e9 referenciada com par\u00eantese em volta do registrador que armazena o endere\u00e7o: por exemplo (%A). Tamanho dos operadores Algumas instru\u00e7\u00f5es podem trabalhar com diferentes tamanhos de dados, assim as instru\u00e7\u00f5es podem ter um sufixo, informando o tamanho do dado que ir\u00e1 manipular, sendo b (8 bits), w (16 bits) e l (32 bits). Por exemplo: movw $2000, (%A) Instru\u00e7\u00f5es de Transfer\u00eancia de Controle As instru\u00e7\u00f5es de jump, fazem o fluxo do programa desviar de uma posi\u00e7\u00e3o do programa para outra. Para marcar as posi\u00e7\u00f5es no programa, s\u00e3o usados marcadores (labels) que sempre terminam com dois pontos (:). Por exemplo: loop: Registradores virtuais Os s\u00edmbolos R0, ..., R15 s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0, ..., 15 Ponteiros de I/O Os s\u00edmbolos SCREEN e KBD s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 16384 e 24576, respectivamente. Ponteiros de controle da VM Os s\u00edmbolos SP, LCL, ARG, THIS, e THAT s\u00e3o automaticamente predefinidos para se referir aos endere\u00e7os de RAM 0-4, respectivamente. Nota\u00e7\u00f5es: im : valor imediato (somente os valores 1, 0 e -1). reg : registrador. mem: mem\u00f3ria, ou seja (%A). Limita\u00e7\u00f5es: A arquitetura n\u00e3o permite somar o valor da mem\u00f3ria apontada por (%A) com o valor de %A, ou de (%A) com (%A), tampouco %A com %A. N\u00e3o \u00e9 poss\u00edvel somar (ou subtrair, se \u00e9 que isso faz sentido) o registrador com o mesmo, por exemplo somar %D com %D. N\u00e3o \u00e9 poss\u00edvel ler e gravar a mem\u00f3ria ao mesmo tempo. Por exemplo, as instru\u00e7\u00f5es abaixo n\u00e3o funcionam no nosso computador: incw (%A); subw (%A),%D,(%A). Observa\u00e7\u00e3o: A linguagem Assembly apresentada \u00e9 especifica para o processador produzido no curso. Embora muito similar a outras usadas em produtos de mercado, as instru\u00e7\u00f5es possuem limita\u00e7\u00f5es inerentes a cada hardware.","title":"Descri\u00e7\u00e3o Detalhada"},{"location":"Util-Resumo-Labs/","text":"Resumo \u00b6 | Atual | Projeto | ID | Laborat\u00f3rio | Descri\u00e7\u00e3o | |---------------+--------------------------------------------------------------+----+----------------------------------------------------------------+-------------------------------| | | X - Mundo Real | | | | | | J - VM Translator | 17 | J VM Translator Lab 1 | Tradu\u00e7\u00e3o de vm para nasm | | | I - VM | 16 | I VM Lab 1 | Programas em linguagem VM | | | H - Assembler | 15 | H Assembler Lab 1 | Implementando m\u00e9todos em java | | | G - CPU | 14 | G CPU Lab 1 | | | | F - Assembly | 13 | F Assembly Lab 3 | | | | | 12 | F Assembly Lab 2 | | | | | 11 | F Assembly Lab 1 | | | | E - Sequencial | 10 | E Sequencial Lab 1 | | | | D - ULA | 9 | D ULA Lab 1 | | | | | 8 | D ULA Lab 2 | | | | C - L\u00f3gica Combinacional | 7 | C L\u00f3gica Combinacional Lab 2 | | | | | 6 | C L\u00f3gica Combinacional Lab 1 | | | | | 5 | C Combinacional Lab 1 | | | | B - CI | 4 | B CI Lab 2 | | | | | 3 | B Lab 1 | | | | A - Transistores | 2 | A Transistores Lab 2 | | | | | 1 | A Transistores Lab 1 | |","title":"Resumo"},{"location":"Util-Resumo-Labs/#resumo","text":"| Atual | Projeto | ID | Laborat\u00f3rio | Descri\u00e7\u00e3o | |---------------+--------------------------------------------------------------+----+----------------------------------------------------------------+-------------------------------| | | X - Mundo Real | | | | | | J - VM Translator | 17 | J VM Translator Lab 1 | Tradu\u00e7\u00e3o de vm para nasm | | | I - VM | 16 | I VM Lab 1 | Programas em linguagem VM | | | H - Assembler | 15 | H Assembler Lab 1 | Implementando m\u00e9todos em java | | | G - CPU | 14 | G CPU Lab 1 | | | | F - Assembly | 13 | F Assembly Lab 3 | | | | | 12 | F Assembly Lab 2 | | | | | 11 | F Assembly Lab 1 | | | | E - Sequencial | 10 | E Sequencial Lab 1 | | | | D - ULA | 9 | D ULA Lab 1 | | | | | 8 | D ULA Lab 2 | | | | C - L\u00f3gica Combinacional | 7 | C L\u00f3gica Combinacional Lab 2 | | | | | 6 | C L\u00f3gica Combinacional Lab 1 | | | | | 5 | C Combinacional Lab 1 | | | | B - CI | 4 | B CI Lab 2 | | | | | 3 | B Lab 1 | | | | A - Transistores | 2 | A Transistores Lab 2 | | | | | 1 | A Transistores Lab 1 | |","title":"Resumo"},{"location":"Util-Resumo-Projetos/","text":"Resumo \u00b6 Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-Projetos/#resumo","text":"Atual Projeto ID Laborat\u00f3rio Descri\u00e7\u00e3o X - Mundo Real J - VM Translator 17 J VM Translator Lab 1 Tradu\u00e7\u00e3o de vm para nasm I - VM 16 I VM Lab 1 Programas em linguagem VM H - Assembler 15 H Assembler Lab 1 Implementando m\u00e9todos em java G - CPU 14 G CPU Lab 1 F - Assembly 13 F Assembly Lab 3 12 F Assembly Lab 2 11 F Assembly Lab 1 E - Sequencial 10 E Sequencial Lab 1 D - ULA 9 D ULA Lab 1 8 D ULA Lab 2 C - L\u00f3gica Combinacional 7 C L\u00f3gica Combinacional Lab 2 6 C L\u00f3gica Combinacional Lab 1 5 C Combinacional Lab 1 B - CI 4 B CI Lab 2 3 B Lab 1 A - Transistores 2 A Transistores Lab 2 1 A Transistores Lab 1","title":"Resumo"},{"location":"Util-Resumo-VM/","text":"Linguagem VM \u00b6 Nota\u00e7\u00e3o \u00b6 Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False Opera\u00e7\u00f5es \u00b6 add - Adi\u00e7\u00e3o \u00b6 add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> | sub - Subtra\u00e7\u00e3o \u00b6 sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor. neg - Nega\u00e7\u00e3o \u00b6 neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP -> not - not bit a bit \u00b6 and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local. or - Or bit a bit \u00b6 or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. and - and bit a bit \u00b6 and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o. eq - Equal \u00b6 eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> | gt - Greater Than \u00b6 gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. lt - Less Than \u00b6 lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha. Label \u00b6 Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto. Goto \u00b6 Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome Fun\u00e7\u00e3o \u00b6 A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es: Declara\u00e7\u00e3o de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add Chamada de fun\u00e7\u00e3o \u00b6 Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2 Par\u00e2metros \u00b6 Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"VM Linguagem"},{"location":"Util-Resumo-VM/#linguagem-vm","text":"","title":"Linguagem VM"},{"location":"Util-Resumo-VM/#notacao","text":"Pilha : Local onde a opera\u00e7\u00e3o \u00e9 executada Primeiro endere\u00e7o : Dado no topo da pilha Segundo endere\u00e7o : Segundo dado no topo da pilha Stack Pointer : Ponteiro para o endere\u00e7o do dado no topo da pilha ... ... X <- Segundo Valor Y <- Primeiro Valor SP -> Opera\u00e7\u00e3o Argumentos retorno Descri\u00e7\u00e3o add : Adi\u00e7\u00e3o X, Y X X = X + Y sub : Subtra\u00e7\u00e3o X, Y X X = X - Y neg : Nega\u00e7\u00e3o Y Y Y = - Y not : Not bit a bit Y Y Y = ! Y and : And bit a bit X, Y X X = X and Y or : Or bit a bit X, Y X X = X or Y eq : Equal X, Y X X = True if X = Y else False gt : Greater Than X, Y X X = True if X > Y else False lt : Less Than X, Y X X = True if X < Y else False","title":"Nota\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#operacoes","text":"","title":"Opera\u00e7\u00f5es"},{"location":"Util-Resumo-VM/#add-adicao","text":"add X = X + Y A opera\u00e7\u00e3o add adiciona dois valores da pilha, e retorna o resultado no local do segundo valor. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X+Y Y | SP -> SP -> |","title":"add - Adi\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#sub-subtracao","text":"sub X = X-Y A opera\u00e7\u00e3o sub subtrai dois valores da pilha, e retorna o resultado no local do segundo valor.","title":"sub - Subtra\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#neg-negacao","text":"neg Y = -Y A opera\u00e7\u00e3o neg nega (complemento de dois) o valor no topo da pilha, e retorna o resultado no mesmo local. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | X Y | -Y SP -> | SP ->","title":"neg - Nega\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#not-not-bit-a-bit","text":"and Y = !Y A opera\u00e7\u00e3o not inverte (bit a bit) o valor no topo da pilha, e retorna o resultado no mesmo local.","title":"not - not bit a bit"},{"location":"Util-Resumo-VM/#or-or-bit-a-bit","text":"or Y = X or Y A opera\u00e7\u00e3o or aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"or - Or bit a bit"},{"location":"Util-Resumo-VM/#and-and-bit-a-bit","text":"and Y = X and Y A opera\u00e7\u00e3o and aplica um or (bit a bit) com os valores no topo da pilha, e retorna o resultado no segundo endere\u00e7o.","title":"and - and bit a bit"},{"location":"Util-Resumo-VM/#eq-equal","text":"eq X = True se X==Y ou False A opera\u00e7\u00e3o eq verifica se os dois valores no topo da pilha s\u00e3o iguais, re retorna o resultado (True ou False) no segundo valor da pilha. True/false 'True' \u00e9 representando por todos os bits em '1': '0xFFFF' 'False' \u00e9 representando por todos os bits em '0': 0x0000' Pilha Essa opera\u00e7\u00e3o consume os dois valores da pilha, veja exemplo. Pilha ---------------------------------------- | Antes | Depois | -------------------|-------------------- .... | .... X | True/False Y | SP -> SP -> |","title":"eq - Equal"},{"location":"Util-Resumo-VM/#gt-greater-than","text":"gt X = True se X>Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 maior que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"gt - Greater Than"},{"location":"Util-Resumo-VM/#lt-less-than","text":"lt X = True se X<Y ou False A opera\u00e7\u00e3o qt verifica se o valor no topo da pilha \u00e9 menor que o anterior, retorna o resultado (True ou False) no segundo valor da pilha.","title":"lt - Less Than"},{"location":"Util-Resumo-VM/#label","text":"Labels s\u00e3o definidos pelo keyword label seguido de seu nome : label nome S\u00e3o utilizados para endere\u00e7ar o c\u00f3digo em uma condi\u00e7\u00e3o de goto.","title":"Label"},{"location":"Util-Resumo-VM/#goto","text":"Existem dois tipos de GOTO, condicional ( if-goto ) e incondicional ( goto ). No condicional o salto \u00e9 realizado caso a condi\u00e7\u00e3o n\u00e3o for Falsa (verifica sempre o \u00faltimo valor da pilha). goto nome if-goto nome","title":"Goto"},{"location":"Util-Resumo-VM/#funcao","text":"A seguir defini\u00e7\u00f5es de fun\u00e7\u00f5es:","title":"Fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#declaracao-de-funcao","text":"Uma fun\u00e7\u00e3o \u00e9 definida pelo keyword function seguido do seu nome e quantidade de vari\u00e1veis locais n na estrutura a seguir : function nome n Toda fun\u00e7\u00e3o em VM deve possuir um retorno, definido pelo keyword return Exemplo declara\u00e7\u00e3o de fun\u00e7\u00e3o funcion add 2 push argument 0 push argument 1 add","title":"Declara\u00e7\u00e3o de fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#chamada-de-funcao","text":"Uma fun\u00e7\u00e3o em VM \u00e9 chamada pelo keyword: call seguido do nome da fun\u00e7\u00e3o e da quantidade m de par\u00e2metros passados para essa fun\u00e7\u00e3o. call nome m Exemplo chamada de fun\u00e7\u00e3o push constant 3 push constant 2 call m ult 2","title":"Chamada de fun\u00e7\u00e3o"},{"location":"Util-Resumo-VM/#parametros","text":"Os par\u00e2metros de uma fun\u00e7\u00e3o s\u00e3o passados na pr\u00f3pria pilha.","title":"Par\u00e2metros"},{"location":"Util-Status-Travis-Grupos/","text":"GRUPO A B C D E F G H I","title":"Util Status Travis Grupos"},{"location":"Util-VM-MAC/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Mac OS Mojave (mas com o devido cuidado funciona no Windows e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive ou instalador montado (mostrando como unidade), se sim, ejete eles no Finder. Conecte o HD Externo de tipo A (MBR) no Mac OS, neste momento dever\u00e1 aparecer uma mensagem dizendo que o Mac OS n\u00e3o \u00e9 capaz de ler o disco, aten\u00e7\u00e3o, voc\u00ea deve clicar no bot\u00e3o 'Ignorar' Agora, abra o Disk Utility (Utilit\u00e1rio de Disco), ele pode ser encontrado pelo Spotlight ou pelo Launchpad, conforme imagem. Clique no bot\u00e3o Visualizar e selecione Mostrar todos os dispositivos . Agora no menu lateral, voc\u00ea deve ser capaz de ver o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Selecione o HD Externo no Disk Utility e nas informa\u00e7\u00f5es exibidas procure por Dispositivo: diskN , sendo que haver\u00e1 um n\u00famero no lugar do N, no caso da foto \u00e9 disk2 . Verifique qual o n\u00famero em seu Mac OS. Agora, abra um Terminal. E execute o seguinte comando, substituindo o diskN pelo disco corresponde visto anteriormente (deve-se manter o /dev/ inicial). Ele ir\u00e1 solicitar a sua senha do Mac OS, por favor digite. sudo VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk /dev/diskN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Mac OS. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Em seguida, no terminal novamente, digite o comando sudo /Applications/VirtualBox.app/Contents/MacOS/VirtualBox Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert , de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para /Users/SEU_USUARIO/VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM MAC"},{"location":"Util-VM-Windows/","text":"Atrav\u00e9s deste guia, voc\u00ea conseguir\u00e1 criar uma m\u00e1quina virtual no VirtualBox que realiza o boot de um HD Externo, este roteiro foi feito e testado no Windows 10 (mas com o devido cuidado funciona no Mac OS e Linux tamb\u00e9m). Antes, verifique se n\u00e3o h\u00e1 nenhum pendrive, se sim, ejete ele no Windows Explorer. Conecte o HD Externo de tipo A (MBR) no Windows, neste momento dever\u00e1 aparecer uma mensagem dizendo para formatar a unidade para poder utiliza-la, clique em N\u00e3o. Agora, abra o Painel de Controle, procure por Ferramentas Administrativas e em seguida Gerenciamento do Computador (Cuidado para n\u00e3o confundir com Gerenciador de Dispositivos!). Agora no menu lateral, procure por Gerenciamento de Discos, na parte central, voc\u00ea deve ser capaz de ver o seu HD e o HD Externo conectado, caso contr\u00e1rio, verifique a conex\u00e3o USB e certifique-se que clicou no bot\u00e3o Ignorar ao conecta-lo. Com foco no HD Externo e procure pelo n\u00famero do Disco (geralmente fica na parte inferior em baixo do nome, no gr\u00e1fico de barras). Deve haver algo como Disco 2 ou Disco 1 . Agora, abra uma Linha de Comando como Administrador (bot\u00e3o direito, e executar como Administrador). Navegue at\u00e9 a pasta do VirtualBox em C:\\Program Files\\Oracle\\VirtualBox e execute o seguinte comando, substituindo o N pelo n\u00famero de disco corresponde visto anteriormente (deve-se manter o \\.\\PhysicalDrive). VBoxManage internalcommands createrawvmdk -filename Elementos.vmdk -rawdisk \\\\.\\PhysicalDriveN Se tudo ocorrer bem, deve aparecer a mensagem RAW host disk access VMDK file Elementos.vmdk created successfully. Caso sim, continue, caso contr\u00e1rio, verifique o comando digitado. No passo 6, criamos um disco virtual, que na realidade n\u00e3o armazena dados e sim diz ao VirtualBox procurar pelo HD Externo. No entanto, este acesso ao HD Externo em n\u00edvel de parti\u00e7\u00f5es de boot, necessita de acesso de administrador ao computador. Portanto, vamos ter que abrir o VirtualBox como administrador no Windows. Primeiro, certifique-se que o VirtualBox est\u00e1 fechado completamente. Procure qualquer atalho ou no menu Iniciar pelo VirtualBox e clique com bot\u00e3o direito e Executar como Administrador. Com \u00eaxito, a janela do VirtualBox deve aparecer. Clique para criar uma nova m\u00e1quina virtual, clique em seguida no modo Expert, de um nome apropriado a m\u00e1quina virtual, na pasta da m\u00e1quina virtual, sugiro que mude o caminho para C:\\Users\\SEU_USUARIO\\VirtualBox VMs (crie caso n\u00e3o exista). Ele ir\u00e1 utilizar esta pasta apenas para arquivos de configura\u00e7\u00e3o. Troque o Tipo para Linux e Vers\u00e3o para Ubuntu (64-bits). \u00c9 recomend\u00e1vel que aloque pelo menos 4GB (4096 MB) para o sistema. Na op\u00e7\u00e3o de Disco R\u00edgido, escolha a op\u00e7\u00e3o Utilizar um disco virtual existente, e selecione o arquivo Elementos.vmdk criado no passo 6. Clique em Criar. Clique para executar a m\u00e1quina virtual criada, se tudo ocorrer bem, voc\u00ea deve ver o boot do Ubuntu iniciando, n\u00e3o esque\u00e7a depois de ligar, de verificar a resolu\u00e7\u00e3o da tela e se a acelera\u00e7\u00e3o de v\u00eddeo est\u00e1 habilitada.","title":"Util VM Windows"},{"location":"Util-Video-Aulas/","text":"Conte\u00fado de \u00c1lgebra Booleana https://www.youtube.com/watch?v=YYIucfsQKl4 Conte\u00fado Transistores https://www.youtube.com/watch?v=rRg9wdzlPvE Conte\u00fado sobre Circuitos Integrados https://www.youtube.com/watch?v=zX36rn_lIl0 Conte\u00fado sobre L\u00f3gica Combinacional https://www.youtube.com/watch?v=ImFt9YjEHHc Conte\u00fado Dados Digitais https://www.youtube.com/watch?v=dVixMB1uSYA Conte\u00fado de Unidade L\u00f3gica Aritm\u00e9tica https://www.youtube.com/watch?v=zRX3sOtjS10 Conte\u00fado de L\u00f3gica Sequencial https://www.youtube.com/watch?v=lNW2d26S-gI Conte\u00fado de Mem\u00f3rias https://www.youtube.com/watch?v=CAw-cQUZO_g Conte\u00fado de L\u00f3gica de Controle https://www.youtube.com/watch?v=eEXI72tztws Conte\u00fado Linguagem de M\u00e1quina https://www.youtube.com/watch?v=_MhpD0Geqlk Conte\u00fado Assembly https://www.youtube.com/watch?v=xABQNUe3hG0 Conte\u00fado Computador https://www.youtube.com/watch?v=uVgqGkz106Q Conte\u00fado Assembler https://www.youtube.com/watch?v=xFBPHkaFIlk Conte\u00fado M\u00e1quina Virtual https://www.youtube.com/watch?v=U9DRGBVp8Eg Conte\u00fado Pilhas https://www.youtube.com/watch?v=5N0rTGZHdwY Conte\u00fado de Controle https://www.youtube.com/watch?v=Hp4ZwLMvYfg Conte\u00fado Linguagem de Alto N\u00edvel https://www.youtube.com/watch?v=YZucTUVv-n8 Conte\u00fado Linguagem Orientada a Objetos https://www.youtube.com/watch?v=-9Fj-ShFV_8 Conte\u00fado An\u00e1lise L\u00e9xica e Sint\u00e1tica https://www.youtube.com/watch?v=rtHxrs6TC6Y Programa\u00e7\u00e3o de FPGA pelo Quartus https://www.youtube.com/watch?v=QuH2pduAs34 Exemplo MuxVHDLQuartus https://www.youtube.com/watch?v=m3B8Yob3xkE Gravando e atualizando dados numa mem\u00f3ria de uma FPGA pelo Quartus https://www.youtube.com/watch?v=zb4taQX4yL8","title":"V\u00eddeo Aulas"},{"location":"Util-Vixi!-Sou-Scrum-Master/","text":"Voc\u00ea \u00e9 o mediador (Scrum Master) do projeto e n\u00e3o sabe por onde come\u00e7ar? A seguir os passos que devem ser realizados! Atualizar o reposit\u00f3rio com o do professor (upstream) referenciar upstream + fetch & merge + push origin Editar SCRUM_MASTER.json com suas informa\u00e7\u00f5es Ler documenta\u00e7\u00e3o do projeto Configurar Travis para executar teste do projeto ( .travis.yml ) Criar Project no github Agora com o Project criado, vamos adicionar tarefas e delegar. (As tarefas s\u00e3o os m\u00f3dulos a serem implementados). Discuta com os seus colegas Acompanhe o grupo ajudando o pessoal trabalhar, seu papel \u00e9 entregar!! no prazo!!! Na entrega do projeto, todos os issues devem ter sido resolvidos (e arquivados). Todos as tarefas devem ser movidas para done no projects. Com o projeto finalizado: Criar uma tag no git para marcar o commit que tudo funciona, exemplo: git tag Projeto-C + git push --tag Preencher formul\u00e1rio de relato (ir\u00e1 receber por e-mail)","title":"Vixi! Sou Scrum Master"},{"location":"Util-Z01.1-Cheat-Sheet/","text":"DOWNLOAD SOURCE instruction set","title":"Z01.1 Cheat Sheet"},{"location":"X-Processadores-Projeto/","text":"Mundo Real \u00b6 Entregar at\u00e9 o \u00faltimo dia de aula (antes da AF). Esse projeto extra optativo (individual) fornece 15 pontos extras de Hardware e 10 pontos extras de Software . Processadores \u00b6 Voc\u00ea dever\u00e1 escolher um dos processadores listados a seguir ARM Cortex M0 RISC V SPARC V8 AVR Microchip PIC N\u00e3o pode repetir dentro do grupo! N\u00e3o pode ser o mesmo de 2019-1 ( 10 HW e 5 SW ) Estudo \u00b6 E entregar um documento com os itens a seguir: ( 2 HW ) Hist\u00f3rico Hist\u00f3ria da arquitetura Pessoas/ empresas respons\u00e1veis, Impacto hist\u00f3rico, impacto nos concorrentes/ comunidade/ Curiosidades ( 2 HW ) Uso atual Dispositivos e empresas que ainda fazem uso da arquitetura. ( 6 HW ) Arquitetura Descreva a arquitetura interna da CPU Quantidade de registradores Opera\u00e7\u00f5es da ULA Program Cunter (PC) Como \u00e9 realizado o acesso a mem\u00f3ria nessa arquitetura Especificidades Compara\u00e7\u00e3o com o Z01.1 ( 5 SW ) Instru\u00e7\u00f5es Descritivo das instru\u00e7\u00f5es e seus padr\u00f5es Quantidade total de instru\u00e7\u00f5es Diferen\u00e7a com rela\u00e7\u00e3o ao Z01.1 A entrega dever\u00e1 ser feita em PDF com entorno de 4 p\u00e1ginas, al\u00e9m do** documento, uma apresenta\u00e7\u00e3o de 5 minutos dever\u00e1 ser feito para seu professor/colegas de sala (iremos marcar). ( 5 HW / 5 SW ) C\u00f3digo exemplo \u00b6 Desenvolva um programa em assembly que realiza a multiplica\u00e7\u00e3o entre os valores 10 e 15. Dica A maioria dos processadores possuem um simulador online, busque na internet por isso, e desenvolva o programa no simulador.","title":"X - Mundo real"},{"location":"X-Processadores-Projeto/#mundo-real","text":"Entregar at\u00e9 o \u00faltimo dia de aula (antes da AF). Esse projeto extra optativo (individual) fornece 15 pontos extras de Hardware e 10 pontos extras de Software .","title":"Mundo Real"},{"location":"X-Processadores-Projeto/#processadores","text":"Voc\u00ea dever\u00e1 escolher um dos processadores listados a seguir ARM Cortex M0 RISC V SPARC V8 AVR Microchip PIC N\u00e3o pode repetir dentro do grupo! N\u00e3o pode ser o mesmo de 2019-1","title":"Processadores"},{"location":"X-Processadores-Projeto/#10-hw-e-5-sw-estudo","text":"E entregar um documento com os itens a seguir: ( 2 HW ) Hist\u00f3rico Hist\u00f3ria da arquitetura Pessoas/ empresas respons\u00e1veis, Impacto hist\u00f3rico, impacto nos concorrentes/ comunidade/ Curiosidades ( 2 HW ) Uso atual Dispositivos e empresas que ainda fazem uso da arquitetura. ( 6 HW ) Arquitetura Descreva a arquitetura interna da CPU Quantidade de registradores Opera\u00e7\u00f5es da ULA Program Cunter (PC) Como \u00e9 realizado o acesso a mem\u00f3ria nessa arquitetura Especificidades Compara\u00e7\u00e3o com o Z01.1 ( 5 SW ) Instru\u00e7\u00f5es Descritivo das instru\u00e7\u00f5es e seus padr\u00f5es Quantidade total de instru\u00e7\u00f5es Diferen\u00e7a com rela\u00e7\u00e3o ao Z01.1 A entrega dever\u00e1 ser feita em PDF com entorno de 4 p\u00e1ginas, al\u00e9m do** documento, uma apresenta\u00e7\u00e3o de 5 minutos dever\u00e1 ser feito para seu professor/colegas de sala (iremos marcar).","title":"(10 HW e 5 SW) Estudo"},{"location":"X-Processadores-Projeto/#5-hw-5-sw-codigo-exemplo","text":"Desenvolva um programa em assembly que realiza a multiplica\u00e7\u00e3o entre os valores 10 e 15. Dica A maioria dos processadores possuem um simulador online, busque na internet por isso, e desenvolva o programa no simulador.","title":"(5 HW / 5 SW) C\u00f3digo exemplo"}]}